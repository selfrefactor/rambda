{"adjust":{"diffReason":"ramda accepts an array-like object","method":"adjust","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('adjust', function() {\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.adjust(2, R.add(1), args(0, 1, 2, 3)), [0, 1, 3, 3]);\n  });\n});"},"allPass":{"diffReason":"ramda returns a curried function whose arity matches that of the highest-arity predicate","method":"allPass","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('allPass', function() {\n  var odd = function(n) { return n % 2 !== 0; };\n  var lt20 = function(n) { return n < 20; };\n  var gt5 = function(n) { return n > 5; };\n  var plusEq = function(w, x, y, z) { return w + x === y + z; };\n  it('returns a curried function whose arity matches that of the highest-arity predicate', function() {\n    eq(R.allPass([odd, gt5, plusEq]).length, 4);\n    eq(R.allPass([odd, gt5, plusEq])(9, 9, 9, 9), true);\n    eq(R.allPass([odd, gt5, plusEq])(9)(9)(9)(9), true);\n  });\n});"},"anyPass":{"diffReason":"ramda returns a curried function whose arity matches that of the highest-arity predicate","method":"anyPass","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('anyPass', function() {\n  var odd = function(n) { return n % 2 !== 0; };\n  var gt20 = function(n) { return n > 20; };\n  var lt5 = function(n) { return n < 5; };\n  var plusEq = function(w, x, y, z) { return w + x === y + z; };\n  it('returns a curried function whose arity matches that of the highest-arity predicate', function() {\n    eq(R.anyPass([odd, lt5, plusEq]).length, 4);\n    eq(R.anyPass([odd, lt5, plusEq])(6, 7, 8, 9), false);\n    eq(R.anyPass([odd, lt5, plusEq])(6)(7)(8)(9), false);\n  });\n});"},"both":{"diffReason":"ramda supports fantasy-land","method":"both","content":"var S = require('sanctuary');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('both', function() {\n  it('accepts fantasy-land applicative functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.both(Just(true), Just(true)), Just(true));\n    eq(R.both(Just(true), Just(false)), Just(false));\n    eq(R.both(Just(true), Nothing()), Nothing());\n    eq(R.both(Nothing(), Just(false)), Nothing());\n    eq(R.both(Nothing(), Nothing()), Nothing());\n  });\n});"},"clone":{"diffReason":"rambda method work only with objects and arrays","method":"clone","content":"var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('deep clone integers, strings and booleans', function() {\n  it('clones integers', function() {\n    eq(R.clone(-4), -4);\n    eq(R.clone(9007199254740991), 9007199254740991);\n  });\n  it('clones floats', function() {\n    eq(R.clone(-4.5), -4.5);\n    eq(R.clone(0.0), 0.0);\n  });\n  it('clones strings', function() {\n    eq(R.clone('ramda'), 'ramda');\n  });\n  it('clones booleans', function() {\n    eq(R.clone(true), true);\n  });\n});\ndescribe('deep clone objects', function() {\n  it('clones objects with circular references', function() {\n    var x = {c: null};\n    var y = {a: x};\n    var z = {b: y};\n    x.c = z;\n    var clone = R.clone(x);\n    assert.notStrictEqual(x, clone);\n    assert.notStrictEqual(x.c, clone.c);\n    assert.notStrictEqual(x.c.b, clone.c.b);\n    assert.notStrictEqual(x.c.b.a, clone.c.b.a);\n    assert.notStrictEqual(x.c.b.a.c, clone.c.b.a.c);\n    eq(R.keys(clone), R.keys(x));\n    eq(R.keys(clone.c), R.keys(x.c));\n    eq(R.keys(clone.c.b), R.keys(x.c.b));\n    eq(R.keys(clone.c.b.a), R.keys(x.c.b.a));\n    eq(R.keys(clone.c.b.a.c), R.keys(x.c.b.a.c));\n    x.c.b = 1;\n    assert.notDeepEqual(clone.c.b, x.c.b);\n  });\n});\ndescribe('deep clone arrays', function() {\n});\ndescribe('deep clone functions', function() {\n});\ndescribe('built-in types', function() {\n  it('clones RegExp object', function() {\n    R.forEach(function(pattern) {\n      var clone = R.clone(pattern);\n      assert.notStrictEqual(clone, pattern);\n      eq(clone.constructor, RegExp);\n      eq(clone.source, pattern.source);\n      eq(clone.global, pattern.global);\n      eq(clone.ignoreCase, pattern.ignoreCase);\n      eq(clone.multiline, pattern.multiline);\n    }, [/x/, /x/g, /x/i, /x/m, /x/gi, /x/gm, /x/im, /x/gim]);\n  });\n});\ndescribe('deep clone deep nested mixed objects', function() {\n  it('clones array with mutual ref object', function() {\n    var obj = {a: 1};\n    var list = [{b: obj}, {b: obj}];\n    var clone = R.clone(list);\n    assert.strictEqual(list[0].b, list[1].b);\n    assert.strictEqual(clone[0].b, clone[1].b);\n    assert.notStrictEqual(clone[0].b, list[0].b);\n    assert.notStrictEqual(clone[1].b, list[1].b);\n    eq(clone[0].b, {a:1});\n    eq(clone[1].b, {a:1});\n    obj.a = 2;\n    eq(clone[0].b, {a:1});\n    eq(clone[1].b, {a:1});\n  });\n});\ndescribe('deep clone edge cases', function() {\n  it('nulls, undefineds and empty objects and arrays', function() {\n    eq(R.clone(null), null);\n    eq(R.clone(undefined), undefined);\n    assert.notStrictEqual(R.clone(undefined), null);\n    var obj = {};\n    assert.notStrictEqual(R.clone(obj), obj);\n    var list = [];\n    assert.notStrictEqual(R.clone(list), list);\n  });\n});\ndescribe('Let `R.clone` use an arbitrary user defined `clone` method', function() {\n  it('dispatches to `clone` method if present', function() {\n    function ArbitraryClone(x) { this.value = x; }\n    ArbitraryClone.prototype.clone = function() { return new ArbitraryClone(this.value); };\n    var obj = new ArbitraryClone(42);\n    var arbitraryClonedObj = R.clone(obj);\n    eq(arbitraryClonedObj, new ArbitraryClone(42));\n    eq(arbitraryClonedObj instanceof ArbitraryClone, true);\n  });\n});"},"complement":{"diffReason":"ramda supports fantasy-land","method":"complement","content":"var S = require('sanctuary');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('complement', function() {\n  it('accepts fantasy-land functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.complement(Just(true)), Just(false));\n    eq(R.complement(Just(false)), Just(true));\n    eq(R.complement(Nothing()), Nothing());\n  });\n});"},"compose":{"diffReason":"ramda passes context to functions | rambda composed functions have no length","method":"compose","content":"var assert = require('assert');\nvar jsv = require('jsverify');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('compose', function() {\n  it('performs right-to-left function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.compose(R.map, R.multiply, parseInt);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.compose(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.compose(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });\n});\ndescribe('compose properties', function() {\n  jsv.property('composes two functions', jsv.fn(), jsv.fn(), jsv.nat, function(f, g, x) {\n    return R.equals(R.compose(f, g)(x), f(g(x)));\n  jsv.property('associative',  jsv.fn(), jsv.fn(), jsv.fn(), jsv.nat, function(f, g, h, x) {\n    var result = f(g(h(x)));\n    return R.all(R.equals(result), [\n      R.compose(f, g, h)(x),\n      R.compose(f, R.compose(g, h))(x),\n      R.compose(R.compose(f, g), h)(x)\n    ]);\n});"},"concat":{"diffReason":"ramda pass to concat method if present","method":"concat","content":"var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('concat', function() {\n  var z1 = {\n    x: 'z1',\n    concat: function(that) { return this.x + ' ' + that.x; }\n  };\n  var z2 = {\n    x: 'z2'\n  };\n  it('delegates to non-String object with a concat method, as second param', function() {\n    eq(R.concat(z1, z2), 'z1 z2');\n  });\n});"},"cond":{"diffReason":"pass to transformer is not applied in rambda","method":"cond","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('cond', function() {\n  it('forwards all arguments to predicates and to transformers', function() {\n    var fn = R.cond([\n      [function(_, x) { return x === 42; }, function() { return arguments.length; }]\n    ]);\n    eq(fn(21, 42, 84), 3);\n  });\n  it('retains highest predicate arity', function() {\n    var fn = R.cond([\n      [R.nAry(2, R.T), R.T],\n      [R.nAry(3, R.T), R.T],\n      [R.nAry(1, R.T), R.T]\n    ]);\n    eq(fn.length, 3);\n  });\n});"},"curry":{"diffReason":"ramda passes context to functions","method":"curry","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar jsv = require('jsverify');\nvar funcN = require('./shared/funcN');\n\ndescribe('curry', function() {\n  it('properly reports the length of the curried function', function() {\n    var f = R.curry(function(a, b, c, d) {return (a + b * c) / d;});\n    eq(f.length, 4);\n    var g = f(12);\n    eq(g.length, 3);\n    var h = g(3);\n    eq(h.length, 2);\n    eq(g(3, 6).length, 1);\n  });\n  it('preserves context', function() {\n    var ctx = {x: 10};\n    var f = function(a, b) { return a + b * this.x; };\n    var g = R.curry(f);\n    eq(g.call(ctx, 2, 4), 42);\n    eq(g.call(ctx, 2).call(ctx, 4), 42);\n  });\n  it('supports R.__ placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = R.__;\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n  it('supports @@functional/placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n});\ndescribe('curry properties', function() {\n  jsv.property('curries multiple values', funcN(4), jsv.json, jsv.json, jsv.json, jsv.json, function(f, a, b, c, d) {\n    var g = R.curry(f);\n    return R.all(R.equals(f(a, b, c, d)), [\n      g(a, b, c, d),\n      g(a)(b)(c)(d),\n      g(a)(b, c, d),\n      g(a, b)(c, d),\n      g(a, b, c)(d)\n    ]);\n  jsv.property('curries with placeholder', funcN(3), jsv.json, jsv.json, jsv.json, function(f, a, b, c) {\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    var g = R.curry(f);\n    return R.all(R.equals(f(a, b, c)), [\n      g(_, _, c)(a, b),\n      g(a, _, c)(b),\n      g(_, b, c)(a),\n      g(a, _, _)(_, c)(b),\n      g(a, b, _)(c)\n    ]);\n});"},"difference":{"diffReason":"ramda supports negative zero","method":"difference","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('difference', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  var Z = [3, 4, 5, 6, 10];\n  var Z2 = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8];\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.difference([0], [-0]).length, 1);\n    eq(R.difference([-0], [0]).length, 1);\n    eq(R.difference([NaN], [NaN]).length, 0);\n    eq(R.difference([new Just([42])], [new Just([42])]).length, 0);\n  });\n});"},"dropLast":{"diffReason":"ramda method can act as a transducer","method":"dropLast","content":"var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('dropLast', function() {\n  it('can act as a transducer', function() {\n    var dropLast2 = R.dropLast(2);\n    assert.deepEqual(R.into([], dropLast2, [1, 3, 5, 7, 9, 1, 2]), [1, 3, 5, 7, 9]);\n    assert.deepEqual(R.into([], dropLast2, [1]), []);\n  });\n});"},"either":{"diffReason":"ramda supports fantasy-land","method":"either","content":"var S = require('sanctuary');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('either', function() {\n  it('accepts fantasy-land applicative functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.either(Just(true), Just(true)), Just(true));\n    eq(R.either(Just(true), Just(false)), Just(true));\n    eq(R.either(Just(false), Just(false)), Just(false));\n    eq(R.either(Just(true), Nothing()), Nothing());\n    eq(R.either(Nothing(), Just(false)), Nothing());\n    eq(R.either(Nothing(), Nothing()), Nothing());\n  });\n});"},"endsWith":{"diffReason":"rambda doesn't support arrays","method":"endsWith","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('startsWith', function() {\n  it('should return true when an array ends with the provided value', function() {\n    eq(R.endsWith(['c'], ['a', 'b', 'c']), true);\n  });\n  it('should return true when an array ends with the provided values', function() {\n    eq(R.endsWith(['b', 'c'], ['a', 'b', 'c']), true);\n  });\n  it('should return false when an array does not end with the provided value', function() {\n    eq(R.endsWith(['b'], ['a', 'b', 'c']), false);\n  });\n  it('should return false when an array does not end with the provided values', function() {\n    eq(R.endsWith(['a', 'b'], ['a', 'b', 'c']), false);\n  });\n});"},"equals":{"diffReason":"rambda doesn't support recursive data structures, objects with same enumerable properties, map/weakmap type of variables | ramda dispatches to `equals` method recursively","method":"equals","content":"/* global Map, Set, WeakMap, WeakSet */\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('equals', function() {\n  var a = [];\n  var b = a;\n  it('never considers Boolean primitive equal to Boolean object', function() {\n    eq(R.equals(true, new Boolean(true)), false);\n    eq(R.equals(new Boolean(true), true), false);\n    eq(R.equals(false, new Boolean(false)), false);\n    eq(R.equals(new Boolean(false), false), false);\n  });\n  it('never considers number primitive equal to Number object', function() {\n    eq(R.equals(0, new Number(0)), false);\n    eq(R.equals(new Number(0), 0), false);\n  });\n  it('never considers string primitive equal to String object', function() {\n    eq(R.equals('', new String('')), false);\n    eq(R.equals(new String(''), ''), false);\n    eq(R.equals('x', new String('x')), false);\n    eq(R.equals(new String('x'), 'x'), false);\n  });\n  var supportsSticky = false;\n  try { RegExp('', 'y'); supportsSticky = true; } catch (e) {}\n  var supportsUnicode = false;\n  try { RegExp('', 'u'); supportsUnicode = true; } catch (e) {}\n  var listA = [1, 2, 3];\n  var listB = [1, 3, 2];\n  var c = {}; c.v = c;\n  var d = {}; d.v = d;\n  var e = []; e.push(e);\n  var f = []; f.push(f);\n  var nestA = {a:[1, 2, {c:1}], b:1};\n  var nestB = {a:[1, 2, {c:1}], b:1};\n  var nestC = {a:[1, 2, {c:2}], b:1};\n  it('handles recursive data structures', function() {\n    eq(R.equals(c, d), true);\n    eq(R.equals(e, f), true);\n    eq(R.equals(nestA, nestB), true);\n    eq(R.equals(nestA, nestC), false);\n  });\n  it('requires that both objects have the same enumerable properties with the same values', function() {\n    var a1 = [];\n    var a2 = [];\n    a2.x = 0;\n    var b1 = new Boolean(false);\n    var b2 = new Boolean(false);\n    b2.x = 0;\n    var d1 = new Date(0);\n    var d2 = new Date(0);\n    d2.x = 0;\n    var n1 = new Number(0);\n    var n2 = new Number(0);\n    n2.x = 0;\n    var r1 = /(?:)/;\n    var r2 = /(?:)/;\n    r2.x = 0;\n    var s1 = new String('');\n    var s2 = new String('');\n    s2.x = 0;\n    eq(R.equals(a1, a2), false);\n    eq(R.equals(b1, b2), false);\n    eq(R.equals(d1, d2), false);\n    eq(R.equals(n1, n2), false);\n    eq(R.equals(r1, r2), false);\n    eq(R.equals(s1, s2), false);\n  });\n  if (typeof ArrayBuffer !== 'undefined' && typeof Int8Array !== 'undefined') {\n    var typArr1 = new ArrayBuffer(10);\n    typArr1[0] = 1;\n    var typArr2 = new ArrayBuffer(10);\n    typArr2[0] = 1;\n    var typArr3 = new ArrayBuffer(10);\n    var intTypArr = new Int8Array(typArr1);\n    typArr3[0] = 0;\n    it('handles typed arrays', function() {\n      eq(R.equals(typArr1, typArr2), true);\n      eq(R.equals(typArr1, typArr3), false);\n      eq(R.equals(typArr1, intTypArr), false);\n    });\n  }\n  if (typeof Promise !== 'undefined') {\n    it('compares Promise objects by identity', function() {\n      var p = Promise.resolve(42);\n      var q = Promise.resolve(42);\n      eq(R.equals(p, p), true);\n      eq(R.equals(p, q), false);\n    });\n  }\n  if (typeof Map !== 'undefined') {\n    it('compares Map objects by value', function() {\n      eq(R.equals(new Map([]), new Map([])), true);\n      eq(R.equals(new Map([]), new Map([[1, 'a']])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[1, 'a']])), true);\n      eq(R.equals(new Map([[1, 'a'], [2, 'b']]), new Map([[2, 'b'], [1, 'a']])), true);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[2, 'a']])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[1, 'b']])), false);\n      eq(R.equals(new Map([[1, 'a'], [2, new Map([[3, 'c']])]]), new Map([[1, 'a'], [2, new Map([[3, 'c']])]])), true);\n      eq(R.equals(new Map([[1, 'a'], [2, new Map([[3, 'c']])]]), new Map([[1, 'a'], [2, new Map([[3, 'd']])]])), false);\n      eq(R.equals(new Map([[[1, 2, 3], [4, 5, 6]]]), new Map([[[1, 2, 3], [4, 5, 6]]])), true);\n      eq(R.equals(new Map([[[1, 2, 3], [4, 5, 6]]]), new Map([[[1, 2, 3], [7, 8, 9]]])), false);\n    });\n    it('dispatches to `equals` method recursively in Set', function() {\n      var a = new Map();\n      var b = new Map();\n      a.set(a, a);\n      eq(R.equals(a, b), false);\n      a.set(b, b);\n      b.set(b, b);\n      b.set(a, a);\n      eq(R.equals(a, b), true);\n    });\n  }\n  if (typeof Set !== 'undefined') {\n    it('compares Set objects by value', function() {\n      eq(R.equals(new Set([]), new Set([])), true);\n      eq(R.equals(new Set([]), new Set([1])), false);\n      eq(R.equals(new Set([1]), new Set([])), false);\n      eq(R.equals(new Set([1, 2]), new Set([2, 1])), true);\n      eq(R.equals(new Set([1, new Set([2, new Set([3])])]), new Set([1, new Set([2, new Set([3])])])), true);\n      eq(R.equals(new Set([1, new Set([2, new Set([3])])]), new Set([1, new Set([2, new Set([4])])])), false);\n      eq(R.equals(new Set([[1, 2, 3], [4, 5, 6]]), new Set([[1, 2, 3], [4, 5, 6]])), true);\n      eq(R.equals(new Set([[1, 2, 3], [4, 5, 6]]), new Set([[1, 2, 3], [7, 8, 9]])), false);\n    });\n    it('dispatches to `equals` method recursively in Set', function() {\n      var a = new Set();\n      var b = new Set();\n      a.add(a);\n      eq(R.equals(a, b), false);\n      a.add(b);\n      b.add(b);\n      b.add(a);\n      eq(R.equals(a, b), true);\n    });\n  }\n  if (typeof WeakMap !== 'undefined') {\n    it('compares WeakMap objects by identity', function() {\n      var m = new WeakMap([]);\n      eq(R.equals(m, m), true);\n      eq(R.equals(m, new WeakMap([])), false);\n    });\n  }\n  if (typeof WeakSet !== 'undefined') {\n    it('compares WeakSet objects by identity', function() {\n      var s = new WeakSet([]);\n      eq(R.equals(s, s), true);\n      eq(R.equals(s, new WeakSet([])), false);\n    });\n  }\n  it('dispatches to `equals` method recursively', function() {\n    function Left(x) { this.value = x; }\n    Left.prototype.equals = function(x) {\n      return x instanceof Left && R.equals(x.value, this.value);\n    };\n    function Right(x) { this.value = x; }\n    Right.prototype.equals = function(x) {\n      return x instanceof Right && R.equals(x.value, this.value);\n    };\n    eq(R.equals(new Left([42]), new Left([42])), true);\n    eq(R.equals(new Left([42]), new Left([43])), false);\n    eq(R.equals(new Left(42), {value: 42}), false);\n    eq(R.equals({value: 42}, new Left(42)), false);\n    eq(R.equals(new Left(42), new Right(42)), false);\n    eq(R.equals(new Right(42), new Left(42)), false);\n    eq(R.equals([new Left(42)], [new Left(42)]), true);\n    eq(R.equals([new Left(42)], [new Right(42)]), false);\n    eq(R.equals([new Right(42)], [new Left(42)]), false);\n    eq(R.equals([new Right(42)], [new Right(42)]), true);\n  });\n});"},"filter":{"diffReason":"ramda dispatches to `filter` method of object","method":"filter","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar Maybe = require('./shared/Maybe');\n\ndescribe('filter', function() {\n  var even = function(x) {return x % 2 === 0;};\n  it('dispatches to passed-in non-Array object with a `filter` method', function() {\n    var f = {filter: function(f) { return f('called f.filter'); }};\n    eq(R.filter(function(s) { return s; }, f), 'called f.filter');\n  });\n  it('correctly uses fantasy-land implementations', function() {\n    var m1 = Maybe.Just(-1);\n    var m2 = R.filter(function(x) { return x > 0; } , m1);\n    eq(m2.isNothing, true);\n  });\n});"},"flip":{"diffReason":"rambda flip work only for functions with two arguments","method":"flip","content":"var jsv = require('jsverify');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar funcN = require('./shared/funcN');\ndescribe('flip', function() {\n  it('returns a function which inverts the first two arguments to the supplied function', function() {\n    var f = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    var g = R.flip(f);\n    eq(f('a', 'b', 'c'), 'a b c');\n    eq(g('a', 'b', 'c'), 'b a c');\n  });\n  it('returns a curried function', function() {\n    var f = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    var g = R.flip(f)('a');\n    eq(g('b', 'c'), 'b a c');\n  });\n  it('returns a function with the correct arity', function() {\n    var f2 = function(a, b) {return a + ' ' + b;};\n    var f3 = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    eq(R.flip(f2).length, 2);\n    eq(R.flip(f3).length, 3);\n  });\n});\ndescribe('flip properties', function() {\n  jsv.property('inverts first two arguments', funcN(3), jsv.json, jsv.json, jsv.json, function(f, a, b, c) {\n    var g = R.flip(f);\n    return R.equals(f(a, b, c), g(b, a, c));\n  });\n});"},"forEach":{"diffReason":"ramda method dispatches to `forEach` method","method":"forEach","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('forEach', function() {\n  var list = [{x: 1, y: 2}, {x: 100, y: 200}, {x: 300, y: 400}, {x: 234, y: 345}];\n  it('dispatches to `forEach` method', function() {\n    var dispatched = false;\n    var fn = function() {};\n    function DummyList() {}\n    DummyList.prototype.forEach = function(callback) {\n      dispatched = true;\n      eq(callback, fn);\n    };\n    R.forEach(fn, new DummyList());\n    eq(dispatched, true);\n  });\n});"},"groupBy":{"diffReason":"ramda support transforms","method":"groupBy","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar _isTransformer = require('rambda/internal/_isTransformer');\n\ndescribe('groupBy', function() {\n  it('dispatches on transformer objects in list position', function() {\n    var byType = R.prop('type');\n    var xf = {\n      '@@transducer/init': function() { return {}; },\n      '@@transducer/result': function(x) { return x; },\n      '@@transducer/step': R.mergeRight\n    };\n    eq(_isTransformer(R.groupBy(byType, xf)), true);\n  });\n});"},"groupWith":{"method":"groupWith","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('groupWith', function() {\n  it('can be turned into the original list through concatenation', function() {\n    var list = [1, 1, 2, 3, 4, 4, 5, 5];\n    eq(R.unnest(R.groupWith(R.equals, list)), list);\n    eq(R.unnest(R.groupWith(R.complement(R.equals), list)), list);\n    eq(R.unnest(R.groupWith(R.T, list)), list);\n    eq(R.unnest(R.groupWith(R.F, list)), list);\n  });\n  it('also works on strings', function() {\n    eq(R.groupWith(R.equals)('Mississippi'), ['M','i','ss','i','ss','i','pp','i']);\n  });\n});"},"has":{"diffReason":"rambda does check properties from the prototype chain","method":"has","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('has', function() {\n  var fred = {name: 'Fred', age: 23};\n  var anon = {age: 99};\n  it('does not check properties from the prototype chain', function() {\n    var Person = function() {};\n    Person.prototype.age = function() {};\n    var bob = new Person();\n    eq(R.has('age', bob), false);\n  });\n});"},"ifElse":{"diffReason":"rambda doesn't return a curried function","method":"ifElse","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('ifElse', function() {\n  var t = function(a) { return a + 1; };\n  var identity = function(a) { return a; };\n  var isArray = function(a) { return Object.prototype.toString.call(a) === '[object Array]'; };\n  it('returns a function whose arity equals the max arity of the three arguments to `ifElse`', function() {\n    function a0() { return 0; }\n    function a1(x) { return x; }\n    function a2(x, y) { return x + y; }\n    eq(R.ifElse(a0, a1, a2).length, 2);\n    eq(R.ifElse(a0, a2, a1).length, 2);\n    eq(R.ifElse(a1, a0, a2).length, 2);\n    eq(R.ifElse(a1, a2, a0).length, 2);\n    eq(R.ifElse(a2, a0, a1).length, 2);\n    eq(R.ifElse(a2, a1, a0).length, 2);\n  });\n  it('returns a curried function', function() {\n    var v = function(a) { return typeof a === 'number'; };\n    var ifIsNumber = R.ifElse(v);\n    eq(ifIsNumber(t, identity)(15), 16);\n    eq(ifIsNumber(t, identity)('hello'), 'hello');\n    var fn = R.ifElse(R.gt, R.subtract, R.add);\n    eq(fn(2)(7), 9);\n    eq(fn(2, 7), 9);\n    eq(fn(7)(2), 5);\n    eq(fn(7, 2), 5);\n  });\n});"},"includes":{"diffReason":"ramda method pass to `equals` method if available","method":"includes","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('includes', function() {\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.includes(0, [-0]), false);\n    eq(R.includes(-0, [0]), false);\n    eq(R.includes(NaN, [NaN]), true);\n    eq(R.includes(new Just([42]), [new Just([42])]), true);\n  });\n});"},"indexBy":{"diffReason":"ramda method can act as a transducer","method":"indexBy","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('indexBy', function() {\n  it('can act as a transducer', function() {\n    var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];\n    var transducer = R.compose(\n      R.indexBy(R.prop('id')),\n      R.map(R.pipe(\n        R.adjust(0, R.toUpper),\n        R.adjust(1, R.omit(['id']))\n      )));\n    var result = R.into({}, transducer, list);\n    eq(result, {ABC: {title: 'B'}, XYZ: {title: 'A'}});\n  });\n});"},"indexOf":{"diffReason":"ramda method dispatches to `indexOf` method","method":"indexOf","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('indexOf', function() {\n  var input = [1, 2, 3, 4, 5];\n  var list = [1, 2, 3];\n  list[-2] = 4; // Throw a wrench in the gears by assigning a non-valid array index as object property.\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.indexOf(0, [-0]), -1);\n    eq(R.indexOf(-0, [0]), -1);\n    eq(R.indexOf(NaN, [NaN]), 0);\n    eq(R.indexOf(new Just([42]), [new Just([42])]), 0);\n  });\n  it('dispatches to `indexOf` method', function() {\n    function Empty() {}\n    Empty.prototype.indexOf = R.always(-1);\n    function List(head, tail) {\n      this.head = head;\n      this.tail = tail;\n    }\n    List.prototype.indexOf = function(x) {\n      var idx = this.tail.indexOf(x);\n      return this.head === x ? 0 : idx >= 0 ? 1 + idx : -1;\n    };\n    var list = new List('b',\n      new List('a',\n        new List('n',\n          new List('a',\n            new List('n',\n              new List('a',\n                new Empty()\n              )\n            )\n          )\n        )\n      )\n    );\n    eq(R.indexOf('a', 'banana'), 1);\n    eq(R.indexOf('x', 'banana'), -1);\n    eq(R.indexOf('a', list), 1);\n    eq(R.indexOf('x', list), -1);\n  });\n});"},"intersection":{"method":"intersection","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('intersection', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  it('does not allow duplicates in the output even if the input lists had duplicates', function() {\n    eq(R.intersection(M2, N2), [3, 4]);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.intersection([0], [-0]).length, 0);\n    eq(R.intersection([-0], [0]).length, 0);\n    eq(R.intersection([NaN], [NaN]).length, 1);\n    eq(R.intersection([new Just([42])], [new Just([42])]).length, 1);\n  });\n});"},"intersperse":{"method":"intersperse","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('intersperse', function() {\n  it('dispatches', function() {\n    var obj = {intersperse: function(x) { return 'override ' + x; }};\n    eq(R.intersperse('x', obj), 'override x');\n  });\n});"},"isEmpty":{"diffReason":"ramda supports typed arrays","method":"isEmpty","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('isEmpty', function() {\n  it('returns true for empty typed array', function() {\n    eq(R.isEmpty(Uint8Array.from('')), true);\n    eq(R.isEmpty(Float32Array.from('')), true);\n    eq(R.isEmpty(new Float32Array([])), true);\n    eq(R.isEmpty(Uint8Array.from('1')), false);\n    eq(R.isEmpty(Float32Array.from('1')), false);\n    eq(R.isEmpty(new Float32Array([1])), false);\n  });\n});"},"keys":{"diffReason":"ramda method works for primitives","method":"keys","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('keys', function() {\n  var obj = {a: 100, b: [1, 2, 3], c: {x: 200, y: 300}, d: 'D', e: null, f: undefined};\n  function C() { this.a = 100; this.b = 200; }\n  C.prototype.x = function() { return 'x'; };\n  C.prototype.y = 'y';\n  var cobj = new C();\n  it('works for primitives', function() {\n    eq(R.keys(null), []);\n    eq(R.keys(undefined), []);\n    eq(R.keys(55), []);\n    eq(R.keys('foo'), []);\n    eq(R.keys(true), []);\n    eq(R.keys(false), []);\n    eq(R.keys(NaN), []);\n    eq(R.keys(Infinity), []);\n    eq(R.keys([]), []);\n  });\n});"},"lastIndexOf":{"diffReason":"ramda method dispatches to `lastIndexOf` method","method":"lastIndexOf","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('lastIndexOf', function() {\n  var input = [1, 2, 3, 4, 5, 1];\n  var list = ['a', 1, 'a'];\n  list[-2] = 'a'; // Throw a wrench in the gears by assigning a non-valid array index as object property.\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.lastIndexOf(0, [-0]), -1);\n    eq(R.lastIndexOf(-0, [0]), -1);\n    eq(R.lastIndexOf(NaN, [NaN]), 0);\n    eq(R.lastIndexOf(new Just([42]), [new Just([42])]), 0);\n  });\n  it('dispatches to `lastIndexOf` method', function() {\n    function Empty() {}\n    Empty.prototype.lastIndexOf = R.always(-1);\n    function List(head, tail) {\n      this.head = head;\n      this.tail = tail;\n    }\n    List.prototype.lastIndexOf = function(x) {\n      var idx = this.tail.lastIndexOf(x);\n      return idx >= 0 ? 1 + idx : this.head === x ? 0 : -1;\n    };\n    var list = new List('b',\n      new List('a',\n        new List('n',\n          new List('a',\n            new List('n',\n              new List('a',\n                new Empty()\n              )\n            )\n          )\n        )\n      )\n    );\n    eq(R.lastIndexOf('a', 'banana'), 5);\n    eq(R.lastIndexOf('x', 'banana'), -1);\n    eq(R.lastIndexOf('a', list), 5);\n    eq(R.lastIndexOf('x', list), -1);\n  });\n  it('finds function, compared by identity', function() {\n    var f = function() {};\n    var g = function() {};\n    var list = [g, f, g, f];\n    eq(R.lastIndexOf(f, list), 3);\n  });\n});"},"length":{"diffReason":"ramda method supports object with `length` method","method":"length","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('length', function() {\n  it('returns the length of a string', function() {\n    eq(R.length(''), 0);\n    eq(R.length('xyz'), 3);\n  });\n  it('returns NaN for length property of unexpected type', function() {\n    eq(R.identical(NaN, R.length({length: ''})), true);\n    eq(R.identical(NaN, R.length({length: '1.23'})), true);\n    eq(R.identical(NaN, R.length({length: null})), true);\n    eq(R.identical(NaN, R.length({length: undefined})), true);\n    eq(R.identical(NaN, R.length({})), true);\n  });\n});"},"mean":{"method":"mean","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('mean', function() {\n  it('handles array-like object', function() {\n    eq(R.mean((function() { return arguments; })(1, 2, 3)), 2);\n  });\n});"},"partial":{"method":"partial","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('partial', function() {\n  var disc = function(a, b, c) { // note disc(3, 7, 4) => 1\n    return b * b - 4 * a * c;\n  };\n  it('caches the initially supplied arguments', function() {\n    var f = R.partial(disc, [3]);\n    eq(f(7, 4), 1);\n    var g = R.partial(disc, [3, 7]);\n    eq(g(4), 1);\n  });\n  it('correctly reports the arity of the new function', function() {\n    var f = R.partial(disc, [3]);\n    eq(f.length, 2);\n    var g = R.partial(disc, [3, 7]);\n    eq(g.length, 1);\n  });\n});"},"path":{"diffReason":"ramda method supports negative indices","method":"path","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('path', function() {\n  var deepObject = {a: {b: {c: 'c'}}, falseVal: false, nullVal: null, undefinedVal: undefined, arrayVal: ['arr']};\n  it('takes a path that contains negative indices into arrays', function() {\n    eq(R.path(['x', -2], {x: ['a', 'b', 'c', 'd']}), 'c');\n    eq(R.path([-1, 'y'], [{x: 1, y: 99}, {x: 2, y: 98}, {x: 3, y: 97}]), 97);\n  });\n});"},"paths":{"diffReason":"ramda method supports negative indices","method":"paths","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('paths', function() {\n  var obj = {\n    a: {\n      b: {\n        c: 1,\n        d: 2\n      }\n    },\n    p: [{q: 3}, 'Hi'],\n    x: {\n      y: 'Alice',\n      z: [[{}]]\n    }\n  };\n  it('takes a path that contains negative indices into arrays', function() {\n    eq(R.paths([['p', -2, 'q'], ['p', -1]], obj), [3, 'Hi']);\n    eq(R.paths([['p', -4, 'q'], ['x', 'z', -1, 0]], obj), [undefined, {}]);\n  });\n});"},"pipe":{"diffReason":"ramda passes context to functions | rambda composed functions have no length","method":"pipe","content":"var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('pipe', function() {\n  it('performs left-to-right function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.pipe(parseInt, R.multiply, R.map);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.pipe(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.pipe(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });\n});"},"pluck":{"diffReason":"ramda method behaves as a transducer","method":"pluck","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('pluck', function() {\n  var people = [\n    {name: 'Fred', age: 23},\n    {name: 'Wilma', age: 21},\n    {name: 'Pebbles', age: 2}\n  ];\n  it('behaves as a transducer when given a transducer in list position', function() {\n    var numbers = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];\n    var transducer = R.compose(R.pluck('a'), R.map(R.add(1)), R.take(2));\n    eq(R.transduce(transducer, R.flip(R.append), [], numbers), [2, 3]);\n  });\n});"},"prop":{"method":"prop","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('prop', function() {\n  var fred = {name: 'Fred', age: 23};\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.prop(0, deities), 'Cthulhu');\n    eq(R.prop(1, deities), 'Dagon');\n    eq(R.prop(2, deities), 'Yog-Sothoth');\n    eq(R.prop(-1, deities), 'Yog-Sothoth');\n  });\n});"},"propEq":{"diffReason":"ramda method pass to `equals` method if available","method":"propEq","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('propEq', function() {\n  var obj1 = {name: 'Abby', age: 7, hair: 'blond'};\n  var obj2 = {name: 'Fred', age: 12, hair: 'brown'};\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propEq(0, 'Cthulhu', deities), true);\n    eq(R.propEq(1, 'Dagon', deities), true);\n    eq(R.propEq(2, 'Yog-Sothoth', deities), true);\n    eq(R.propEq(-1, 'Yog-Sothoth', deities), true);\n    eq(R.propEq(3, undefined, deities), true);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.propEq('value', 0, {value: -0}), false);\n    eq(R.propEq('value', -0, {value: 0}), false);\n    eq(R.propEq('value', NaN, {value: NaN}), true);\n    eq(R.propEq('value', new Just([42]), {value: new Just([42])}), true);\n  });\n});"},"propIs":{"method":"propIs","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('propIs', function() {\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propIs(String, 0, deities), true);\n    eq(R.propIs(String, 1, deities), true);\n    eq(R.propIs(String, 2, deities), true);\n    eq(R.propIs(String, -1, deities), true);\n    eq(R.propIs(String, 3, deities), false);\n  });\n});"},"propOr":{"method":"propOr","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('propOr', function() {\n  var fred = {name: 'Fred', age: 23};\n  var anon = {age: 99};\n  var nm = R.propOr('Unknown', 'name');\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propOr('Unknown', 0, deities), 'Cthulhu');\n    eq(R.propOr('Unknown', 1, deities), 'Dagon');\n    eq(R.propOr('Unknown', 2, deities), 'Yog-Sothoth');\n    eq(R.propOr('Unknown', -1, deities), 'Yog-Sothoth');\n    eq(R.propOr('Unknown', 3, deities), 'Unknown');\n  });\n});"},"reduce":{"diffReason":"rambda doesn't have `R.reduced` method | ramda method pass to `reduce` method","method":"reduce","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('reduce', function() {\n  var add = function(a, b) {return a + b;};\n  var mult = function(a, b) {return a * b;};\n  it('Prefers the use of the iterator of an object over reduce (and handles short-circuits)', function() {\n    var symIterator = (typeof Symbol !== 'undefined') ? Symbol.iterator : '@@iterator';\n    function Reducible(arr) {\n      this.arr = arr;\n    }\n    Reducible.prototype.reduce = function(f, init) {\n      var acc = init;\n      for (var i = 0; i < this.arr.length; i += 1) {\n        acc = f(acc, this.arr[i]);\n      }\n      return acc;\n    };\n    Reducible.prototype[symIterator] = function() {\n      var a = this.arr;\n      return {\n        _pos: 0,\n        next: function() {\n          if (this._pos < a.length) {\n            var v = a[this._pos];\n            this._pos += 1;\n            return {\n              value: v,\n              done: false\n            };\n          } else {\n            return {\n              done: true\n            };\n          }\n        }\n      };\n    };\n    var xf = R.take(2);\n    var apendingT = { };\n    apendingT['@@transducer/result'] = R.identity;\n    apendingT['@@transducer/step'] = R.flip(R.append);\n    var rfn = xf(apendingT);\n    var list = new Reducible([1, 2, 3, 4, 5, 6]);\n    eq(R.reduce(rfn, [], list), [1, 2]);\n  });\n  it('short circuits with reduced', function() {\n    var addWithMaxOf10 = function(acc, val) {return acc + val > 10 ? R.reduced(acc) : acc + val;};\n    eq(R.reduce(addWithMaxOf10, 0, [1, 2, 3, 4]), 10);\n    eq(R.reduce(addWithMaxOf10, 0, [2, 4, 6, 8]), 6);\n  });\n});"},"reject":{"diffReason":"ramda method dispatches to `filter` method","method":"reject","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('reject', function() {\n  var even = function(x) {return x % 2 === 0;};\n  it('dispatches to `filter` method', function() {\n    function Nothing() {}\n    Nothing.value = new Nothing();\n    Nothing.prototype.filter = function() {\n      return this;\n    };\n    function Just(x) { this.value = x; }\n    Just.prototype.filter = function(pred) {\n      return pred(this.value) ? this : Nothing.value;\n    };\n    var m = new Just(42);\n    eq(R.filter(R.T, m), m);\n    eq(R.filter(R.F, m), Nothing.value);\n    eq(R.reject(R.T, m), Nothing.value);\n    eq(R.reject(R.F, m), m);\n  });\n});"},"slice":{"method":"slice","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('slice', function() {\n  it('handles array-like object', function() {\n    var args = (function() { return arguments; }(1, 2, 3, 4, 5));\n    eq(R.slice(1, 4, args), [2, 3, 4]);\n  });\n});"},"sortBy":{"diffReason":"ramda works with array-like objects","method":"sortBy","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\nvar albums = [\n  {title: 'Art of the Fugue', artist: 'Glenn Gould', genre: 'Baroque'},\n  {title: 'A Farewell to Kings', artist: 'Rush', genre: 'Rock'},\n  {title: 'Timeout', artist: 'Dave Brubeck Quartet', genre: 'Jazz'},\n  {title: 'Fly By Night', artist: 'Rush', genre: 'Rock'},\n  {title: 'Goldberg Variations', artist: 'Daniel Barenboim', genre: 'Baroque'},\n  {title: 'New World Symphony', artist: 'Leonard Bernstein', genre: 'Romantic'},\n  {title: 'Romance with the Unseen', artist: 'Don Byron', genre: 'Jazz'},\n  {title: 'Somewhere In Time', artist: 'Iron Maiden', genre: 'Metal'},\n  {title: 'In Times of Desparation', artist: 'Danny Holt', genre: 'Modern'},\n  {title: 'Evita', artist: 'Various', genre: 'Broadway'},\n  {title: 'Five Leaves Left', artist: 'Nick Drake', genre: 'Folk'},\n  {title: 'The Magic Flute', artist: 'John Eliot Gardiner', genre: 'Classical'}\n];\ndescribe('sortBy', function() {\n  it('sorts array-like object', function() {\n    var args = (function() { return arguments; }('c', 'a', 'b'));\n    var result = R.sortBy(R.identity, args);\n    eq(result[0], 'a');\n    eq(result[1], 'b');\n    eq(result[2], 'c');\n  });\n});"},"startsWith":{"diffReason":"rambda doesn't support arrays","method":"startsWith","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('startsWith', function() {\n  it('should return true when an array starts with the provided value', function() {\n    eq(R.startsWith(['a'], ['a', 'b', 'c']), true);\n  });\n  it('should return true when an array starts with the provided values', function() {\n    eq(R.startsWith(['a', 'b'], ['a', 'b', 'c']), true);\n  });\n  it('should return false when an array does not start with the provided value', function() {\n    eq(R.startsWith(['b'], ['a', 'b', 'c']), false);\n  });\n  it('should return false when an array does not start with the provided values', function() {\n    eq(R.startsWith(['b', 'c'], ['a', 'b', 'c']), false);\n  });\n});"},"symmetricDifference":{"method":"symmetricDifference","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('symmetricDifference', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  var Z = [3, 4, 5, 6, 10];\n  var Z2 = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8];\n  it('does not allow duplicates in the output even if the input lists had duplicates', function() {\n    eq(R.symmetricDifference(M2, N2), [1, 2, 5, 6]);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.symmetricDifference([0], [-0]).length, 2);\n    eq(R.symmetricDifference([-0], [0]).length, 2);\n    eq(R.symmetricDifference([NaN], [NaN]).length, 0);\n    eq(R.symmetricDifference([new Just([42])], [new Just([42])]).length, 0);\n  });\n  it('will not create a \"sparse\" array', function() {\n    eq(R.symmetricDifference(M2, [3]).length, 3);\n  });\n});"},"take":{"diffReason":"rambda doesn't have 'R.into` method","method":"take","content":"var assert = require('assert');\nvar sinon = require('sinon');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('take', function() {\n  it('handles zero correctly (#1224)', function() {\n    eq(R.into([], R.take(0), [1, 2, 3]), []);\n  });\n  it('steps correct number of times', function() {\n    var spy = sinon.spy();\n    R.into([], R.compose(R.map(spy), R.take(2)), [1, 2, 3]);\n    sinon.assert.calledTwice(spy);\n  });\n  it('transducer called for every member of list if `n` is < 0', function() {\n    var spy = sinon.spy();\n    R.into([], R.compose(R.map(spy), R.take(-1)), [1, 2, 3]);\n    sinon.assert.calledThrice(spy);\n  });\n});"},"tap":{"diffReason":"ramda can act as a transducer","method":"tap","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar listXf = require('./helpers/listXf');\nvar _curry2 = require('rambda/internal/_curry2');\n\ndescribe('tap', function() {\n  var pushToList = _curry2(function(lst, x) { lst.push(x); });\n  it('can act as a transducer', function() {\n    var sideEffect = [];\n    var numbers = [1,2,3,4,5];\n    var xf = R.compose(R.map(R.identity), R.tap(pushToList(sideEffect)));\n    eq(R.into([], xf, numbers), numbers);\n    eq(sideEffect, numbers);\n  });\n  it('dispatches to transformer objects', function() {\n    var sideEffect = [];\n    var pushToSideEffect = pushToList(sideEffect);\n    eq(R.tap(pushToSideEffect, listXf), {\n      f: pushToSideEffect,\n      xf: listXf\n    });\n  });\n});"},"toString":{"method":"toString","content":"var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\ndescribe('toString', function() {\n  it('returns the string representation of null', function() {\n    assert.strictEqual(R.toString(null), 'null');\n  });\n  it('returns the string representation of undefined', function() {\n    assert.strictEqual(R.toString(undefined), 'undefined');\n  });\n  it('returns the string representation of a number primitive', function() {\n    assert.strictEqual(R.toString(0), '0');\n    assert.strictEqual(R.toString(-0), '-0');\n    assert.strictEqual(R.toString(1.23), '1.23');\n    assert.strictEqual(R.toString(-1.23), '-1.23');\n    assert.strictEqual(R.toString(1e+23), '1e+23');\n    assert.strictEqual(R.toString(-1e+23), '-1e+23');\n    assert.strictEqual(R.toString(1e-23), '1e-23');\n    assert.strictEqual(R.toString(-1e-23), '-1e-23');\n    assert.strictEqual(R.toString(Infinity), 'Infinity');\n    assert.strictEqual(R.toString(-Infinity), '-Infinity');\n    assert.strictEqual(R.toString(NaN), 'NaN');\n  });\n  it('returns the string representation of a string primitive', function() {\n    assert.strictEqual(R.toString('abc'), '\"abc\"');\n    assert.strictEqual(R.toString('x \"y\" z'), '\"x \\\\\"y\\\\\" z\"');\n    assert.strictEqual(R.toString(\"' '\"), '\"\\' \\'\"');\n    assert.strictEqual(R.toString('\" \"'), '\"\\\\\" \\\\\"\"');\n    assert.strictEqual(R.toString('\\b \\b'), '\"\\\\b \\\\b\"');\n    assert.strictEqual(R.toString('\\f \\f'), '\"\\\\f \\\\f\"');\n    assert.strictEqual(R.toString('\\n \\n'), '\"\\\\n \\\\n\"');\n    assert.strictEqual(R.toString('\\r \\r'), '\"\\\\r \\\\r\"');\n    assert.strictEqual(R.toString('\\t \\t'), '\"\\\\t \\\\t\"');\n    assert.strictEqual(R.toString('\\v \\v'), '\"\\\\v \\\\v\"');\n    assert.strictEqual(R.toString('\\0 \\0'), '\"\\\\0 \\\\0\"');\n    assert.strictEqual(R.toString('\\\\ \\\\'), '\"\\\\\\\\ \\\\\\\\\"');\n  });\n  it('returns the string representation of a Boolean object', function() {\n    assert.strictEqual(R.toString(new Boolean(true)), 'new Boolean(true)');\n    assert.strictEqual(R.toString(new Boolean(false)), 'new Boolean(false)');\n  });\n  it('returns the string representation of a Number object', function() {\n    assert.strictEqual(R.toString(new Number(0)), 'new Number(0)');\n    assert.strictEqual(R.toString(new Number(-0)), 'new Number(-0)');\n  });\n  it('returns the string representation of a String object', function() {\n    assert.strictEqual(R.toString(new String('abc')), 'new String(\"abc\")');\n    assert.strictEqual(R.toString(new String('x \"y\" z')), 'new String(\"x \\\\\"y\\\\\" z\")');\n    assert.strictEqual(R.toString(new String(\"' '\")), 'new String(\"\\' \\'\")');\n    assert.strictEqual(R.toString(new String('\" \"')), 'new String(\"\\\\\" \\\\\"\")');\n    assert.strictEqual(R.toString(new String('\\b \\b')), 'new String(\"\\\\b \\\\b\")');\n    assert.strictEqual(R.toString(new String('\\f \\f')), 'new String(\"\\\\f \\\\f\")');\n    assert.strictEqual(R.toString(new String('\\n \\n')), 'new String(\"\\\\n \\\\n\")');\n    assert.strictEqual(R.toString(new String('\\r \\r')), 'new String(\"\\\\r \\\\r\")');\n    assert.strictEqual(R.toString(new String('\\t \\t')), 'new String(\"\\\\t \\\\t\")');\n    assert.strictEqual(R.toString(new String('\\v \\v')), 'new String(\"\\\\v \\\\v\")');\n    assert.strictEqual(R.toString(new String('\\0 \\0')), 'new String(\"\\\\0 \\\\0\")');\n    assert.strictEqual(R.toString(new String('\\\\ \\\\')), 'new String(\"\\\\\\\\ \\\\\\\\\")');\n  });\n  it('returns the string representation of a Date object', function() {\n    assert.strictEqual(R.toString(new Date('2001-02-03T04:05:06.000Z')), 'new Date(\"2001-02-03T04:05:06.000Z\")');\n    assert.strictEqual(R.toString(new Date('XXX')), 'new Date(NaN)');\n  });\n  it('returns the string representation of an array', function() {\n    assert.strictEqual(R.toString([]), '[]');\n    assert.strictEqual(R.toString([1, 2, 3]), '[1, 2, 3]');\n    assert.strictEqual(R.toString([1, [2, [3]]]), '[1, [2, [3]]]');\n    assert.strictEqual(R.toString(['x', 'y']), '[\"x\", \"y\"]');\n  });\n  it('returns the string representation of an array with non-numeric property names', function() {\n    var xs = [1, 2, 3];\n    xs.foo = 0;\n    xs.bar = 0;\n    xs.baz = 0;\n    assert.strictEqual(R.toString(xs), '[1, 2, 3, \"bar\": 0, \"baz\": 0, \"foo\": 0]');\n  });\n  it('returns the string representation of an arguments object', function() {\n    assert.strictEqual(R.toString((function() { return arguments; })()), '(function() { return arguments; }())');\n    assert.strictEqual(R.toString((function() { return arguments; })(1, 2, 3)), '(function() { return arguments; }(1, 2, 3))');\n    assert.strictEqual(R.toString((function() { return arguments; })(['x', 'y'])), '(function() { return arguments; }([\"x\", \"y\"]))');\n  });\n  it('returns the string representation of a plain object', function() {\n    assert.strictEqual(R.toString({}), '{}');\n    assert.strictEqual(R.toString({foo: 1, bar: 2, baz: 3}), '{\"bar\": 2, \"baz\": 3, \"foo\": 1}');\n    assert.strictEqual(R.toString({'\"quoted\"': true}), '{\"\\\\\"quoted\\\\\"\": true}');\n    assert.strictEqual(R.toString({a: {b: {c: {}}}}), '{\"a\": {\"b\": {\"c\": {}}}}');\n  });\n  it('treats instance without custom `toString` method as plain object', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    assert.strictEqual(R.toString(new Point(1, 2)), '{\"x\": 1, \"y\": 2}');\n  });\n  it('dispatches to custom `toString` method', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    Point.prototype.toString = function() {\n      return 'new Point(' + this.x + ', ' + this.y + ')';\n    };\n    assert.strictEqual(R.toString(new Point(1, 2)), 'new Point(1, 2)');\n    function Just(x) {\n      if (!(this instanceof Just)) {\n        return new Just(x);\n      }\n      this.value = x;\n    }\n    Just.prototype.toString = function() {\n      return 'Just(' + R.toString(this.value) + ')';\n    };\n    assert.strictEqual(R.toString(Just(42)), 'Just(42)');\n    assert.strictEqual(R.toString(Just([1, 2, 3])), 'Just([1, 2, 3])');\n    assert.strictEqual(R.toString(Just(Just(Just('')))), 'Just(Just(Just(\"\")))');\n    assert.strictEqual(R.toString({toString: R.always('x')}), 'x');\n  });\n  it('handles object with no `toString` method', function() {\n    if (typeof Object.create === 'function') {\n      var a = Object.create(null);\n      var b = Object.create(null); b.x = 1; b.y = 2;\n      assert.strictEqual(R.toString(a), '{}');\n      assert.strictEqual(R.toString(b), '{\"x\": 1, \"y\": 2}');\n    }\n  });\n  it('handles circular references', function() {\n    var a = [];\n    a[0] = a;\n    assert.strictEqual(R.toString(a), '[<Circular>]');\n    var o = {};\n    o.o = o;\n    assert.strictEqual(R.toString(o), '{\"o\": <Circular>}');\n    var b = ['bee'];\n    var c = ['see'];\n    b[1] = c;\n    c[1] = b;\n    assert.strictEqual(R.toString(b), '[\"bee\", [\"see\", <Circular>]]');\n    assert.strictEqual(R.toString(c), '[\"see\", [\"bee\", <Circular>]]');\n    var p = {};\n    var q = {};\n    p.q = q;\n    q.p = p;\n    assert.strictEqual(R.toString(p), '{\"q\": {\"p\": <Circular>}}');\n    assert.strictEqual(R.toString(q), '{\"p\": {\"q\": <Circular>}}');\n    var x = [];\n    var y = {};\n    x[0] = y;\n    y.x = x;\n    assert.strictEqual(R.toString(x), '[{\"x\": <Circular>}]');\n    assert.strictEqual(R.toString(y), '{\"x\": [<Circular>]}');\n  });\n});"},"trim":{"diffReason":"ramda trims all ES5 whitespace","method":"trim","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('trim', function() {\n  var test = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFFHello, World!\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n  it('trims all ES5 whitespace', function() {\n    eq(R.trim(test), 'Hello, World!');\n    eq(R.trim(test).length, 13);\n  });\n  if (typeof String.prototype.trim !== 'function') {\n    it('falls back to a shim if String.prototype.trim is not present', function() {\n      eq(R.trim('   xyz  '), 'xyz');\n      eq(R.trim(test), 'Hello, World!');\n      eq(R.trim(test).length, 13);\n      eq(R.trim('\\u200b'), '\\u200b');\n      eq(R.trim('\\u200b').length, 1);\n    });\n  }\n});"},"type":{"diffReason":"ramda returns 'Number' type to NaN input, while rambda returns 'NaN'","method":"type","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('type', function() {\n  // it('\"Arguments\" if given an arguments object', function() {\n  //   var args = (function() { return arguments; }());\n  //   eq(R.type(args), 'Arguments');\n  // });\n  it('\"Number\" if given the NaN value', function() {\n    eq(R.type(NaN), 'Number');\n  });\n});"},"uniq":{"diffReason":"ramda pass to `uniq` method | ramda method uses reference equality for functions","method":"uniq","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('uniq', function() {\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.uniq([-0, -0]).length, 1);\n    eq(R.uniq([0, -0]).length, 2);\n    eq(R.uniq([NaN, NaN]).length, 1);\n    eq(R.uniq([[1], [1]]).length, 1);\n    eq(R.uniq([new Just([42]), new Just([42])]).length, 1);\n  it('handles null and undefined elements', function() {\n    eq(R.uniq([void 0, null, void 0, null]), [void 0, null]);\n  it('uses reference equality for functions', function() {\n    eq(R.uniq([R.add, R.identity, R.add, R.identity, R.add, R.identity]).length, 2);\n});"},"update":{"diffReason":"ramda accepts an array-like object","method":"update","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('update', function() {\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.update(2, 4, args(0, 1, 2, 3)), [0, 1, 4, 3]);\n  });\n});"},"without":{"diffReason":"ramda method act as a transducer | ramda method pass to `equals` method","method":"without","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('without', function() {\n  it('can act as a transducer', function() {\n    eq(R.into([], R.without([1]), [1]), []);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.without([0], [-0]).length, 1);\n    eq(R.without([-0], [0]).length, 1);\n    eq(R.without([NaN], [NaN]).length, 0);\n    eq(R.without([[1]], [[1]]).length, 0);\n    eq(R.without([new Just([42])], [new Just([42])]).length, 0);\n  });\n});"},"xor":{"diffReason":"ramda support empty call of method","method":"xor","content":"var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('xor', function() {\n  it('returns a curried function', function() {\n    eq(R.xor()(true)(true), false);\n    eq(R.xor()(true)(false), true);\n    eq(R.xor()(false)(true), true);\n    eq(R.xor()(false)(false), false);\n  });\n});"}}
