// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generate final readme file 1`] = `
"# Rambda

Faster alternative to **Ramda** - [Documentation](https://selfrefactor.github.io/rambda/#/)

[![CircleCI](https://circleci.com/gh/selfrefactor/rambda/tree/master.svg?style=svg)](https://circleci.com/gh/selfrefactor/rambda/tree/master)
[![codecov](https://codecov.io/gh/selfrefactor/rambda/branch/master/graph/badge.svg)](https://codecov.io/gh/selfrefactor/rambda)
[![dependencies Status](https://david-dm.org/selfrefactor/rambda/status.svg)](https://david-dm.org/selfrefactor/rambda)
![Normal size](https://img.badgesize.io/selfrefactor/rambda/master/dist/rambda.js)
![Gzip size](https://img.badgesize.io/selfrefactor/rambda/master/dist/rambda.js?compression=gzip)

## Example use

\`\`\`javascript
import { compose, map, filter } from 'rambda'

const result = compose(
  map(x => x * 2),
  filter(x => x > 2)
)([1, 2, 3, 4])
// => [6, 8]
\`\`\`

You can test this example in <a href=\\"https://rambda.now.sh?const%20result%20%3D%20R.compose(%0A%20%20R.map(x%20%3D%3E%20x%20*%202)%2C%0A%20%20R.filter(x%20%3D%3E%20x%20%3E%202)%0A)(%5B1%2C%202%2C%203%2C%204%5D)%0A%0A%2F%2F%20%3D%3E%20%5B6%2C%208%5D\\">Rambda's REPL</a>

* [Install](#install)
* [Differences between Rambda and Ramda](#differences-between-rambda-and-ramda)
* [API](#api)
* [Use with ES5](#use-with-es5)
* [Changelog](#changelog)
* [Additional info](#additional-info)

## Rambda's advantages

- Tree-shaking

Currently **Rambda** is more tree-shakable than **Ramda**

---

- Speed

**Rambda** is generally more performant than \`Ramda\` as the [#benchmarks](benchmarks) can prove that.

---

- dot notation for \`R.path\` and \`R.paths\`

Standard usage of \`R.path\` is \`R.path(['a', 'b'], {a: {b: 1} })\`.

In **Rambda** you have the choice to use dot notation(which is arguably more readable):

\`\`\`
R.path('a.b', {a: {b: 1} })
\`\`\`

---

- comma notation for \`R.pick\` and \`R.omit\`

Similar to dot notation, but the separator is comma(\`,\`) instead of dot(\`.\`).

\`\`\`
R.pick('a,b', {a: 1 , b: 2, c: 3} })

// No space allowed between properties
\`\`\`

---

- Typescript included

Typescript definitions are included in the library, in comparison to **Ramda**, where you need to additionally install \`@types/ramda\`.

- More generic methods

\`Ramda\` has an overwhelming list of methods, as one could get lost putting all the methods in one's head. \`Rambda\`'s much smaller number of total methods(124) I see as advantage compared to the 255 of \`Ramda\`.

Ramda methods has plenty of really deep FP Methods, which are in fact quite useful, but they come at the price of added complexity. Such complex logics are in practice rarely needed.

You can [check the list with missing  Ramda methods in Rambda](https://github.com/selfrefactor/rambda/blob/master/files/ramdaMissing.md)  list to assure that \`Rambda\` doesn't have any important misses.

## Install

- **yarn add rambda**

- For UMD usage either use \`./dist/rambda.umd.js\` or following CDN link:

\`\`\`
https://unpkg.com/rambda@4.3.0/dist/rambda.umd.js
\`\`\`

## Differences between Rambda and Ramda

- Rambda's **type** detect async functions and unresolved \`Promises\`. The returned values are \`'Async'\` and \`'Promise'\`.

- Rambda's **type** handle \`NaN\` input, in which case it returns \`\\"NaN\\"\`.

- Rambda's **path** and **paths** accepts dot notation(\`'x.y' same as ['x','y']\`)

- Rambda's **pick** and **omit** accept comma notation(\`'x,y' same as ['x','y']\`)

- Rambda's **map**, **filter**, **reject** and **forEach** can iterate over objects not only arrays.

- Rambda's **map** and **filter** pass array index as second argument when mapping over arrays.

- Rambda's **defaultTo** accept indefinite number of arguments when non curried, i.e. \`R.defaultTo(2, foo, bar, baz)\`.

- Rambda's **adjust**, **all**, **allPass**, **any**, **anyPass**, **findIndex** , **findLastIndex** and **reject** are passing index as second argument to the predicate function.

- Rambda's **startsWith/endsWith** work only with strings, instead with array and strings.

- Rambda's **equals** doesn't protect against circular structures as **Ramda.equals** does.

- Rambda's **flip** works only for functions expecting two arguments.

- Rambda's **partial** doesn't need the input arguments to be wrapped as array.

- Rambda's **filter** returns empty array with bad input(\`null\` or \`undefined\`), while Ramda throws.

- Ramda's **includes** will throw an error if input is neither \`string\` nor \`array\`, while **Rambda** version will return \`false\`.

- Ramda's **clamp** work for letters, while Rambda's method work only for numbers.

> If you need more **Ramda** methods in **Rambda**, you may either submit a \`PR\` or check the extended version of **Rambda** - [Rambdax](https://github.com/selfrefactor/rambdax). In case of the former, you may want to consult with [Rambda contribution guidelines.](CONTRIBUTING.md)

---

## Benchmarks

<details>

<summary>
Click to expand all benchmark results

There are methods which are benchmarked only with \`Ramda\` and \`Rambda\`(i.e. no \`Lodash\`).

Note that some of these methods, are called with and without curring. This is done in order to give more detailed performance feedback.

</summary>

method | Rambda | Ramda | Lodash
--- |--- | --- | ---
 *add* | ğŸš€ Fastest | 28.16% slower | 76.17% slower
 *adjust* | ğŸš€ Fastest | 2.8% slower | ğŸ”³
 *all* | ğŸš€ Fastest | 89.64% slower | ğŸ”³
 *allPass* | ğŸš€ Fastest | 98.48% slower | ğŸ”³
 *any* | ğŸš€ Fastest | 92.1% slower | 29.4% slower
 *anyPass* | ğŸš€ Fastest | 98.67% slower | ğŸ”³
 *append* | ğŸš€ Fastest | 85.14% slower | ğŸ”³
 *applySpec* | ğŸš€ Fastest | 82.9% slower | ğŸ”³
 *assoc* | 76.71% slower | 63.5% slower | ğŸš€ Fastest
 *clone* | ğŸš€ Fastest | 93.55% slower | 88.95% slower
 *compose* | ğŸš€ Fastest | 95.09% slower | 79.91% slower
 *converge* | 72.48% slower | ğŸš€ Fastest | ğŸ”³
 *curry* | ğŸš€ Fastest | 42.95% slower | ğŸ”³
 *curryN* | ğŸš€ Fastest | 22.07% slower | ğŸ”³
 *defaultTo* | ğŸš€ Fastest | 41.61% slower | ğŸ”³
 *drop* | ğŸš€ Fastest | 89.2% slower | ğŸ”³
 *dropLast* | ğŸš€ Fastest | 91.53% slower | ğŸ”³
 *equals* | ğŸš€ Fastest | 84.87% slower | 59.82% slower
 *filter* | ğŸš€ Fastest | 72.63% slower | 11.78% slower
 *find* | ğŸš€ Fastest | 47.89% slower | 60.19% slower
 *findIndex* | ğŸš€ Fastest | 90.6% slower | 84.75% slower
 *flatten* | 10.31% slower | 96.42% slower | ğŸš€ Fastest
 *ifElse* | ğŸš€ Fastest | 23.16% slower | ğŸ”³
 *includes* | ğŸš€ Fastest | 66.8% slower | ğŸ”³
 *indexOf* | ğŸš€ Fastest | 69.38% slower | 0.64% slower
 *init* | ğŸš€ Fastest | 94.17% slower | 2.63% slower
 *is* | ğŸš€ Fastest | 44.05% slower | ğŸ”³
 *isEmpty* | 37.68% slower | 92.85% slower | ğŸš€ Fastest
 *last* | ğŸš€ Fastest | 99.02% slower | 3.5% slower
 *lastIndexOf* | ğŸš€ Fastest | 45.56% slower | ğŸ”³
 *map* | ğŸš€ Fastest | 87.72% slower | 23.59% slower
 *match* | ğŸš€ Fastest | 52.01% slower | ğŸ”³
 *merge* | ğŸš€ Fastest | 29.34% slower | 67.66% slower
 *none* | ğŸš€ Fastest | 66.57% slower | ğŸ”³
 *omit* | ğŸš€ Fastest | 72.93% slower | 97.97% slower
 *over* | ğŸš€ Fastest | 56.26% slower | ğŸ”³
 *path* | 0.34% slower | 52.76% slower | ğŸš€ Fastest
 *pick* | ğŸš€ Fastest | 24.06% slower | 88.13% slower
 *prop* | ğŸš€ Fastest | 94.38% slower | ğŸ”³
 *propEq* | ğŸš€ Fastest | 90.34% slower | ğŸ”³
 *range* | ğŸš€ Fastest | 63.45% slower | 50.56% slower
 *reduce* | 71.84% slower | 84.24% slower | ğŸš€ Fastest
 *repeat* | 55.51% slower | 83.45% slower | ğŸš€ Fastest
 *replace* | ğŸš€ Fastest | 35.85% slower | 4.98% slower
 *set* | ğŸš€ Fastest | 57.61% slower | ğŸ”³
 *sort* | ğŸš€ Fastest | 28.43% slower | ğŸ”³
 *sortBy* | ğŸš€ Fastest | 16.52% slower | 72.48% slower
 *split* | ğŸš€ Fastest | 56.27% slower | 28.78% slower
 *splitEvery* | ğŸš€ Fastest | 74.75% slower | ğŸ”³
 *take* | ğŸš€ Fastest | 96% slower | 26.07% slower
 *takeLast* | ğŸš€ Fastest | 96.37% slower | 28.53% slower
 *test* | ğŸš€ Fastest | 86.86% slower | ğŸ”³
 *type* | 19.76% slower | ğŸš€ Fastest | ğŸ”³
 *uniq* | 99.56% slower | 96.54% slower | ğŸš€ Fastest
 *update* | ğŸš€ Fastest | 87.94% slower | ğŸ”³
 *view* | ğŸš€ Fastest | 69.35% slower | ğŸ”³

</details>

## Used by

- [WatermelonDB](https://github.com/Nozbe/WatermelonDB)

- [SAP's Cloud SDK](https://github.com/SAP/cloud-sdk)

- [VSCode Slack intergration](https://github.com/verydanny/vcslack)

- [Webpack PostCSS](https://github.com/sectsect/webpack-postcss)

- [MobX-State-Tree decorators](https://github.com/farwayer/mst-decorators)

- [Mobx decorators](https://github.com/farwayer/mobx-decorators)


## API

### add

> add(a: number, b: number): number

It adds \`a\` and \`b\`. It doesn't work with strings, as the inputs are parsed to numbers before calculation.

\`\`\`javascript
R.add(2, 3) // =>  5
\`\`\`

<details>

<summary>Tests</summary>

\`\`\`javascript
import { add } from './add'

test('with number', () => {
  expect(add(2, 3)).toEqual(5)
  expect(add(7)(10)).toEqual(17)
})

test('string is bad input', () => {
  expect(add('foo', 'bar')).toBeNaN()
})

test('ramda specs', () => {
  expect(add('1', '2'),).toEqual(3)
  expect(add(1, '2'),).toEqual(3)
  expect(add(true, false),).toEqual(1)
  expect(add(null, null),).toEqual(0)
  expect(add(undefined, undefined),).toEqual(NaN)
  expect(add(new Date(1), new Date(2)),).toEqual(3)
})
\`\`\`

</details>

<details>

<summary>Typescript test</summary>

\`\`\`typescript
import {add} from 'rambda'

describe('add', () => {
  it('number', () => {
    const resultA = add(4)(1) // $ExpectType number
    resultA // $ExpectType number
    const resultB = add(4, 1) // $ExpectType number
    resultB // $ExpectType number
  })
})
\`\`\`

</details>

<a href=\\"https://rambda.now.sh?const%20result%20%3D%20R.add(2%2C%203)%20%2F%2F%20%3D%3E%20%205\\">Try <strong>R.add</strong> in REPL</a>

### adjust

> adjust<T>(index: number, replaceFn: (a: T) => T, list: ReadonlyArray<T>): T[]

It replaces \`index\` in array \`list\` with the result of \`replaceFn(arr[i])\`.

\`\`\`javascript
R.adjust(
  0,
  a => a + 1,
  [0, 100]
) // => [1, 100]
\`\`\`

<details>

<summary>Tests</summary>

\`\`\`javascript
import { add } from './add'
import { adjust } from './adjust'

const expected = [ 0, 11, 2 ]

test('without curring', () => {
  expect(adjust(
    1, add(10), [ 0, 1, 2 ]
  )).toEqual(expected)
})

test('with curring type 1 1 1', () => {
  expect(adjust(1)(add(10))([ 0, 1, 2 ])).toEqual(expected)
})

test('with curring type 1 2', () => {
  expect(adjust(1)(add(10), [ 0, 1, 2 ])).toEqual(expected)
})

test('with curring type 2 1', () => {
  expect(adjust(1, add(10))([ 0, 1, 2 ])).toEqual(expected)
})

test('with negative index', () => {
  expect(adjust(
    -2, add(10), [ 0, 1, 2 ]
  )).toEqual(expected)
})

test('when index is out of bounds', () => {
  const list = [ 0, 1, 2, 3 ]
  expect(adjust(
    4, add(1), list
  )).toEqual(list)
  expect(adjust(
    -5, add(1), list
  )).toEqual(list)
})
\`\`\`

</details>

<details>

<summary> Failed Ramda.adjust specs

> Reason for the failure: ramda accepts an array-like object
</summary>

\`\`\`javascript
var R = require('../../../../dist/rambda.js');
var eq = require('./shared/eq');

describe('adjust', function() {
  it('accepts an array-like object', function() {
    function args() {
      return arguments;
    }
    eq(R.adjust(2, R.add(1), args(0, 1, 2, 3)), [0, 1, 3, 3]);
  });
});
\`\`\`


</details>

<a href=\\"https://rambda.now.sh?const%20result%20%3D%20R.adjust(%0A%20%200%2C%0A%20%20a%20%3D%3E%20a%20%2B%201%2C%0A%20%20%5B0%2C%20100%5D%0A)%20%2F%2F%20%3D%3E%20%5B1%2C%20100%5D\\">Try <strong>R.adjust</strong> in REPL</a>

### all

> all<T>(predicate: (x: T) => boolean, list: ReadonlyArray<T>): boolean

It returns \`true\`, if all members of array \`list\` returns \`true\`, when applied as argument to \`predicate\` function.

\`\`\`javascript
const list = [ 0, 1, 2, 3, 4 ]
const predicate = x => x > -1

const result = R.all(fn, arr)
// => true
\`\`\`

<details>

<summary>Tests</summary>

\`\`\`javascript
import { all } from './all'

const numArr = [ 0, 1, 2, 3, 4 ]

test('when true', () => {
  const fn = x => x > -1

  expect(all(fn)(numArr)).toBeTrue()
})

test('when false', () => {
  const fn = x => x > 2

  expect(all(fn, numArr)).toBeFalse()
})

test('pass index as second argument', () => {
  const indexes = []
  const fn = (x, i) => {
    indexes.push(i)

    return x > 5
  }
  all(fn, [ 10, 12, 14 ])

  expect(indexes).toEqual([ 0, 1, 2 ])
})
\`\`\`

</details>

<details>

<summary>Typescript test</summary>

\`\`\`typescript
import {all} from 'rambda'

describe('all', () => {
  it('happy', () => {
    const x = all<number>(y => {
      y // $ExpectType number
      return y > 0
    })([1, 2, 3])
    x // $ExpectType boolean

    const q = all(y => y > 0, [1, 2, 3]) // $ExpectType boolean

    q // $ExpectType boolean
  })
})
\`\`\`

</details>

<a href=\\"https://rambda.now.sh?const%20list%20%3D%20%5B%200%2C%201%2C%202%2C%203%2C%204%20%5D%0Aconst%20predicate%20%3D%20x%20%3D%3E%20x%20%3E%20-1%0A%0Aconst%20result%20%3D%20R.all(fn%2C%20arr)%0A%2F%2F%20%3D%3E%20true\\">Try <strong>R.all</strong> in REPL</a>

### allPass

> allPass<T>(predicates: ((x: T) => boolean)[]): (input: T) => boolean



### always

> always<T>(x: T): () => T



### and

> and<T extends { and?: ((...a: readonly any[]) => any)



### any

> any<T>(fn: (x: T, i: number) => boolean, arr: ReadonlyArray<T>): boolean



### anyPass

> anyPass<T>(preds: ReadonlyArray<SafePred<T>>): SafePred<T>



### append

> append<T>(el: T, list: ReadonlyArray<T>): T[]



### applySpec

> applySpec<Obj extends Record<string, (...args: readonly any[]) => any>>(
  obj: Obj
): (
    ...args: Parameters<ValueOfRecord<Obj>>
  ) => { [Key in keyof Obj]: ReturnType<Obj[Key]> }



### assoc

> assoc<T, U, K extends string>(prop: K, value: T, obj: U): Record<K, T> & U



### assocPath

> assocPath<T, U>(path: Path, val: T, obj: U): U



### both

> both(pred1: Pred, pred2: Pred): Pred



### clamp

> clamp(min: number, max: number, input: number): number



### clone

> clone<T>(value: T): T



### complement

> complement(pred: (...args: any[]) => boolean): (...args: any[]) => boolean



### compose

> compose<T1>(fn0: () => T1): () => T1



### concat

> concat<T>(x: ReadonlyArray<T>, y: ReadonlyArray<T>): T[]



### cond

> cond(fns: [Pred, (...a: readonly any[]) => any][]): (...a: readonly any[]) => any



### curry

> curry<F extends (...args: any) => any>(f: F): FToolbelt.Curry<F>



### dec

> dec(n: number): number



### defaultTo

> defaultTo<T>(defaultValue: T): (...inputArguments: (T | null | undefined)[]) => T



### difference

> difference<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]



### dissoc

> dissoc<T>(prop: string, obj: any): T



### divide

> divide(a: number, b: number): number



### drop

> drop<T>(howManyToDrop: number, arrOrStr: ReadonlyArray<T>): T[]



### dropLast

> dropLast<T>(howManyToDrop: number, arrOrStr: ReadonlyArray<T>): T[]



### either

> either(pred1: Pred, pred2: Pred): Pred



### endsWith

> endsWith(a: string, list: string): boolean



### equals

> equals<T>(a: T, b: T): boolean



### F

> F(): boolean



### filter

> filter<T>(filterFn: FilterFunctionArray<T>): (x: T[]) => T[]



### find

> find<T>(findFn: (a: T) => boolean, arr: ReadonlyArray<T>): T | undefined



### findIndex

> findIndex<T>(findFn: (a: T) => boolean, arr: ReadonlyArray<T>): number



### flatten

> flatten<T>(x: ReadonlyArray<T> | ReadonlyArray<T[]> | ReadonlyArray<ReadonlyArray<T>>): T[]



### flip

> flip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult



### forEach

> forEach<T>(fn: (x: T) => void, list: T[]): T[]



### fromPairs

> fromPairs<V>(pairs: KeyValuePair<string, V>[]): { [index: string]: V }



### groupBy

> groupBy<T>(fn: (a: T) => string, list: ReadonlyArray<T>): { [index: string]: T[] }



### groupWith

> groupWith<T>(fn: (x: T, y: T) => boolean): (list: ReadonlyArray<T>) => T[][]



### has

> has<T>(prop: string, obj: T): boolean



### head

> head<T>(arrOrStr: T[]): T | undefined



### identical

> identical<T>(a: T, b: T): boolean



### identity

> identity<T>(x: T): T



### ifElse

> ifElse(fn: Pred, onTrue: Arity1Fn, onFalse: Arity1Fn): Arity1Fn



### inc

> inc(n: number): number



### includes

> includes(valueToFind: string, input: ReadonlyArray<string> | string): boolean



### indexBy

> indexBy<T>(condition: (a: T) => string, arr: ReadonlyArray<T>): { [key: string]: T }



### indexOf

> indexOf<T>(target: T, arr: ReadonlyArray<T>): number



### init

> init<T>(arrOrStr: ReadonlyArray<T>): T[]



### intersection

> intersection<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]



### intersperse

> intersperse<T>(separator: T, list: ReadonlyArray<T>): T[]



### is

> is(xPrototype: any, x: any): boolean



### isEmpty

> isEmpty<T>(input: T): boolean



### isNil

> isNil(x: any): x is null | undefined



### join

> join(x: string, xs: ReadonlyArray<any>): string



### keys

> keys<T extends object>(x: T): (keyof T)[]



### last

> last<T>(arrOrStr: T[]): T | undefined



### lastIndexOf

> lastIndexOf<T>(x: T, arr: ReadonlyArray<T>): number



### length

> length<T>(list: ReadonlyArray<T>): number



### lens

> lens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens



### lensIndex

> lensIndex(n: number): Lens



### lensProp

> lensProp(str: string): {
  <T, U>(obj: T): U



### map

> map<T, U>(mapFn: MapFunctionObject<T, U>, x: Dictionary<T>): Dictionary<U>



### match

> match(regexp: RegExp, str: string): any[]



### max

> max<T extends Ord>(a: T, b: T): T



### maxBy

> maxBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T



### mean

> mean(list: ReadonlyArray<number>): number



### median

> median(list: ReadonlyArray<number>): number



### merge

> merge<T1, T2>(a: T1, b: T2): Merge<T2, T1>



### min

> min<T extends Ord>(a: T, b: T): T



### minBy

> minBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T



### modulo

> modulo(a: number, b: number): number



### multiply

> multiply(a: number, b: number): number



### negate

> negate(a: number): number



### none

> none<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): boolean



### not

> not(x: any): boolean



### nth

> nth<T>(n: number, list: ReadonlyArray<T>): T | undefined



### omit

> omit<T>(propsToOmit: string | string[], obj: Dictionary<T>): Dictionary<T>



### over

> over<T>(lens: Lens, fn: Arity1Fn, value: T): T



### partial

> partial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, x0: V0): (x1: V1) => T



### path

> path<Input, T>(pathToSearch: string | string[], obj: Input): T | undefined



### pathOr

> pathOr<T>(defaultValue: T, pathToSearch: Path, obj: any): T



### paths

> paths<Input, T>(pathsToSearch: (string | string[])[], obj: Input): (T | undefined)[]



### pick

> pick<T>(propsToPick: string | string[], obj: Dictionary<T>): Dictionary<T>



### pickAll

> pickAll<T, U>(names: ReadonlyArray<string>, obj: T): U



### pipe

> pipe<T1>(fn0: () => T1): () => T1



### pluck

> pluck<T>(property: number, arr: ReadonlyArray<T>): T



### prepend

> prepend<T>(x: T, arr: ReadonlyArray<T>): T[]



### product

> product(list: ReadonlyArray<number>): number



### prop

> prop<P extends keyof T, T>(propToFind: P, obj: T): T[P]



### propEq

> propEq<T>(propToFind: string | number, valueToMatch: T, obj: any): boolean



### propIs

> propIs<P extends keyof T, T>(type: any, name: P, obj: T): boolean



### propOr

> propOr<T, U, V>(val: T, p: string, obj: U): V



### range

> range(start: number, end: number): number[]



### reduce

> reduce<T, TResult>(fn: (acc: TResult, elem: T, i: number) => TResult, acc: TResult, list: ReadonlyArray<T>): TResult



### reject

> reject<T>(filterFn: FilterFunctionArray<T>): (x: T[]) => T[]



### repeat

> repeat<T>(a: T, n: number): T[]



### replace

> replace(strOrRegex: RegExp | string, replacer: string, str: string): string



### reverse

> reverse<T>(list: ReadonlyArray<T>): T[]



### set

> set<T, U>(lens: Lens, a: U, obj: T): T



### slice

> slice(a: number, b: number, list: string): string



### sort

> sort<T>(sortFn: (a: T, b: T) => number, arr: ReadonlyArray<T>): T[]



### sortBy

> sortBy<T>(sortFn: (a: T) => Ord, arr: ReadonlyArray<T>): T[]



### split

> split(sep: string | RegExp): (str: string) => string[]



### splitEvery

> splitEvery<T>(a: number, list: ReadonlyArray<T>): T[][]



### startsWith

> startsWith(a: string, list: string): boolean



### subtract

> subtract(a: number, b: number): number



### sum

> sum(list: ReadonlyArray<number>): number



### symmetricDifference

> symmetricDifference<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]



### T

> T(): boolean



### tail

> tail<T>(arrOrStr: ReadonlyArray<T>): T[]



### take

> take<T>(num: number, arrOrStr: ReadonlyArray<T>): T[]



### takeLast

> takeLast<T>(num: number, arrOrStr: ReadonlyArray<T>): T[]



### tap

> tap<T>(fn: (a: T) => any, value: T): T



### test

> test(regExpression: RegExp): (str: string) => boolean



### times

> times<T>(fn: (i: number) => T, n: number): T[]



### toLower

> toLower(str: string): string



### toPairs

> toPairs<S>(obj: { [k: string]: S } | { [k: number]: S }): [string, S][]



### toString

> toString<T>(val: T): string



### toUpper

> toUpper(str: string): string



### transpose

> transpose<T>(list: T[][]): T[][]



### trim

> trim(str: string): string



### type

> type(val: any): \\"Object\\" | \\"Number\\" | \\"Boolean\\" | \\"String\\" | \\"Null\\" | \\"Array\\" | \\"Function\\" | \\"Undefined\\" | \\"Async\\" | \\"Promise\\" | \\"RegExp\\" | \\"NaN\\"



### uniq

> uniq<T>(arr: ReadonlyArray<T>): T[]



### uniqWith

> uniqWith<T, U>(fn: (x: T, y: T) => boolean, arr: ReadonlyArray<T>): T[]



### update

> update<T>(index: number, value: T, list: ReadonlyArray<T>): T[]



### values

> values<T extends object, K extends keyof T>(obj: T): T[K][]



### view

> view<T, U>(lens: Lens): (obj: T) => U



### without

> without<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]



### xor

> xor(a: boolean, b: boolean): boolean



### zip

> zip<K, V>(list1: ReadonlyArray<K>, list2: ReadonlyArray<V>): KeyValuePair<K, V>[]



### zipObj

> zipObj<T>(keys: ReadonlyArray<string>, values: ReadonlyArray<T>): { [index: string]: T }




## CHANGELOG

- 5.1.1

Release new documentation site

Deprecate docsify

- 5.1.0

Add \`R.converge\` and \`R.curryN\` from [PR #412](https://github.com/selfrefactor/rambda/pull/412)

> Close [Issue #410](https://github.com/selfrefactor/rambda/issues/410) - wrong implementation of \`R.groupWith\`

> Close [Issue #411](https://github.com/selfrefactor/rambda/issues/411) - change the order of declared \`R.map\` typings rules

- 5.0.0

Move \`R.partialCurry\` to Rambdax(reason for major bump).

Use new type of export in Typescript definitions.

Approve [PR #381](https://github.com/selfrefactor/rambda/pull/381) - add \`R.applySpec\`

- 4.6.0

Approve [PR #375](https://github.com/selfrefactor/rambda/pull/375) - add lenses(Thank you [@synthet1c](https://github.com/synthet1c))

Add \`R.lens\`

Add \`R.lensIndex\`

Add \`R.lensPath\`

Add \`R.lensProp\`

Add \`R.over\`

Add \`R.set\`

Add \`R.view\`

> Sync with Ramda 0.27

Add \`R.paths\`

Add \`R.xor\`

> Close [Issue #373](https://github.com/selfrefactor/rambda/issues/373)

Add \`R.cond\`

- 4.5.0 Add \`R.clamp\`

- 4.4.2 Improve \`R.propOr\` typings

- 4.4.1 Make \`R.reject\` has the same typing as \`R.filter\`

- 4.4.0 Several changes:

Close [Issue #317](https://github.com/selfrefactor/rambda/issues/317) - add \`R.transpose\`

Close [Issue #325](https://github.com/selfrefactor/rambda/issues/325) - \`R.filter\` should return equal values for bad inputs \`null\` and \`undefined\`

Approve suggestion for \`R.indexBy\` to accept string not only function as first argument.

Edit of \`R.path\` typings

- 4.2.0 Approve [PR #314](https://github.com/selfrefactor/rambda/pull/314) - add \`R.and\`

- 4.1.1 Add missing typings for \`R.slice\`

- 4.1.0 Add \`R.findLast\` and \`R.findLastIndex\`

- 4.0.2 Fix \`R.isEmpty\` wrong behaviour compared to the Ramda method

- 4.0.1 Approve [PR #289](https://github.com/selfrefactor/rambda/pull/289) - remove console.log in \`R.values\` method

- 4.0.0 Multiple breaking changes as Rambda methods are changed in order to increase the similarity between with Ramda

Add to \`Differences\`:

\`\`\`text
R.type can return 'NaN'

R.compose doesn't pass \`this\` context

R.clone doesn't work with number, booleans and strings as input
\`\`\`

All breaking changes:

-- R.add works only with numbers

-- Fix R.adjust which had wrong order of arguments

-- R.adjust works when index is out of bounds

-- R.complement support function with multiple arguments

-- R.compose/pipe throws when called with no argument

-- R.clone works with \`Date\` value as input

-- R.drop/dropLast/take/takeLast always return new copy of the list/string

-- R.take/takeLast return original list/string with negative index

-- R.equals handles \`NaN\` and \`RegExp\` types

-- R.type/R.equals supports \`new Boolean/new Number/new Date/new String\` expressions

-- R.has works with non-object

-- R.ifElse pass all arguments

-- R.length works with bad input

-- R.propEq work with bad input for object argument

-- R.range work with bad inputs

-- R.times work with bad inputs

-- R.reverse works with strings

-- R.splitEvery throws on non-positive integer index

-- R.test throws just like Ramda when first argument is not regex

-- R.values works with bad inputs

-- R.zipObj ignores extra keys

- 3.3.0

This is pre \`4.0.0\` release and it contains all of the above changes

Close [issue #287](https://github.com/selfrefactor/rambda/issues/287) - \`ts-toolbelt\` directory was changed but not reflected in \`files\` property in \`package.json\`

- 3.2.5

Close [issue #273](https://github.com/selfrefactor/rambda/issues/273) - ts-toolbelt needs other type of export when \`isolatedModules\` TypeScript property

Close [issue #245](https://github.com/selfrefactor/rambda/issues/245) - complete typings tests for methods that have more specific Typescript definitions

- 3.2.1 Fast fix for [issue #273](https://github.com/selfrefactor/rambda/issues/273) - messed up typings

- 3.2.0 There are several changes:

Close [issue #263](https://github.com/selfrefactor/rambda/issues/263) - broken curry typing solved by \`ts-toolbelt\` local dependency.

Add \`R.partialCurry\` typings.

Approve [PR #266](https://github.com/selfrefactor/rambda/pull/266) that adds \`R.slice\` method.

- 3.1.0 This might be breaking change for Typescript users, as very different definitions are introduced. With the previous state of the definitions, it was not possible to pass \`dtslint\` typings tests.

- \`R.either\` and \`R.both\` supports multiple arguments as they should.

- Several methods added by  [@squidfunk](https://github.com/squidfunk) - \`R.assocPath\`, \`R.symmetricDifference\`, \`R.intersperse\`, \`R.intersection\` and \`R.difference\`

- 3.0.1 Close [issue #234](https://github.com/selfrefactor/rambda/issues/234) - wrong curry typing

- 3.0.0 Deprecate \`R.contains\`, while \`R.includes\` is now following Ramda API(it uses \`R.equals\` for comparision)

- 2.14.5 \`R.without\` needs currying

- 2.14.4 Close [issue #227](https://github.com/selfrefactor/rambda/issues/227) - add index as third argument of \`R.reduce\` typings

- 2.14.2 Use \`R.curry\` with \`R.reduce\` as manual curry there didn't work as expected.

- 2.14.1 Fix wrong typescript with \`R.head\` - [PR #228](https://github.com/selfrefactor/rambda/pull/228) pushed by [@tonivj5](https://github.com/tonivj5)

- 2.14.0 Add \`R.groupWith\` by @selfrefactor | Add \`R.propOr\`, \`R.mathMod\`, \`R.mean\`, \`R.median\`, \`R.negate\`, \`R.product\` by [@ku8ar](https://github.com/ku8ar)

- 2.13.0 Add \`R.identical\` - [PR #217](https://github.com/selfrefactor/rambda/pull/217) pushed by [@ku8ar](https://github.com/ku8ar)

- 2.12.0 Add \`R.propIs\` - [PR #213](https://github.com/selfrefactor/rambda/pull/213) and add \`R.sum\` - [issue #207](https://github.com/selfrefactor/rambda/issues/207)

- 2.11.2 Close Rambdax [issue #32](https://github.com/selfrefactor/rambdax/issues/32) - wrong \`R.type\` when function is input

- 2.11.1 Approve [PR #182](https://github.com/selfrefactor/rambda/pull/182) - Changed typings to allow object as input to \`R.forEach\` and \`R.map\`

- 2.11.0 Approve [PR #179](https://github.com/selfrefactor/rambda/pull/179) - \`R.adjust\` handles negative index; \`R.all\` doesn't need \`R.filter\`

- 2.10.2 Close [issue #175](https://github.com/selfrefactor/rambda/issues/175) - missing typescript file

- 2.10.0 Approve huge and important [PR #171](https://github.com/selfrefactor/rambda/pull/171) submitted by [@helmuthdu](https://github.com/helmuthdu) - Add comments to each method, improve Typescript support

- 2.9.0 \`R.toPairs\` and \`R.fromPairs\`

- 2.8.0 Approve [PR #165](https://github.com/selfrefactor/rambda/pull/165) \`R.clone\`

- 2.7.1 expose \`src\` | Discussed at [issue #147](https://github.com/selfrefactor/rambda/issues/147)

- 2.7.0 Approve [PR #161](https://github.com/selfrefactor/rambda/pull/161) \`R.isEmpty\`

- 2.6.0 \`R.map\`, \`R.filter\` and \`R.forEach\` pass original object to iterator as third argument | Discussed at [issue #147](https://github.com/selfrefactor/rambda/issues/147)

- 2.5.0 Close [issue #149](https://github.com/selfrefactor/rambda/issues/149) Add \`R.partial\` | \`R.type\` handles \`NaN\`

- 2.4.0 Major bump of \`Rollup\`; Stop building for ES5

- 2.3.1 Close [issue #90](https://github.com/selfrefactor/rambda/issues/90) | Add string type of path in \`R.pathOr\`

- 2.3.0 Close [issue #89](https://github.com/selfrefactor/rambda/issues/89) | Fix missing \`Number\` TS definition in \`R.type\`

- 2.2.0 \`R.defaultTo\` accepts indefinite number of input arguments. So the following is valid expression: \`const x = defaultTo('foo',null, null, 'bar')\`

- 2.1.0 Restore \`R.zip\` using [WatermelonDB](https://github.com/Nozbe/WatermelonDB/) implementation.

- 2.0.0 Major version caused by removing of \`R.zip\` and \`R.addIndex\`. [Issue #85](https://github.com/selfrefactor/rambda/issues/85) rightfully finds that the implementation of \`R.addIndex\` is not correct. This led to removing this method and also of \`R.zip\` as it had depended on it. The second change is that \`R.map\`, \`R.filter\` are passing array index as second argument when looping over arrays. The third change is that \`R.includes\` will return \`false\` if input is neigher \`string\` nor \`array\`. The previous behaviour was to throw an error. The last change is to increase the number of methods that are passing index as second argument to the predicate function.

- 1.2.6 Use \`src\` folder instead of \`modules\`
- 1.2.5 Fix \`omit\` typing
- 1.2.4 Add missing Typescript definitions - [PR#82](https://github.com/selfrefactor/rambda/pull/82)
- 1.2.2 Change curry method used across most of library methods
- 1.2.1 Add \`R.assoc\` | fix passing \`undefined\` to \`R.map\` and \`R.merge\` [issue #77](https://github.com/selfrefactor/rambda/issues/77)
- 1.2.0 Add \`R.min\`, \`R.minBy\`, \`R.max\`, \`R.maxBy\`, \`R.nth\` and \`R.keys\`
- 1.1.5 Close [issue #74](https://github.com/selfrefactor/rambda/issues/74) \`R.zipObj\`
- 1.1.4 Close [issue #71](https://github.com/selfrefactor/rambda/issues/71) CRA fail to build \`rambda\`
- 1.1.3 Approve [PR #70](https://github.com/selfrefactor/rambda/pull/67) implement \`R.groupBy\` | Close [issue #69](https://github.com/selfrefactor/rambda/issues/69)
- 1.1.2 Approve [PR #67](https://github.com/selfrefactor/rambda/pull/67) use \`babel-plugin-annotate-pure-calls\`
- 1.1.1 Approve [PR #66](https://github.com/selfrefactor/rambda/pull/66) \`R.zip\`
- 1.1.0 \`R.compose\` accepts more than one input argument [issue #65](https://github.com/selfrefactor/rambda/issues/65)
- 1.0.13 Approve [PR #64](https://github.com/selfrefactor/rambda/pull/64) \`R.indexOf\`
- 1.0.12 Close [issue #61](https://github.com/selfrefactor/rambda/issues/61) make all functions modules
- 1.0.11 Close [issue #60](https://github.com/selfrefactor/rambda/issues/60) problem with babelrc
- 1.0.10 Close [issue #59](https://github.com/selfrefactor/rambda/issues/59) add R.dissoc
- 1.0.9 Close [issue #58](https://github.com/selfrefactor/rambda/issues/58) - Incorrect \`R.equals\`
- 1.0.8 \`R.map\` and \`R.filter\` pass object properties when mapping over objects
- 1.0.7 Add \`R.uniqWith\`
- 1.0.6 Close [issue #52](https://github.com/selfrefactor/rambda/issues/52) - ES5 compatible code
- 1.0.5 Close [issue #51](https://github.com/selfrefactor/rambda/issues/51)
- 1.0.4 Close [issue #50](https://github.com/selfrefactor/rambda/issues/50) - add \`R.pipe\` typings
- 1.0.3 \`R.ifElse\` accept also boolean as condition argument
- 1.0.2 Remove \`typedDefaultTo\` and \`typedPathOr\` | Add \`R.pickAll\` and \`R.none\`
- 1.0.0 Major change as build is now ES6 not ES5 compatible (Related to [issue #46](https://github.com/selfrefactor/rambda/issues/46))| Making \`Rambda\` fully tree-shakeable| Edit Typescript definition
- 0.9.8 Revert to ES5 compatible build - [issue #46](https://github.com/selfrefactor/rambda/issues/46)
- 0.9.7 Refactor for \`Rollup\` tree-shake | Remove \`R.padEnd\` and \`R.padStart\`
- 0.9.6 Close [issue #44](https://github.com/selfrefactor/rambda/issues/44) - \`R.reverse\` mutates the array
- 0.9.5 Close [issue #45](https://github.com/selfrefactor/rambda/issues/45) - invalid Typescript typings
- 0.9.4 Add \`R.reject\` and \`R.without\` ([PR#41](https://github.com/selfrefactor/rambda/pull/41) [PR#42](https://github.com/selfrefactor/rambda/pull/42)) | Remove 'browser' field in \`package.json\` due to Webpack bug [4674](https://github.com/webpack/webpack/issues/4674)
- 0.9.3 Add \`R.forEach\` and \`R.times\`
- 0.9.2 Add \`Typescript\` definitions
- 0.9.1 Close [issue #36](https://github.com/selfrefactor/rambda/issues/36) - move current behaviour of \`defaultTo\` to a new method \`typedDefaultTo\`; make \`defaultTo\` follow Ramda spec; add \`pathOr\`; add \`typedPathOr\`.
- 0.9.0 Add \`R.pipe\` [PR#35](https://github.com/selfrefactor/rambda/pull/35)
- 0.8.9 Add \`R.isNil\`
- 0.8.8 Migrate to ES modules [PR33](https://github.com/selfrefactor/rambda/pull/33) | Add R.flip to the API | R.map/filter works with objects
- 0.8.7 Change \`Webpack\` with \`Rollup\` - [PR29](https://github.com/selfrefactor/rambda/pull/29)
- 0.8.6 Add \`R.tap\` and \`R.identity\`
- 0.8.5 Add \`R.all\`, \`R.allPass\`, \`R.both\`, \`R.either\` and \`R.complement\`
- 0.8.4 Learning to run \`yarn test\` before \`yarn publish\` the hard way
- 0.8.3 Add \`R.always\`, \`R.T\` and \`R.F\`
- 0.8.2 Add \`concat\`, \`padStart\`, \`padEnd\`, \`lastIndexOf\`, \`toString\`, \`reverse\`, \`endsWith\` and \`startsWith\` methods
- 0.8.1 Add \`R.ifElse\`
- 0.8.0 Add \`R.not\`, \`R.includes\` | Take string as condition for \`R.pick\` and \`R.omit\`
- 0.7.6 Fix incorrect implementation of \`R.values\`
- 0.7.5 Fix incorrect implementation of \`R.omit\`
- 0.7.4 [issue #13](https://github.com/selfrefactor/rambda/issues/13) - Fix \`R.curry\`, which used to return incorrectly \`function\` when called with more arguments
- 0.7.3 Close [issue #9](https://github.com/selfrefactor/rambda/issues/9) - Compile to \`es2015\`; Approve [PR #10](https://github.com/selfrefactor/rambda/pull/10) - add \`R.addIndex\` to the API
- 0.7.2 Add \`Promise\` support for \`R.type\`
- 0.7.1 Close [issue #7](https://github.com/selfrefactor/rambda/issues/7) - add \`R.reduce\` to the API
- 0.7.0 Close [issue #5](https://github.com/selfrefactor/rambda/issues/5) - change name of \`curry\` to \`partialCurry\`; add new method \`curry\`, which works just like Ramda's \`curry\`
- 0.6.2 Add separate documentation site via \`docsify\`

## Additional info

> Running benchmarks

TODO

> Rambda references

- [Interview with Dejan Totef at SurviveJS blog](https://survivejs.com/blog/rambda-interview/)

- [Awesome functional Javascript programming libraries](https://github.com/stoeffel/awesome-fp-js#libraries)

> Links to Rambda

- (https://mailchi.mp/webtoolsweekly/web-tools-280)[Web Tools Weekly]

- (https://github.com/stoeffel/awesome-fp-js)[awesome-fp-js]

- (https://github.com/docsifyjs/awesome-docsify)[awesome-docsify]"
`;
