{
  "add": {
    "typing": "add(a: number, b: number): number",
    "allTypings": "add(a: number, b: number): number;\nadd(a: number): (b: number) => number;",
    "notes": "It doesn't work with strings, as the inputs are parsed to numbers before calculation.",
    "rambdaSource": "export function add(a, b){\n  if (arguments.length === 1) return _b => add(a, _b)\n\n  return Number(a) + Number(b)\n}",
    "rambdaSpecs": "import { add } from './add'\n\ntest('with number', () => {\n  expect(add(2, 3)).toEqual(5)\n  expect(add(7)(10)).toEqual(17)\n})\n\ntest('string is bad input', () => {\n  expect(add('foo', 'bar')).toBeNaN()\n})\n\ntest('ramda specs', () => {\n  expect(add('1', '2')).toEqual(3)\n  expect(add(1, '2')).toEqual(3)\n  expect(add(true, false)).toEqual(1)\n  expect(add(null, null)).toEqual(0)\n  expect(add(undefined, undefined)).toEqual(NaN)\n  expect(add(new Date(1), new Date(2))).toEqual(3)\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const add = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.add(1, 1)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.add(1, 1)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.add(1, 1)\n    },\n  },\n]",
      "methodSummary": "Lodash is fastest. Rambda is 96.71% slower and Ramda is 96.74% slower"
    },
    "explanation": "It adds `a` and `b`.",
    "example": "R.add(2, 3) // =>  5",
    "typescriptDefinitionTest": "import {add} from 'rambda'\n\ndescribe('add', () => {\n  it('number', () => {\n    const resultA = add(4)(1) // $ExpectType number\n    resultA // $ExpectType number\n    const resultB = add(4, 1) // $ExpectType number\n    resultB // $ExpectType number\n  })\n})"
  },
  "adjust": {
    "typing": "adjust<T>(index: number, replaceFn: (a: T) => T, list: ReadonlyArray<T>): T[]",
    "allTypings": "adjust<T>(index: number, replaceFn: (a: T) => T, list: ReadonlyArray<T>): T[];\nadjust<T>(index: number, replaceFn: (a: T) => T): (list: ReadonlyArray<T>) => T[];",
    "rambdaSource": "import { curry } from './curry'\n\nfunction adjustFn(\n  index, replaceFn, list\n){\n  const actualIndex = index < 0 ? list.length + index : index\n  if (index >= list.length || actualIndex < 0) return list\n\n  const clone = list.slice()\n  clone[ actualIndex ] = replaceFn(clone[ actualIndex ])\n\n  return clone\n}\n\nexport const adjust = curry(adjustFn)",
    "rambdaSpecs": "import { add } from './add'\nimport { adjust } from './adjust'\n\nconst expected = [ 0, 11, 2 ]\n\ntest('without curring', () => {\n  expect(adjust(\n    1, add(10), [ 0, 1, 2 ]\n  )).toEqual(expected)\n})\n\ntest('with curring type 1 1 1', () => {\n  expect(adjust(1)(add(10))([ 0, 1, 2 ])).toEqual(expected)\n})\n\ntest('with curring type 1 2', () => {\n  expect(adjust(1)(add(10), [ 0, 1, 2 ])).toEqual(expected)\n})\n\ntest('with curring type 2 1', () => {\n  expect(adjust(1, add(10))([ 0, 1, 2 ])).toEqual(expected)\n})\n\ntest('with negative index', () => {\n  expect(adjust(\n    -2, add(10), [ 0, 1, 2 ]\n  )).toEqual(expected)\n})\n\ntest('when index is out of bounds', () => {\n  const list = [ 0, 1, 2, 3 ]\n  expect(adjust(\n    4, add(1), list\n  )).toEqual(list)\n  expect(adjust(\n    -5, add(1), list\n  )).toEqual(list)\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const list = [ 0, 1, 2 ]\nconst fn = x => x + 1\nconst index = 1\n\nconst adjust = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.adjust(\n        index, fn, list\n      )\n      R.adjust(index, fn)(list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.adjust(\n        index, fn, list\n      )\n      Ramda.adjust(index, fn)(list)\n    },\n  },\n]",
      "methodSummary": "Rambda is faster than Ramda with 4.57%"
    },
    "explanation": "It replaces `index` in array `list` with the result of `replaceFn(list[i])`.",
    "example": "R.adjust(\n  0,\n  a => a + 1,\n  [0, 100]\n) // => [1, 100]",
    "failedRamdaSpecs": "const eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\n\ndescribe('adjust', () => {\n  it('accepts an array-like object', () => {\n    function args(){\n      return arguments\n    }\n    eq(R.adjust(\n      2, R.add(1), args(\n        0, 1, 2, 3\n      )\n    ), [ 0, 1, 3, 3 ])\n  })\n})\n",
    "failedSpecsReasons": "ramda accepts an array-like object"
  },
  "all": {
    "typing": "all<T>(predicate: (x: T) => boolean, list: ReadonlyArray<T>): boolean",
    "allTypings": "all<T>(predicate: (x: T) => boolean, list: ReadonlyArray<T>): boolean;\nall<T>(predicate: (x: T) => boolean): (list: ReadonlyArray<T>) => boolean;",
    "rambdaSource": "export function all(predicate, list){\n  if (arguments.length === 1) return _list => all(predicate, _list)\n\n  for (let i = 0; i < list.length; i++){\n    if (!predicate(list[ i ], i)) return false\n  }\n\n  return true\n}",
    "rambdaSpecs": "import { all } from './all'\n\nconst numArr = [ 0, 1, 2, 3, 4 ]\n\ntest('when true', () => {\n  const fn = x => x > -1\n\n  expect(all(fn)(numArr)).toBeTrue()\n})\n\ntest('when false', () => {\n  const fn = x => x > 2\n\n  expect(all(fn, numArr)).toBeFalse()\n})\n\ntest('pass index as second argument', () => {\n  const indexes = []\n  const fn = (x, i) => {\n    indexes.push(i)\n\n    return x > 5\n  }\n  all(fn, [ 10, 12, 14 ])\n\n  expect(indexes).toEqual([ 0, 1, 2 ])\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const input = [ 1, 2, 3, 4 ]\n\nconst all = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      const fn = x => x > 2\n\n      R.all(fn, input)\n      R.all(fn)(input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      const fn = x => x > 2\n\n      Ramda.all(fn, input)\n      Ramda.all(fn)(input)\n    },\n  },\n]",
      "methodSummary": "Rambda is faster than Ramda with 95.2%"
    },
    "explanation": "It returns `true`, if all members of array `list` returns `true`, when applied as argument to `predicate` function.",
    "example": "const list = [ 0, 1, 2, 3, 4 ]\nconst predicate = x => x > -1\n\nconst result = R.all(fn, arr)\n// => true",
    "typescriptDefinitionTest": "import {all} from 'rambda'\n\ndescribe('all', () => {\n  it('happy', () => {\n    const x = all<number>(y => {\n      y // $ExpectType number\n      return y > 0\n    })([1, 2, 3])\n    x // $ExpectType boolean\n\n    const q = all(y => y > 0, [1, 2, 3]) // $ExpectType boolean\n\n    q // $ExpectType boolean\n  })\n})"
  },
  "allPass": {
    "typing": "allPass<T>(predicates: ((x: T) => boolean)[]): (input: T) => boolean",
    "allTypings": "allPass<T>(predicates: ((x: T) => boolean)[]): (input: T) => boolean;",
    "rambdaSource": "export function allPass(predicates){\n  return input => {\n    let counter = 0\n    while (counter < predicates.length){\n      if (!predicates[ counter ](input)){\n        return false\n      }\n      counter++\n    }\n\n    return true\n  }\n}",
    "rambdaSpecs": "import { allPass } from './allPass'\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'number', x => x > 10, x => x * 7 < 100 ]\n\n  expect(allPass(rules)(11)).toBeTrue()\n\n  expect(allPass(rules)(undefined)).toBeFalse()\n})\n\ntest('when returns true', () => {\n  const conditionArr = [ val => val.a === 1, val => val.b === 2 ]\n\n  expect(allPass(conditionArr)({\n    a : 1,\n    b : 2,\n  })).toBeTrue()\n})\n\ntest('when returns false', () => {\n  const conditionArr = [ val => val.a === 1, val => val.b === 3 ]\n\n  expect(allPass(conditionArr)({\n    a : 1,\n    b : 2,\n  })).toBeFalse()\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const rules = [ x => typeof x === 'number', x => x > 10, x => x * 7 < 100 ]\n\nconst allPass = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.allPass(rules)(11)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.allPass(rules)(11)\n    },\n  },\n]",
      "methodSummary": "Rambda is faster than Ramda with 99.24%"
    },
    "explanation": "It returns `true`, if all functions of `predicates` return `true`, when `input` is their argument.",
    "example": "const input = {\n  a : 1,\n  b : 2,\n}\nconst predicates = [\n  x => x.a === 1,\n  x => x.b === 2,\n]\nconst result = R.allPass(predicates)(input) // => true",
    "typescriptDefinitionTest": "import {allPass} from 'rambda'\n\ndescribe('allPass', () => {\n  it('happy', () => {\n    const x = allPass<number>([\n      y => {\n        y // $ExpectType number\n        return typeof y === 'number'\n      },\n      y => {\n        return y > 0\n      },\n    ])(11)\n\n    x // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "const eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\n\ndescribe('allPass', () => {\n  const odd = function (n){\n    return n % 2 !== 0\n  }\n  const lt20 = function (n){\n    return n < 20\n  }\n  const gt5 = function (n){\n    return n > 5\n  }\n  const plusEq = function (\n    w, x, y, z\n  ){\n    return w + x === y + z\n  }\n  it('returns a curried function whose arity matches that of the highest-arity predicate', () => {\n    eq(R.allPass([ odd, gt5, plusEq ]).length, 4)\n    eq(R.allPass([ odd, gt5, plusEq ])(\n      9, 9, 9, 9\n    ), true)\n    eq(R.allPass([ odd, gt5, plusEq ])(9)(9)(9)(9), true)\n  })\n})\n",
    "failedSpecsReasons": "ramda returns a curried function whose arity matches that of the highest-arity predicate"
  },
  "always": {
    "typing": "always<T>(x: T): () => T",
    "allTypings": "always<T>(x: T): () => T;",
    "rambdaSource": "export function always(x){\n  return () => x\n}",
    "rambdaSpecs": "import { always } from './always'\n\ntest('happy', () => {\n  const fn = always(7)\n\n  expect(fn()).toEqual(7)\n  expect(fn()).toEqual(7)\n})",
    "explanation": "It returns function that always returns `x`.",
    "example": "const fn = R.always(7)\n\nconsole.log(fn())// => 7"
  },
  "and": {
    "typing": "and<T extends { and?: ((...a: readonly any[]) => any)",
    "allTypings": "and<T extends { and?: ((...a: readonly any[]) => any); } | number | boolean | string | null>(fn1: T, val2: any): boolean;\nand<T extends { and?: ((...a: readonly any[]) => any); } | number | boolean | string | null>(fn1: T): (val2: any) => boolean;",
    "rambdaSource": "export function and(a, b){\n  if (arguments.length === 1) return _b => and(a, _b)\n\n  return a && b\n}",
    "rambdaSpecs": "import { and } from './and'\n\ntest('happy', () => {\n  expect(and(true, true)).toBe(true)\n  expect(and(true, false)).toBe(false)\n  expect(and(false, true)).toBe(false)\n  expect(and(false, false)).toBe(false)\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const and = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.and(true, true)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.and(true, true)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.and(true, true)\n    },\n  },\n]",
      "methodSummary": ""
    },
    "explanation": "Returns `true` if both arguments are `true`. Otherwise, it returns `false`.",
    "example": "R.and(true, true); // => true\nR.and(false, true); // => false"
  },
  "any": {
    "typing": "any<T>(predicate: (x: T, i: number) => boolean, list: ReadonlyArray<T>): boolean",
    "allTypings": "any<T>(predicate: (x: T, i: number) => boolean, list: ReadonlyArray<T>): boolean;\nany<T>(predicate: (x: T) => boolean, list: ReadonlyArray<T>): boolean;\nany<T>(predicate: (x: T, i: number) => boolean): (list: ReadonlyArray<T>) => boolean;\nany<T>(predicate: (x: T) => boolean): (list: ReadonlyArray<T>) => boolean;",
    "rambdaSource": "export function any(predicate, list){\n  if (arguments.length === 1) return _list => any(predicate, _list)\n\n  let counter = 0\n  while (counter < list.length){\n    if (predicate(list[ counter ], counter)){\n      return true\n    }\n    counter++\n  }\n\n  return false\n}",
    "rambdaSpecs": "import { any } from './any'\n\nconst arr = [ 1, 2 ]\n\ntest('no curry', () => {\n  expect(any(val => val < 0, arr)).toBeFalse()\n})\n\ntest('with curry', () => {\n  expect(any(val => val < 2)(arr)).toBeTrue()\n})\n\ntest('passes index to predicate', () => {\n  any((x, i) => {\n    expect(typeof x).toBe('string')\n    expect(typeof i).toBe('number')\n  })([ 'foo', 'bar' ])\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const input = [ 1, 2, 3, 4 ]\nconst fn = val => val > 2\n\nconst any = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.any(fn, input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.any(fn, input)\n    },\n  },\n  {\n    label : 'Lodash.some',\n    fn    : () => {\n      _.some(input, fn)\n    },\n  },\n]",
      "methodSummary": "Rambda is fastest. Ramda is 98.77% slower and Lodash is 16.04% slower"
    },
    "explanation": "It returns `true`, if at least one member of `list` returns true, when passed to `predicate` function.",
    "example": "const list = [1, 2, 3]\nconst predicate = x => x * x > 8\nR.any(fn, list)\n// => true",
    "typescriptDefinitionTest": "import {any} from 'rambda'\n\ndescribe('any', () => {\n  it('1', () => {\n    const x = any<number>(\n      (y, i) => {\n        y // $ExpectType number\n        i // $ExpectType number\n        return y > 2\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType boolean\n  })\n  it('2', () => {\n    const x = any<number>(\n      y => {\n        y // $ExpectType number\n        return y > 2\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType boolean\n  })\n\n  it('1 curry', () => {\n    const x = any<number>((y, i) => {\n      y // $ExpectType number\n      i // $ExpectType number\n      return y > 2\n    })([1, 2, 3])\n    x // $ExpectType boolean\n  })\n  it('2 curry', () => {\n    const x = any<number>(y => {\n      y // $ExpectType number\n      return y > 2\n    })([1, 2, 3])\n    x // $ExpectType boolean\n  })\n})"
  },
  "anyPass": {
    "typing": "anyPass<T>(predicates: ReadonlyArray<SafePred<T>>): SafePred<T>",
    "allTypings": "anyPass<T>(predicates: ReadonlyArray<SafePred<T>>): SafePred<T>;",
    "rambdaSource": "export function anyPass(predicates){\n  return input => {\n    let counter = 0\n    while (counter < predicates.length){\n      if (predicates[ counter ](input)){\n        return true\n      }\n      counter++\n    }\n\n    return false\n  }\n}",
    "rambdaSpecs": "import { anyPass } from './anyPass'\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'string', x => x > 10 ]\n  const predicate = anyPass(rules)\n  expect(predicate('foo')).toBeTrue()\n  expect(predicate(6)).toBeFalse()\n})\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'string', x => x > 10 ]\n\n  expect(anyPass(rules)(11)).toBeTrue()\n\n  expect(anyPass(rules)(undefined)).toBeFalse()\n})\n\nconst obj = {\n  a : 1,\n  b : 2,\n}\n\ntest('when returns true', () => {\n  const conditionArr = [ val => val.a === 1, val => val.a === 2 ]\n\n  expect(anyPass(conditionArr)(obj)).toBeTrue()\n})\n\ntest('when returns false + curry', () => {\n  const conditionArr = [ val => val.a === 2, val => val.b === 3 ]\n\n  expect(anyPass(conditionArr)(obj)).toBeFalse()\n})\n\ntest('happy', () => {\n  expect(anyPass([])(3)).toEqual(false)\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const rules = [ x => typeof x === 'boolean', x => x > 20, x => x * 7 < 100 ]\n\nconst anyPass = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.anyPass(rules)(11)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.anyPass(rules)(11)\n    },\n  },\n]",
      "methodSummary": "Rambda is faster than Ramda with 99.06%"
    },
    "explanation": "It accepts list of `predicates` and returns a function. This function with its `input` will return `true`, if any of `predicates` returns `true` for this `input`.",
    "example": "const isBig = x => x > 20\nconst isOdd = x => x % 2 === 1\nconst input = 11\n\nconst fn = const result = R.anyPass(\n  [isBig, isOdd]\n)\n\nconst result = fn(input) // => true",
    "typescriptDefinitionTest": "import {anyPass} from 'rambda'\n\ndescribe('anyPass', () => {\n  it('happy', () => {\n    const x = anyPass<number>([\n      y => {\n        y // $ExpectType number\n        return typeof y === 'number'\n      },\n      y => {\n        return y > 0\n      },\n    ])(11)\n\n    x // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "const eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\n\ndescribe('anyPass', () => {\n  const odd = function (n){\n    return n % 2 !== 0\n  }\n  const gt20 = function (n){\n    return n > 20\n  }\n  const lt5 = function (n){\n    return n < 5\n  }\n  const plusEq = function (\n    w, x, y, z\n  ){\n    return w + x === y + z\n  }\n  it('returns a curried function whose arity matches that of the highest-arity predicate', () => {\n    eq(R.anyPass([ odd, lt5, plusEq ]).length, 4)\n    eq(R.anyPass([ odd, lt5, plusEq ])(\n      6, 7, 8, 9\n    ), false)\n    eq(R.anyPass([ odd, lt5, plusEq ])(6)(7)(8)(9), false)\n  })\n})\n",
    "failedSpecsReasons": "ramda returns a curried function whose arity matches that of the highest-arity predicate"
  },
  "append": {
    "typing": "append<T>(el: T, list: ReadonlyArray<T>): T[]",
    "allTypings": "append<T>(el: T, list: ReadonlyArray<T>): T[];\nappend<T>(el: T): <T>(list: ReadonlyArray<T>) => T[];",
    "rambdaSource": "export function append(el, list){\n  if (arguments.length === 1) return _list => append(el, _list)\n\n  if (typeof list === 'string') return `${ list }${ el }`\n\n  const clone = list.slice()\n  clone.push(el)\n\n  return clone\n}",
    "rambdaSpecs": "import { compose, flatten, map } from '../rambda'\nimport { append } from './append'\n\ntest('with strings', () => {\n  expect(append('o', 'fo')).toEqual('foo')\n})\n\ntest('with arrays', () => {\n  expect(append('tests', [ 'write', 'more' ])).toEqual([\n    'write',\n    'more',\n    'tests',\n  ])\n})\n\ntest('append to empty array', () => {\n  expect(append('tests', [])).toEqual([ 'tests' ])\n})\n\ntest('happy', () => {\n  const result = compose(flatten, map(append(0)))([ [ 1 ], [ 2 ], [ 3 ] ])\n  expect(result).toEqual([ 1, 0, 2, 0, 3, 0 ])\n})\n\ntest('should not modify arguments', () => {\n  const a = [ 1, 2, 3 ]\n  const b = append(4, a)\n\n  expect(a).toEqual([ 1, 2, 3 ])\n  expect(b).toEqual([ 1, 2, 3, 4 ])\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const append = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.append(0)([ 1, 2, 3, 4 ])\n      R.append('bar')('foo')\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.append(0)([ 1, 2, 3, 4 ])\n      Ramda.append('bar')('foo')\n    },\n  },\n]",
      "methodSummary": "Rambda is faster than Ramda with 82.5%"
    },
    "explanation": "It appends element `el` to a `list` array.",
    "example": "R.append(\n  'foo',\n  ['bar', 'baz']\n) // => ['bar', 'baz', 'foo']"
  },
  "applySpec": {
    "typing": "applySpec<Spec extends Record<string, (...args: readonly any[]) => any>>(\n  spec: Spec\n): (\n    ...args: Parameters<ValueOfRecord<Spec>>\n  ) => { [Key in keyof Spec]: ReturnType<Spec[Key]> }",
    "allTypings": "applySpec<Spec extends Record<string, (...args: readonly any[]) => any>>(",
    "notes": "The currying in this function works best with functions with 4 arguments or less. (arity of 4)",
    "rambdaSource": "// recursively traverse the given spec object to find the highest arity function\nfunction __findHighestArity(spec, max = 0){\n  for (const key in spec){\n    if (spec.hasOwnProperty(key) === false || key === 'constructor') continue\n\n    if (typeof spec[ key ] === 'object'){\n      max = Math.max(max, __findHighestArity(spec[ key ]))\n    }\n\n    if (typeof spec[ key ] === 'function'){\n      max = Math.max(max, spec[ key ].length)\n    }\n  }\n\n  return max\n}\n\nfunction __filterUndefined(){\n  const defined = []\n  let i = 0\n  const l = arguments.length\n  while (i < l){\n    if (typeof arguments[ i ] === 'undefined') break\n    defined[ i ] = arguments[ i ]\n    i++\n  }\n\n  return defined\n}\n\nfunction __applySpecWithArity(\n  spec, arity, cache\n){\n  const remaining = arity - cache.length\n\n  if (remaining === 1)\n    return x =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(...cache, x)\n      )\n  if (remaining === 2)\n    return (x, y) =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(\n          ...cache, x, y\n        )\n      )\n  if (remaining === 3)\n    return (\n      x, y, z\n    ) =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(\n          ...cache, x, y, z\n        )\n      )\n  if (remaining === 4)\n    return (\n      x, y, z, a\n    ) =>\n      __applySpecWithArity(\n        spec,\n        arity,\n        __filterUndefined(\n          ...cache, x, y, z, a\n        )\n      )\n  if (remaining > 4)\n    return (...args) =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(...cache, ...args)\n      )\n\n  // handle spec as Array\n  if (Array.isArray(spec)){\n    const ret = []\n    let i = 0\n    const l = spec.length\n    for (; i < l; i++){\n      // handle recursive spec inside array\n      if (typeof spec[ i ] === 'object' || Array.isArray(spec[ i ])){\n        ret[ i ] = __applySpecWithArity(\n          spec[ i ], arity, cache\n        )\n      }\n      // apply spec to the key\n      if (typeof spec[ i ] === 'function'){\n        ret[ i ] = spec[ i ](...cache)\n      }\n    }\n\n    return ret\n  }\n\n  // handle spec as Object\n  const ret = {}\n  // apply callbacks to each property in the spec object\n  for (const key in spec){\n    if (spec.hasOwnProperty(key) === false || key === 'constructor') continue\n\n    // apply the spec recursively\n    if (typeof spec[ key ] === 'object'){\n      ret[ key ] = __applySpecWithArity(\n        spec[ key ], arity, cache\n      )\n      continue\n    }\n\n    // apply spec to the key\n    if (typeof spec[ key ] === 'function'){\n      ret[ key ] = spec[ key ](...cache)\n    }\n  }\n\n  return ret\n}\n\nexport function applySpec(spec, ...args){\n  // get the highest arity spec function, cache the result and pass to __applySpecWithArity\n  const arity = __findHighestArity(spec)\n\n  if (arity === 0){\n    return () => ({})\n  }\n  const toReturn = __applySpecWithArity(\n    spec, arity, args\n  )\n\n  return toReturn\n}",
    "rambdaSpecs": "import { applySpec as applySpecRamda, nAry } from 'ramda'\n\nimport { add, always, compose, dec, inc, map, path, prop, T } from '../rambda'\nimport { applySpec } from './applySpec'\n\ntest('different than Ramda when bad spec', () => {\n  const result = applySpec({ sum : { a : 1 } })(1, 2)\n  const ramdaResult = applySpecRamda({ sum : { a : 1 } })(1, 2)\n  expect(result).toEqual({})\n  expect(ramdaResult).toEqual({ sum : { a : {} } })\n})\n\ntest('works with empty spec', () => {\n  expect(applySpec({})()).toEqual({})\n  expect(applySpec([])(1, 2)).toEqual({})\n  expect(applySpec(null)(1, 2)).toEqual({})\n})\n\ntest('works with unary functions', () => {\n  const result = applySpec({\n    v : inc,\n    u : dec,\n  })(1)\n  const expected = {\n    v : 2,\n    u : 0,\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('works with binary functions', () => {\n  const result = applySpec({ sum : add })(1, 2)\n  expect(result).toEqual({ sum : 3 })\n})\n\ntest('works with nested specs', () => {\n  const result = applySpec({\n    unnested : always(0),\n    nested   : { sum : add },\n  })(1, 2)\n  const expected = {\n    unnested : 0,\n    nested   : { sum : 3 },\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('works with arrays of nested specs', () => {\n  const result = applySpec({\n    unnested : always(0),\n    nested   : [ { sum : add } ],\n  })(1, 2)\n\n  expect(result).toEqual({\n    unnested : 0,\n    nested   : [ { sum : 3 } ],\n  })\n})\n\ntest('works with arrays of spec objects', () => {\n  const result = applySpec([ { sum : add } ])(1, 2)\n\n  expect(result).toEqual([ { sum : 3 } ])\n})\n\ntest('works with arrays of functions', () => {\n  const result = applySpec([ map(prop('a')), map(prop('b')) ])([\n    {\n      a : 'a1',\n      b : 'b1',\n    },\n    {\n      a : 'a2',\n      b : 'b2',\n    },\n  ])\n  const expected = [\n    [ 'a1', 'a2' ],\n    [ 'b1', 'b2' ],\n  ]\n  expect(result).toEqual(expected)\n})\n\ntest('works with a spec defining a map key', () => {\n  expect(applySpec({ map : prop('a') })({ a : 1 })).toEqual({ map : 1 })\n})\n\ntest.skip('retains the highest arity', () => {\n  const f = applySpec({\n    f1 : nAry(2, T),\n    f2 : nAry(5, T),\n  })\n  expect(f.length).toBe(5)\n})\n\ntest('returns a curried function', () => {\n  expect(applySpec({ sum : add })(1)(2)).toEqual({ sum : 3 })\n})\n\n// Additional tests\n// ============================================\ntest('arity', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n  }\n  expect(applySpec(\n    spec, 1, 2, 3\n  )).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n  })\n})\n\ntest('arity over 5 arguments', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n    four : (\n      x1, x2, x3, x4\n    ) => x1 + x2 + x3 + x4,\n    five : (\n      x1, x2, x3, x4, x5\n    ) => x1 + x2 + x3 + x4 + x5,\n  }\n  expect(applySpec(\n    spec, 1, 2, 3, 4, 5\n  )).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n    four  : 10,\n    five  : 15,\n  })\n})\n\ntest('curried', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n  }\n  expect(applySpec(spec)(1)(2)(3)).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n  })\n})\n\ntest('curried over 5 arguments', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n    four : (\n      x1, x2, x3, x4\n    ) => x1 + x2 + x3 + x4,\n    five : (\n      x1, x2, x3, x4, x5\n    ) => x1 + x2 + x3 + x4 + x5,\n  }\n  expect(applySpec(spec)(1)(2)(3)(4)(5)).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n    four  : 10,\n    five  : 15,\n  })\n})\n\ntest('undefined property', () => {\n  const spec = { prop : path([ 'property', 'doesnt', 'exist' ]) }\n  expect(applySpec(spec, {})).toEqual({ prop : undefined })\n})\n\ntest('restructure json object', () => {\n  const spec = {\n    id          : path('user.id'),\n    name        : path('user.firstname'),\n    profile     : path('user.profile'),\n    doesntExist : path('user.profile.doesntExist'),\n    info        : { views : compose(inc, prop('views')) },\n    type        : always('playa'),\n  }\n\n  const data = {\n    user : {\n      id        : 1337,\n      firstname : 'john',\n      lastname  : 'shaft',\n      profile   : 'shaft69',\n    },\n    views : 42,\n  }\n\n  expect(applySpec(spec, data)).toEqual({\n    id          : 1337,\n    name        : 'john',\n    profile     : 'shaft69',\n    doesntExist : undefined,\n    info        : { views : 43 },\n    type        : 'playa',\n  })\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const curryN = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      const data = {\n        a : {\n          b : { c : 1 },\n          d : 2,\n        },\n      }\n      const spec = {\n        c : R.path([ 'a', 'b', 'c' ]),\n        d : R.path([ 'a', 'd' ]),\n      }\n      R.applySpec(spec, data)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      const data = {\n        a : {\n          b : { c : 1 },\n          d : 2,\n        },\n      }\n      const spec = {\n        c : Ramda.path([ 'a', 'b', 'c' ]),\n        d : Ramda.path([ 'a', 'd' ]),\n      }\n      Ramda.applySpec(spec, data)\n    },\n  },\n]",
      "methodSummary": "Rambda is faster than Ramda with 67.65%"
    },
    "explanation": "Returns a curried function with the same arity as the longest function in the spec object.\nArguments will be applied to the spec methods recursively.",
    "example": "const spec = {\n  name: R.path('deeply.nested.firstname')\n}\nconst json = {\n  deeply: {\n   nested: {\n      firstname: 'barry'\n    }\n  }\n}\nconst result = R.applySpec(spec, json) // => { name: 'barry' }\n\n// Second example\nconst getMetrics = R.applySpec({\n  sum: R.add,\n  nested: { mul: R.multiply }\n});\ngetMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }",
    "typescriptDefinitionTest": "import {multiply, applySpec, inc, dec, add} from 'rambda'\n\ndescribe('applySpec', () => {\n  it('ramda 1', () => {\n    const result = applySpec({\n      v: inc,\n      u: dec,\n    })(1)\n    result // $ExpectType { v: number; u: number; }\n  })\n  it('ramda 1', () => {\n    interface Output {\n      sum: number,\n      multiplied: number,\n    }\n    const result = applySpec<Output>({\n      sum: add,\n      multiplied: multiply,\n    })(1, 2)\n\n    result // $ExpectType Output\n  })\n})"
  },
  "assoc": {
    "typing": "assoc<T, U, K extends string>(prop: K, newValue: T, obj: U): Record<K, T> & U",
    "allTypings": "assoc<T, U, K extends string>(prop: K, newValue: T, obj: U): Record<K, T> & U;\nassoc<T, K extends string>(prop: K, newValue: T): <U>(obj: U) => Record<K, T> & U;\nassoc<K extends string>(prop: K): <T, U>(newValue: T, obj: U) => Record<K, T> & U;",
    "notes": "This copies and flattens prototype properties\nonto the new object as well. All non-primitive properties are copied by\nreference.",
    "rambdaSource": "import { curry } from './curry'\n\nfunction assocFn(\n  prop, newValue, obj\n){\n  return Object.assign(\n    {}, obj, { [ prop ] : newValue }\n  )\n}\n\nexport const assoc = curry(assocFn)",
    "rambdaSpecs": "import { assoc } from './assoc'\n\ntest('adds a key to an empty object', () => {\n  expect(assoc(\n    'a', 1, {}\n  )).toEqual({ a : 1 })\n})\n\ntest('adds a key to a non-empty object', () => {\n  expect(assoc(\n    'b', 2, { a : 1 }\n  )).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 1', () => {\n  expect(assoc('b', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 2', () => {\n  expect(assoc('b')(2, { a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 3', () => {\n  const result = assoc('b')(2)({ a : 1 })\n\n  expect(result).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('changes an existing key', () => {\n  expect(assoc(\n    'a', 2, { a : 1 }\n  )).toEqual({ a : 2 })\n})\n\ntest('undefined is considered an empty object', () => {\n  expect(assoc(\n    'a', 1, undefined\n  )).toEqual({ a : 1 })\n})\n\ntest('null is considered an empty object', () => {\n  expect(assoc(\n    'a', 1, null\n  )).toEqual({ a : 1 })\n})\n\ntest('value can be null', () => {\n  expect(assoc(\n    'a', null, null\n  )).toEqual({ a : null })\n})\n\ntest('value can be undefined', () => {\n  expect(assoc(\n    'a', undefined, null\n  )).toEqual({ a : undefined })\n})\n\ntest('assignment is shallow', () => {\n  expect(assoc(\n    'a', { b : 2 }, { a : { c : 3 } }\n  )).toEqual({ a : { b : 2 } })\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const input = {\n  a : 1,\n  b : 2,\n}\nconst key = 'c'\nconst value = 3\n\nconst assoc = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.assoc(\n        key, value, input\n      )\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.assoc(\n        key, value, input\n      )\n    },\n  },\n  {\n    label : 'Lodash.set',\n    fn    : () => {\n      _.set(\n        input, key, value\n      )\n    },\n  },\n]",
      "methodSummary": "Lodash is fastest. Rambda is 91.68% slower and Ramda is 67.07% slower"
    },
    "explanation": "It makes a shallow clone of `obj` with setting or overriding the property `prop` with `newValue`.",
    "example": "R.assoc('c', 3, {a: 1, b: 2})\n//=> {a: 1, b: 2, c: 3}"
  },
  "assocPath": {
    "typing": "assocPath<T, U>(path: Path, newValue: T, obj: U): U",
    "allTypings": "assocPath<T, U>(path: Path, newValue: T, obj: U): U;\nassocPath<T, U>(path: Path, newValue: T): (obj: U) => U;\nassocPath<T, U>(path: Path): FToolbelt.Curry<(a: T, b: U) => U>;",
    "notes": "Object",
    "rambdaSource": "import { _isInteger } from './_internals/_isInteger'\nimport { assoc } from './assoc'\nimport { curry } from './curry'\n\nfunction assocPathFn(\n  list, newValue, input\n){\n  const pathArrValue = typeof list === 'string' ? list.split('.') : list\n  if (pathArrValue.length === 0){\n    return newValue\n  }\n\n  const index = pathArrValue[ 0 ]\n  if (pathArrValue.length > 1){\n    const condition =\n      typeof input !== 'object' ||\n      input === null ||\n      !input.hasOwnProperty(index)\n\n    const nextinput = condition ?\n      _isInteger(parseInt(pathArrValue[ 1 ], 10)) ?\n        [] :\n        {} :\n      input[ index ]\n    newValue = assocPathFn(\n      Array.prototype.slice.call(pathArrValue, 1),\n      newValue,\n      nextinput\n    )\n  }\n\n  if (_isInteger(parseInt(index, 10)) && Array.isArray(input)){\n    const arr = input.slice()\n    arr[ index ] = newValue\n\n    return arr\n  }\n\n  return assoc(\n    index, newValue, input\n  )\n}\n\nexport const assocPath = curry(assocPathFn)",
    "rambdaSpecs": "import { assocPath } from './assocPath'\n\ntest('adds a key to an empty object', () => {\n  expect(assocPath(\n    'a', 1, {}\n  )).toEqual({ a : 1 })\n})\n\ntest('adds a key to a non-empty object', () => {\n  expect(assocPath(\n    'b', 2, { a : 1 }\n  )).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a nested key to a non-empty object', () => {\n  expect(assocPath(\n    'b.c', 2, { a : 1 }\n  )).toEqual({\n    a : 1,\n    b : { c : 2 },\n  })\n})\n\ntest('adds a nested key to a nested non-empty object - curry case 1', () => {\n  expect(assocPath('b.d',\n    3)({\n    a : 1,\n    b : { c : 2 },\n  })).toEqual({\n    a : 1,\n    b : {\n      c : 2,\n      d : 3,\n    },\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 1', () => {\n  expect(assocPath('b', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a nested key to a non-empty object - curry case 1', () => {\n  expect(assocPath('b.c', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : { c : 2 },\n  })\n})\n\ntest('adds a nested array to a non-empty object - curry case 1', () => {\n  expect(assocPath('b.0', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : [ 2 ],\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 2', () => {\n  expect(assocPath('b')(2, { a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 3', () => {\n  const result = assocPath('b')(2)({ a : 1 })\n\n  expect(result).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('changes an existing key', () => {\n  expect(assocPath(\n    'a', 2, { a : 1 }\n  )).toEqual({ a : 2 })\n})\n\ntest('undefined is considered an empty object', () => {\n  expect(assocPath(\n    'a', 1, undefined\n  )).toEqual({ a : 1 })\n})\n\ntest('null is considered an empty object', () => {\n  expect(assocPath(\n    'a', 1, null\n  )).toEqual({ a : 1 })\n})\n\ntest('value can be null', () => {\n  expect(assocPath(\n    'a', null, null\n  )).toEqual({ a : null })\n})\n\ntest('value can be undefined', () => {\n  expect(assocPath(\n    'a', undefined, null\n  )).toEqual({ a : undefined })\n})\n\ntest('assignment is shallow', () => {\n  expect(assocPath(\n    'a', { b : 2 }, { a : { c : 3 } }\n  )).toEqual({ a : { b : 2 } })\n})\n\ntest('happy', () => {\n  const result = assocPath(\n    [], 3, {\n      a : 1,\n      b : 2,\n    }\n  )\n  expect(result).toEqual(3)\n})\n\ntest('happy', () => {\n  const expected = { foo : { bar : { baz : 42 } } }\n  const result = assocPath(\n    [ 'foo', 'bar', 'baz' ], 42, { foo : null }\n  )\n  expect(result).toEqual(expected)\n})",
    "explanation": "It makes a shallow clone of `obj` with setting or overriding with `newValue` the property found with `path`.",
    "example": "const path = 'b.c'\nconst newValue = 2\nconst obj = { a: 1 }\n\nR.assocPath(path, newValue, obj)\n// => { a : 1, b : { c : 2 }}"
  },
  "both": {
    "typing": "both(pred1: Pred, pred2: Pred): Pred",
    "allTypings": "both(pred1: Pred, pred2: Pred): Pred;\nboth<T>(pred1: Predicate<T>, pred2: Predicate<T>): Predicate<T>;\nboth<T>(pred1: Predicate<T>): (pred2: Predicate<T>) => Predicate<T>;\nboth(pred1: Pred): (pred2: Pred) => Pred;",
    "rambdaSource": "export function both(f, g){\n  if (arguments.length === 1) return _g => both(f, _g)\n\n  return (...input) => f(...input) && g(...input)\n}",
    "rambdaSpecs": "import { both } from './both'\n\nconst firstFn = val => val > 0\nconst secondFn = val => val < 10\n\ntest('with curry', () => {\n  expect(both(firstFn)(secondFn)(17)).toBeFalse()\n})\n\ntest('without curry', () => {\n  expect(both(firstFn, secondFn)(7)).toBeTrue()\n})\n\ntest('with multiple inputs', () => {\n  const between = function (\n    a, b, c\n  ){\n    return a < b && b < c\n  }\n  const total20 = function (\n    a, b, c\n  ){\n    return a + b + c === 20\n  }\n  const fn = both(between, total20)\n  expect(fn(\n    5, 7, 8\n  )).toBeTrue()\n})\n\ntest('skip evaluation of the second expression', () => {\n  let effect = 'not evaluated'\n  const F = function (){\n    return false\n  }\n  const Z = function (){\n    effect = 'Z got evaluated'\n  }\n  both(F, Z)()\n\n  expect(effect).toBe('not evaluated')\n})",
    "explanation": "It returns a function with `input` argument. \n\nThis funciton will return `true`, if both `firstCondition` and `secondCondition` return `true` when `input` is passed as their argument.",
    "example": "const firstCondition = x => x > 10\nconst secondCondition = x => x < 20\nconst fn = R.both(secondCondition)\n\nconst result = [fn(15), fn(30)]\n// => [true, false]",
    "typescriptDefinitionTest": "import {both} from 'rambda'\n\ndescribe('both', () => {\n  it('with passed type', () => {\n    const fn = both<number>( // $ExpectType Predicate<number>\n      x => {\n        return x > 1\n      },\n      x => {\n        return x % 2 === 0\n      }\n    )\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  })\n  it('no type passed', () => {\n    const fn = both(\n      x => {\n        x // $ExpectType any\n        return x > 1\n      },\n      x => {\n        return x % 2 === 0\n      }\n    )\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  })\n})\n\ndescribe('both + curry', () => {\n  it('with passed type', () => {\n    const fn = both<number>(x => {\n      return x > 1\n    })(x => {\n      return x % 2 === 0\n    })\n    fn // $ExpectType Predicate<number>\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  })\n  it('no type passed', () => {\n    const fn = both(x => {\n      x // $ExpectType unknown\n      return (x as number) > 1\n    })(x => {\n      return (x as number) % 2 === 0\n    })\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "const S = require('sanctuary')\n\nconst eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\ndescribe('both', () => {\n  it('accepts fantasy-land applicative functors', () => {\n    const { Just } = S\n    const { Nothing } = S\n    eq(R.both(Just(true), Just(true)), Just(true))\n    eq(R.both(Just(true), Just(false)), Just(false))\n    eq(R.both(Just(true), Nothing()), Nothing())\n    eq(R.both(Nothing(), Just(false)), Nothing())\n    eq(R.both(Nothing(), Nothing()), Nothing())\n  })\n})\n",
    "failedSpecsReasons": "ramda supports fantasy-land"
  },
  "clamp": {
    "typing": "clamp(min: number, max: number, input: number): number",
    "allTypings": "clamp(min: number, max: number, input: number): number;\nclamp(min: number, max: number): (input: number) => number;",
    "rambdaSource": "import { curry } from './curry'\n\nfunction clampFn(\n  min, max, input\n){\n  if (input >= min && input <= max) return input\n\n  if (input > max) return max\n  if (input < min) return min\n}\n\nexport const clamp = curry(clampFn)",
    "rambdaSpecs": "import { clamp } from './clamp'\n\ntest('rambda specs', () => {\n  expect(clamp(\n    1, 10, 0\n  )).toEqual(1)\n  expect(clamp(\n    3, 12, 1\n  )).toEqual(3)\n  expect(clamp(\n    -15, 3, -100\n  )).toEqual(-15)\n  expect(clamp(\n    1, 10, 20\n  )).toEqual(10)\n  expect(clamp(\n    3, 12, 23\n  )).toEqual(12)\n  expect(clamp(\n    -15, 3, 16\n  )).toEqual(3)\n  expect(clamp(\n    1, 10, 4\n  )).toEqual(4)\n  expect(clamp(\n    3, 12, 6\n  )).toEqual(6)\n  expect(clamp(\n    -15, 3, 0\n  )).toEqual(0)\n})",
    "explanation": "Restrict a number `input` to be withing `min` and `max` limits.\n\nIf `input` is bigger than `max`, then the result is `max`.\n\nIf `input` is smaller than `min`, then the result is `min`.",
    "example": "R.clamp(0, 10, 5) //=> 5\nR.clamp(0, 10, -1) //=> 0\nR.clamp(0, 10, 11) //=> 10"
  },
  "clone": {
    "typing": "clone<T>(input: T): T",
    "allTypings": "clone<T>(input: T): T;\nclone<T>(input: ReadonlyArray<T>): T[];"
  },
  "complement": {
    "typing": "complement(pred: (...args: any[]) => boolean): (...args: any[]) => boolean",
    "allTypings": "complement(pred: (...args: any[]) => boolean): (...args: any[]) => boolean;",
    "rambdaSource": "export function complement(fn){\n  return (...input) => !fn(...input)\n}",
    "rambdaSpecs": "import { complement } from './complement'\n\ntest('happy', () => {\n  const fn = complement(x => x.length === 0)\n\n  expect(fn([ 1, 2, 3 ])).toBeTrue()\n})\n\ntest('with multiple parameters', () => {\n  const between = function (\n    a, b, c\n  ){\n    return a < b && b < c\n  }\n  const f = complement(between)\n  expect(f(\n    4, 5, 11\n  )).toEqual(false)\n  expect(f(\n    12, 2, 6\n  )).toEqual(true)\n})",
    "explanation": "It returns `inverted` version of `origin` function that accept `input` as argument.\n\nThe return value of `inverted` is the negative boolean value of `origin(input)`.",
    "example": "const origin = x => x > 5\nconst inverted = complement(origin)\n\nconst result = [\n  origin(7),\n  inverted(7)\n] => [ true, false ]",
    "failedRamdaSpecs": "const S = require('sanctuary')\n\nconst eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\ndescribe('complement', () => {\n  it('accepts fantasy-land functors', () => {\n    const { Just } = S\n    const { Nothing } = S\n    eq(R.complement(Just(true)), Just(false))\n    eq(R.complement(Just(false)), Just(true))\n    eq(R.complement(Nothing()), Nothing())\n  })\n})\n",
    "failedSpecsReasons": "ramda supports fantasy-land"
  },
  "compose": {
    "typing": "compose<T1>(fn0: () => T1): () => T1",
    "allTypings": "compose<T1>(fn0: () => T1): () => T1;\ncompose<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;\ncompose<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;\ncompose<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;",
    "rambdaSource": "export function compose(...fns){\n  if (fns.length === 0){\n    throw new Error('compose requires at least one argument')\n  }\n\n  return (...args) => {\n    const list = fns.slice()\n    if (list.length > 0){\n      const fn = list.pop()\n      let result = fn(...args)\n      while (list.length > 0){\n        result = list.pop()(result)\n      }\n\n      return result\n    }\n  }\n}",
    "rambdaSpecs": "import { add, filter, last, map } from '../rambda'\nimport { compose } from './compose'\n\ntest('happy', () => {\n  const result = compose(\n    last, map(add(10)), map(add(1))\n  )([ 1, 2, 3 ])\n\n  expect(result).toEqual(14)\n})\n\ntest('accepts initially two arguments', () => {\n  const result = compose(map(x => x * 2),\n    (a, y) => filter(x => x > y, a))([ 1, 2, 3, 4 ], 2)\n\n  expect(result).toEqual([ 6, 8 ])\n})\n\ntest('when no arguments is passed', () => {\n  expect(() => compose()).toThrow('compose requires at least one argument')\n})\n\ntest('ramda spec', () => {\n  const f = function (\n    a, b, c\n  ){\n    return [ a, b, c ]\n  }\n  const g = compose(f)\n  expect(g(\n    1, 2, 3\n  )).toEqual([ 1, 2, 3 ])\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const input = [ 1, 2, 3, 4 ]\nconst fns = [ val => val + 1, val => val.length ]\n\nconst compose = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.compose(...fns)(input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.compose(...fns)(input)\n    },\n  },\n  {\n    label : 'Lodash.flowRight',\n    fn    : () => {\n      _.flowRight(...fns)(input)\n    },\n  },\n]",
      "methodSummary": "Rambda is fastest. Ramda is 95.55% slower and Lodash is 76.43% slower"
    },
    "explanation": "It performs right-to-left function composition.",
    "example": "const result = R.compose(\n  R.map(x => x * 2),\n  R.filter(x => x > 2)\n)([1, 2, 3, 4])\n\n// => [6, 8]",
    "failedRamdaSpecs": "var assert = require('assert');\nvar jsv = require('jsverify');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('compose', function() {\n  it('performs right-to-left function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.compose(R.map, R.multiply, parseInt);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.compose(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.compose(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });\n});\ndescribe('compose properties', function() {\n  jsv.property('composes two functions', jsv.fn(), jsv.fn(), jsv.nat, function(f, g, x) {\n    return R.equals(R.compose(f, g)(x), f(g(x)));\n  jsv.property('associative',  jsv.fn(), jsv.fn(), jsv.fn(), jsv.nat, function(f, g, h, x) {\n    var result = f(g(h(x)));\n    return R.all(R.equals(result), [\n      R.compose(f, g, h)(x),\n      R.compose(f, R.compose(g, h))(x),\n      R.compose(R.compose(f, g), h)(x)\n    ]);\n});",
    "failedSpecsReasons": "ramda passes context to functions | rambda composed functions have no length"
  },
  "concat": {
    "typing": "concat<T>(x: ReadonlyArray<T>, y: ReadonlyArray<T>): T[]",
    "allTypings": "concat<T>(x: ReadonlyArray<T>, y: ReadonlyArray<T>): T[];\nconcat<T>(x: ReadonlyArray<T>): (y: ReadonlyArray<T>) => T[];\nconcat(x: string, y: string): string;\nconcat(x: string): (y: string) => string;",
    "rambdaSource": "export function concat(x, y){\n  if (arguments.length === 1) return _y => concat(x, _y)\n\n  return typeof x === 'string' ? `${ x }${ y }` : [ ...x, ...y ]\n}",
    "rambdaSpecs": "import { concat } from './concat'\n\ntest('happy', () => {\n  const arr1 = [ 'a', 'b', 'c' ]\n  const arr2 = [ 'd', 'e', 'f' ]\n\n  const a = concat(arr1, arr2)\n  const b = concat(arr1)(arr2)\n  const expectedResult = [ 'a', 'b', 'c', 'd', 'e', 'f' ]\n\n  expect(a).toEqual(expectedResult)\n  expect(b).toEqual(expectedResult)\n})\n\ntest('with strings', () => {\n  expect(concat('ABC', 'DEF')).toEqual('ABCDEF')\n})",
    "explanation": "It returns a new string or array, which is the result of merging `x` and `y`.",
    "example": "R.concat([1, 2])([3, 4]) // => [1, 2, 3, 4]\nR.concat('foo', 'bar') // => 'foobar'",
    "failedRamdaSpecs": "const assert = require('assert')\n\nconst eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\ndescribe('concat', () => {\n  const z1 = {\n    x      : 'z1',\n    concat : function (that){\n      return this.x + ' ' + that.x\n    },\n  }\n  const z2 = { x : 'z2' }\n  it('delegates to non-String object with a concat method, as second param', () => {\n    eq(R.concat(z1, z2), 'z1 z2')\n  })\n})\n",
    "failedSpecsReasons": "ramda pass to concat method if present"
  },
  "cond": {
    "typing": "cond(conditions: [Pred, (...a: readonly any[]) => any][]): (...a: readonly any[]) => any",
    "allTypings": "cond(conditions: [Pred, (...a: readonly any[]) => any][]): (...a: readonly any[]) => any;\ncond<A, B>(conditions: [SafePred<A>, (...a: readonly A[]) => B][]): (...a: readonly A[]) => B;",
    "rambdaSource": "export function cond(conditions){\n  return input => {\n    let done = false\n    let toReturn\n    conditions.forEach(([ predicate, resultClosure ]) => {\n      if (!done && predicate(input)){\n        done = true\n        toReturn = resultClosure(input)\n      }\n    })\n\n    return toReturn\n  }\n}",
    "rambdaSpecs": "import { always, equals, T } from '../rambda.js'\nimport { cond } from './cond'\n\ntest('returns a function', () => {\n  expect(typeof cond([])).toEqual('function')\n})\n\ntest('returns a conditional function', () => {\n  const fn = cond([\n    [ equals(0), always('water freezes at 0°C') ],\n    [ equals(100), always('water boils at 100°C') ],\n    [\n      T,\n      function (temp){\n        return 'nothing special happens at ' + temp + '°C'\n      },\n    ],\n  ])\n  expect(fn(0)).toEqual('water freezes at 0°C')\n  expect(fn(50)).toEqual('nothing special happens at 50°C')\n  expect(fn(100)).toEqual('water boils at 100°C')\n})\n\ntest('no winner', () => {\n  const fn = cond([\n    [ equals('foo'), always(1) ],\n    [ equals('bar'), always(2) ],\n  ])\n  expect(fn('quux')).toEqual(undefined)\n})\n\ntest('predicates are tested in order', () => {\n  const fn = cond([\n    [ T, always('foo') ],\n    [ T, always('bar') ],\n    [ T, always('baz') ],\n  ])\n  expect(fn()).toEqual('foo')\n})",
    "explanation": "It takes list with `conditions` and returns a new function `fn` that expects `input` as argument. \n\nThis function will start evaluating the `conditions` in order to find the first winner(order of conditions matter). \n\nThe winner is this condition, which left side returns `true` when `input` is its argument. Then the evaluation of the right side of the winner will be the final result.\n\nIf no winner is found, then `fn` returns `undefined`.",
    "example": "const fn = R.cond([\n  [ x => x > 25, R.always('more than 25') ],\n  [ x => x > 15, R.always('more than 15') ],\n  [ R.T, x => `${x} is nothing special` ],\n])\n\nconst result = [\n  fn(30),\n  fn(20),\n  fn(10),\n] \n// => ['more than 25', 'more than 15', '10 is nothing special']",
    "typescriptDefinitionTest": "import {cond, always, equals} from 'rambda'\n\ndescribe('cond', () => {\n  it('happy', () => {\n    const fn = cond<number, string>([\n      [equals(0), always('water freezes at 0°C')],\n      [equals(100), always('water boils at 100°C')],\n      [\n        () => true,\n        function(temp) {\n          return 'nothing special happens at ' + temp + '°C'\n        },\n      ],\n    ])\n\n    const a = fn(0)\n    a // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "const eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\n\ndescribe('cond', () => {\n  it('forwards all arguments to predicates and to transformers', () => {\n    const fn = R.cond([\n      [\n        function (_, x){\n          return x === 42\n        },\n        function (){\n          return arguments.length\n        },\n      ],\n    ])\n    eq(fn(\n      21, 42, 84\n    ), 3)\n  })\n  it('retains highest predicate arity', () => {\n    const fn = R.cond([\n      [ R.nAry(2, R.T), R.T ],\n      [ R.nAry(3, R.T), R.T ],\n      [ R.nAry(1, R.T), R.T ],\n    ])\n    eq(fn.length, 3)\n  })\n})\n",
    "failedSpecsReasons": "pass to transformer is not applied in rambda"
  },
  "curry": {
    "typing": "curry<F extends (...args: any) => any>(f: F): FToolbelt.Curry<F>",
    "allTypings": "curry<F extends (...args: any) => any>(f: F): FToolbelt.Curry<F>;",
    "rambdaSource": "export function curry(fn, args = []){\n  return (..._args) =>\n    (rest => rest.length >= fn.length ? fn(...rest) : curry(fn, rest))([\n      ...args,\n      ..._args,\n    ])\n}",
    "rambdaSpecs": "import { curry } from './curry'\n\ntest('happy', () => {\n  const addFourNumbers = (\n    a, b, c, d\n  ) => a + b + c + d\n  const curriedAddFourNumbers = curry(addFourNumbers)\n  const f = curriedAddFourNumbers(1, 2)\n  const g = f(3)\n\n  expect(g(4)).toEqual(10)\n})\n\ntest('when called with more arguments', () => {\n  const add = curry((n, n2) => n + n2)\n\n  expect(add(\n    1, 2, 3\n  )).toEqual(3)\n})\n\ntest('when called with zero arguments', () => {\n  const sub = curry((a, b) => a - b)\n  const s0 = sub()\n\n  expect(s0(5, 2)).toEqual(3)\n})\n\ntest('when called via multiple curry stages', () => {\n  const join = curry((\n    a, b, c, d\n  ) => [ a, b, c, d ].join('-'))\n\n  const stage1 = join('A')\n  const stage2 = stage1('B', 'C')\n\n  expect(stage2('D')).toEqual('A-B-C-D')\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const addFourNumbers = (\n  a, b, c, d\n) => a + b + c + d\n\nconst curry = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      const curriedAddFourNumbers = R.curry(addFourNumbers)\n      const f = curriedAddFourNumbers(1, 2)\n      const g = f(3)\n\n      g(4)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      const curriedAddFourNumbers = Ramda.curry(addFourNumbers)\n      const f = curriedAddFourNumbers(1, 2)\n      const g = f(3)\n\n      g(4)\n    },\n  },\n]",
      "methodSummary": "Rambda is faster than Ramda with 54.29%"
    },
    "explanation": "It expects a function as input and returns its curried version.",
    "example": "const fn = (a, b, c) => a + b + c\nconst curried = R.curry(fn)\nconst sum = curried(1,2)\n\nconst result = sum(3) // => 6",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar jsv = require('jsverify');\nvar funcN = require('./shared/funcN');\n\ndescribe('curry', function() {\n  it('properly reports the length of the curried function', function() {\n    var f = R.curry(function(a, b, c, d) {return (a + b * c) / d;});\n    eq(f.length, 4);\n    var g = f(12);\n    eq(g.length, 3);\n    var h = g(3);\n    eq(h.length, 2);\n    eq(g(3, 6).length, 1);\n  });\n  it('preserves context', function() {\n    var ctx = {x: 10};\n    var f = function(a, b) { return a + b * this.x; };\n    var g = R.curry(f);\n    eq(g.call(ctx, 2, 4), 42);\n    eq(g.call(ctx, 2).call(ctx, 4), 42);\n  });\n  it('supports R.__ placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = R.__;\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n  it('supports @@functional/placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n});\ndescribe('curry properties', function() {\n  jsv.property('curries multiple values', funcN(4), jsv.json, jsv.json, jsv.json, jsv.json, function(f, a, b, c, d) {\n    var g = R.curry(f);\n    return R.all(R.equals(f(a, b, c, d)), [\n      g(a, b, c, d),\n      g(a)(b)(c)(d),\n      g(a)(b, c, d),\n      g(a, b)(c, d),\n      g(a, b, c)(d)\n    ]);\n  jsv.property('curries with placeholder', funcN(3), jsv.json, jsv.json, jsv.json, function(f, a, b, c) {\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    var g = R.curry(f);\n    return R.all(R.equals(f(a, b, c)), [\n      g(_, _, c)(a, b),\n      g(a, _, c)(b),\n      g(_, b, c)(a),\n      g(a, _, _)(_, c)(b),\n      g(a, b, _)(c)\n    ]);\n});",
    "failedSpecsReasons": "ramda passes context to functions"
  },
  "dec": {
    "typing": "dec(x: number): number",
    "allTypings": "dec(x: number): number;",
    "rambdaSource": "export const dec = x => x - 1",
    "rambdaSpecs": "import { dec } from './dec'\n\ntest('happy', () => {\n  expect(dec(2)).toBe(1)\n})",
    "explanation": "It decrements a number."
  },
  "defaultTo": {
    "typing": "defaultTo<T>(defaultValue: T): (...inputArguments: (T | null | undefined)[]) => T",
    "allTypings": "defaultTo<T>(defaultValue: T): (...inputArguments: (T | null | undefined)[]) => T;\ndefaultTo<T>(defaultValue: T, ...inputArguments: (T | null | undefined)[]): T;\ndefaultTo<T, U>(defaultValue: T | U, ...inputArguments: (T | U | null | undefined)[]): T | U;",
    "notes": "`Ramda` library works with a single input argument, while `Rambda` allows multiple arguments.",
    "rambdaSource": "function flagIs(inputArguments){\n  return (\n    inputArguments === undefined ||\n    inputArguments === null ||\n    Number.isNaN(inputArguments) === true\n  )\n}\n\nexport function defaultTo(defaultArgument, ...inputArguments){\n  if (arguments.length === 1){\n    return _inputArguments => defaultTo(defaultArgument, _inputArguments)\n  } else if (arguments.length === 2){\n    return flagIs(inputArguments[ 0 ]) ? defaultArgument : inputArguments[ 0 ]\n  }\n\n  const limit = inputArguments.length - 1\n  let len = limit + 1\n  let ready = false\n  let holder\n\n  while (!ready){\n    const instance = inputArguments[ limit - len + 1 ]\n\n    if (len === 0){\n      ready = true\n    } else if (flagIs(instance)){\n      len -= 1\n    } else {\n      holder = instance\n      ready = true\n    }\n  }\n\n  return holder === undefined ? defaultArgument : holder\n}",
    "rambdaSpecs": "import { defaultTo } from './defaultTo'\n\ntest('with undefined', () => {\n  expect(defaultTo('foo')(undefined)).toEqual('foo')\n})\n\ntest('with null', () => {\n  expect(defaultTo('foo')(null)).toEqual('foo')\n})\n\ntest('with NaN', () => {\n  expect(defaultTo('foo')(NaN)).toEqual('foo')\n})\n\ntest('with empty string', () => {\n  expect(defaultTo('foo', '')).toEqual('')\n})\n\ntest('with false', () => {\n  expect(defaultTo('foo', false)).toEqual(false)\n})\n\ntest('when inputArgument passes initial check', () => {\n  expect(defaultTo('foo', 'bar')).toEqual('bar')\n})\n\ntest('default extends to indefinite input arguments - case 1', () => {\n  const result = defaultTo(\n    'foo', null, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 2', () => {\n  const result = defaultTo(\n    'foo', null, NaN, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 3', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined\n  )\n  const expected = 'foo'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 4', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 5', () => {\n  const result = defaultTo(\n    'foo', null, NaN, 'bar', 'baz'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 6', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined, null, NaN\n  )\n  const expected = 'foo'\n\n  expect(result).toEqual(expected)\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const input = [ null, undefined, 5 ]\n\nconst defaultTo = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.defaultTo(3, input[ 0 ])\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.defaultTo(3, input[ 0 ])\n    },\n  },\n  {\n    label : 'Rambda with multiple arguments',\n    fn    : () => {\n      R.defaultTo(3, ...input)\n    },\n  },\n]",
      "methodSummary": "Rambda is faster than Ramda with 73.18%"
    },
    "explanation": "It returns `defaultValue`, if all of `inputArguments` are `undefined`, `null` or `NaN`.\n\nElse, it returns the first truthy `inputArguments` instance(from left to right).",
    "example": "// With single input argument\nR.defaultTo('foo', 'bar') // => 'bar'\nR.defaultTo('foo', undefined) // => 'foo'\n\n// With multiple input arguments\nR.defaultTo('foo', undefined, null, NaN) // => 'foo'\nR.defaultTo('foo', undefined, 'bar', NaN, 'qux') // => 'bar'\nR.defaultTo('foo', undefined, null, NaN, 'quz') // => 'qux'",
    "typescriptDefinitionTest": "import {defaultTo} from 'rambda'\n\ndescribe('defaultTo with Ramda spec', () => {\n  it('happy', () => {\n    const x = defaultTo<string>('foo', undefined) // $ExpectType string\n    x // $ExpectType string\n  })\n  it('fallback', () => {\n    const x = defaultTo('foo', undefined) // $ExpectType \"foo\"\n    x // $ExpectType \"foo\"\n    const y = defaultTo('foo', 'bar') // $ExpectType \"foo\" | \"bar\"\n    y // $ExpectType \"foo\" | \"bar\"\n  })\n  it('with one type', () => {\n    const x = defaultTo<string>('foo', 'bar') // $ExpectType string\n    x // $ExpectType string\n  })\n  it('with two types', () => {\n    const x = defaultTo<string, number>('foo', 1) // $ExpectType string | number\n    x // $ExpectType string | number\n  })\n})\n\ndescribe('defaultTo with Rambda spec', () => {\n  it('happy', () => {\n    const x = defaultTo<string>('foo', undefined, 'bar') // $ExpectType string\n    x // $ExpectType string\n  })\n\n  it('happy with curry', () => {\n    const fn = defaultTo<string>('foo')\n    const x = fn(undefined, 'bar', null) // $ExpectType string\n    x // $ExpectType string\n    const y = fn(undefined) // $ExpectType string\n    y // $ExpectType string\n  })\n\n  it('with two types', () => {\n    const x = defaultTo<string, number>('foo', undefined, 1, null, 2, 'bar') // $ExpectType string | number\n    x // $ExpectType string | number\n  })\n})"
  },
  "difference": {
    "typing": "difference<T>(a: ReadonlyArray<T>, b: ReadonlyArray<T>): T[]",
    "allTypings": "difference<T>(a: ReadonlyArray<T>, b: ReadonlyArray<T>): T[];\ndifference<T>(a: ReadonlyArray<T>): (b: ReadonlyArray<T>) => T[];",
    "rambdaSource": "import { includes } from './includes'\nimport { uniq } from './uniq'\n\nexport function difference(a, b){\n  if (arguments.length === 1) return _b => difference(a, _b)\n\n  return uniq(a).filter(aInstance => !includes(aInstance, b))\n}",
    "rambdaSpecs": "import { difference } from './difference'\n\ntest('difference', () => {\n  const a = [ 1, 2, 3, 4 ]\n  const b = [ 3, 4, 5, 6 ]\n  expect(difference(a)(b)).toEqual([ 1, 2 ])\n\n  expect(difference([], [])).toEqual([])\n})\n\ntest('difference with objects', () => {\n  const a = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 4 } ]\n  const b = [ { id : 3 }, { id : 4 }, { id : 5 }, { id : 6 } ]\n  expect(difference(a, b)).toEqual([ { id : 1 }, { id : 2 } ])\n})\n\ntest('no duplicates in first list', () => {\n  const M2 = [ 1, 2, 3, 4, 1, 2, 3, 4 ]\n  const N2 = [ 3, 3, 4, 4, 5, 5, 6, 6 ]\n  expect(difference(M2, N2)).toEqual([ 1, 2 ])\n})\n\ntest('should use R.equals', () => {\n  expect(difference([ NaN ], [ NaN ]).length).toEqual(0)\n})",
    "explanation": "It returns the uniq set of all elements in the first list `a` not contained in the second list `b`.",
    "example": "const a = [ 1, 2, 3, 4 ]\nconst b = [ 3, 4, 5, 6 ]\n\nconst result = difference(a, b)\n// => [ 1, 2 ]",
    "failedRamdaSpecs": "const eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\n\ndescribe('difference', () => {\n  const M = [ 1, 2, 3, 4 ]\n  const M2 = [ 1, 2, 3, 4, 1, 2, 3, 4 ]\n  const N = [ 3, 4, 5, 6 ]\n  const N2 = [ 3, 3, 4, 4, 5, 5, 6, 6 ]\n  const Z = [ 3, 4, 5, 6, 10 ]\n  const Z2 = [ 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8 ]\n  it('has R.equals semantics', () => {\n    function Just(x){\n      this.value = x\n    }\n    Just.prototype.equals = function (x){\n      return x instanceof Just && R.equals(x.value, this.value)\n    }\n    eq(R.difference([ 0 ], [ -0 ]).length, 1)\n    eq(R.difference([ -0 ], [ 0 ]).length, 1)\n    eq(R.difference([ NaN ], [ NaN ]).length, 0)\n    eq(R.difference([ new Just([ 42 ]) ], [ new Just([ 42 ]) ]).length, 0)\n  })\n})\n",
    "failedSpecsReasons": "ramda supports negative zero"
  },
  "dissoc": {
    "typing": "dissoc<T>(prop: string, obj: any): T",
    "allTypings": "dissoc<T>(prop: string, obj: any): T;\ndissoc(prop: string): <U>(obj: any) => U;",
    "rambdaSource": "export function dissoc(prop, obj){\n  if (arguments.length === 1) return _obj => dissoc(prop, _obj)\n\n  if (obj === null || obj === undefined) return {}\n\n  const willReturn = {}\n  for (const p in obj){\n    willReturn[ p ] = obj[ p ]\n  }\n  delete willReturn[ prop ]\n\n  return willReturn\n}",
    "rambdaSpecs": "import { dissoc } from './dissoc'\n\ntest('input is null or undefined', () => {\n  expect(dissoc('b', null)).toEqual({})\n  expect(dissoc('b', undefined)).toEqual({})\n})\n\ntest('property exists curried', () => {\n  expect(dissoc('b')({\n    a : 1,\n    b : 2,\n  })).toEqual({ a : 1 })\n})\n\ntest('property doesn\\'t exists', () => {\n  expect(dissoc('c', {\n    a : 1,\n    b : 2,\n  })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('works with non-string property', () => {\n  expect(dissoc(42, {\n    a  : 1,\n    42 : 2,\n  })).toEqual({ a : 1 })\n\n  expect(dissoc(null, {\n    a    : 1,\n    null : 2,\n  })).toEqual({ a : 1 })\n\n  expect(dissoc(undefined, {\n    a         : 1,\n    undefined : 2,\n  })).toEqual({ a : 1 })\n})\n\ntest('includes prototype properties', () => {\n  function Rectangle(width, height){\n    this.width = width\n    this.height = height\n  }\n  const area = Rectangle.prototype.area = function (){\n    return this.width * this.height\n  }\n  const rect = new Rectangle(7, 6)\n\n  expect(dissoc('area', rect)).toEqual({\n    width  : 7,\n    height : 6,\n  })\n\n  expect(dissoc('width', rect)).toEqual({\n    height : 6,\n    area   : area,\n  })\n\n  expect(dissoc('depth', rect)).toEqual({\n    width  : 7,\n    height : 6,\n    area   : area,\n  })\n})",
    "explanation": "It returns a new object that does not contain property `prop`.",
    "example": "R.dissoc('b', {a: 1, b: 2, c: 3})\n//=> {a: 1, c: 3}"
  },
  "divide": {
    "typing": "divide(a: number, b: number): number",
    "allTypings": "divide(a: number, b: number): number;\ndivide(a: number): (b: number) => number;",
    "rambdaSource": "export function divide(a, b){\n  if (arguments.length === 1) return _b => divide(a, _b)\n\n  return a / b\n}",
    "rambdaSpecs": "import { divide } from './divide'\n\ntest('happy', () => {\n  expect(divide(71, 100)).toEqual(0.71)\n  expect(divide(71)(100)).toEqual(0.71)\n})",
    "example": "R.divide(71, 100) // => 0.71"
  },
  "drop": {
    "typing": "drop<T>(howManyToDrop: number, listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "drop<T>(howManyToDrop: number, listOrString: ReadonlyArray<T>): T[];\ndrop(howManyToDrop: number, listOrString: string): string;\ndrop<T>(howManyToDrop: number): {",
    "rambdaSource": "export function drop(howManyToDrop, listOrString){\n  if (arguments.length === 1) return _list => drop(howManyToDrop, _list)\n\n  return listOrString.slice(howManyToDrop > 0 ? howManyToDrop : 0)\n}",
    "rambdaSpecs": "import assert from 'assert'\n\nimport { drop } from './drop'\n\ntest('with array', () => {\n  expect(drop(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'baz' ])\n  expect(drop(3, [ 'foo', 'bar', 'baz' ])).toEqual([])\n  expect(drop(4, [ 'foo', 'bar', 'baz' ])).toEqual([])\n})\n\ntest('with string', () => {\n  expect(drop(3, 'rambda')).toEqual('bda')\n})\n\ntest('with non-positive count', () => {\n  expect(drop(0, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(drop(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(drop(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('should return copy', () => {\n  const xs = [ 1, 2, 3 ]\n\n  assert.notStrictEqual(drop(0, xs), xs)\n  assert.notStrictEqual(drop(-1, xs), xs)\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const input = [ 1, 2, 3, 4 ]\n\nconst drop = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.drop(3, input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.drop(3, input)\n    },\n  },\n]",
      "methodSummary": "Rambda is faster than Ramda with 97.91%"
    },
    "explanation": "It returns `listOrString` with `howManyToDrop` items dropped from its beginning.",
    "example": "R.drop(2, ['foo', 'bar', 'baz']) // => ['baz']\nR.drop(2, 'foobar')  // => 'obar'",
    "typescriptDefinitionTest": "import {drop} from 'rambda'\n\ndescribe('drop', () => {\n  it('happy', () => {\n    const x = drop(2, 'foo') // $ExpectType string\n    x // $ExpectType string\n    const xx = drop(2)('foo') // $ExpectType string\n    xx // $ExpectType string\n    const y = drop(2, [1, 2, 3]) // $ExpectType number[]\n    y // $ExpectType number[]\n    const yy = drop<number>(2)([1, 2, 3]) // $ExpectType number[]\n    yy // $ExpectType number[]\n  })\n})"
  },
  "dropLast": {
    "typing": "dropLast<T>(howManyToDrop: number, listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "dropLast<T>(howManyToDrop: number, listOrString: ReadonlyArray<T>): T[];\ndropLast(howManyToDrop: number, listOrString: string): string;\ndropLast<T>(howManyToDrop: number): {",
    "rambdaSource": "export function dropLast(howManyToDrop, listOrString){\n  if (arguments.length === 1){\n    return _listOrString => dropLast(howManyToDrop, _listOrString)\n  }\n\n  return howManyToDrop > 0 ?\n    listOrString.slice(0, -howManyToDrop) :\n    listOrString.slice()\n}",
    "rambdaSpecs": "import assert from 'assert'\n\nimport { dropLast } from './dropLast'\n\ntest('with array', () => {\n  expect(dropLast(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'foo' ])\n  expect(dropLast(3, [ 'foo', 'bar', 'baz' ])).toEqual([])\n  expect(dropLast(4, [ 'foo', 'bar', 'baz' ])).toEqual([])\n})\n\ntest('with string', () => {\n  expect(dropLast(3, 'rambda')).toEqual('ram')\n})\n\ntest('with non-positive count', () => {\n  expect(dropLast(0, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(dropLast(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(dropLast(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('should return copy', () => {\n  const xs = [ 1, 2, 3 ]\n\n  assert.notStrictEqual(dropLast(0, xs), xs)\n  assert.notStrictEqual(dropLast(-1, xs), xs)\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const input = [ 1, 2, 3, 4 ]\n\nconst dropLast = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.dropLast(3, input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.dropLast(3, input)\n    },\n  },\n]",
      "methodSummary": "Rambda is faster than Ramda with 97.64%"
    },
    "explanation": "It returns `listOrString` with `howManyToDrop` items dropped from its end.",
    "example": "R.dropLast(2, ['foo', 'bar', 'baz']) // => ['foo']\nR.dropLast(2, 'foobar')  // => 'foob'",
    "failedRamdaSpecs": "const assert = require('assert')\n\nconst eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\ndescribe('dropLast', () => {\n  it('can act as a transducer', () => {\n    const dropLast2 = R.dropLast(2)\n    assert.deepEqual(R.into(\n      [], dropLast2, [ 1, 3, 5, 7, 9, 1, 2 ]\n    ), [\n      1,\n      3,\n      5,\n      7,\n      9,\n    ])\n    assert.deepEqual(R.into(\n      [], dropLast2, [ 1 ]\n    ), [])\n  })\n})\n",
    "failedSpecsReasons": "ramda method can act as a transducer"
  },
  "either": {
    "typing": "either(firstPredicate: Pred, secondPredicate: Pred): Pred",
    "allTypings": "either(firstPredicate: Pred, secondPredicate: Pred): Pred;\neither(firstPredicate: Pred): (secondPredicate: Pred) => Pred;"
  },
  "endsWith": {
    "typing": "endsWith(a: string, list: string): boolean",
    "allTypings": "endsWith(a: string, list: string): boolean;\nendsWith(a: string): (list: string) => boolean;",
    "notes": "It doesn't work with arrays.",
    "rambdaSource": "export function endsWith(suffix, input){\n  if (arguments.length === 1) return _list => endsWith(suffix, _input)\n\n  return input.endsWith(suffix)\n}",
    "rambdaSpecs": "import { endsWith } from './endsWith'\n\ntest('happy', () => {\n  expect(endsWith('bar', 'foo-bar')).toBeTrue()\n  expect(endsWith('baz')('foo-bar')).toBeFalse()\n})\n\ntest('does not work with arrays', () => {\n  expect(() => endsWith([ 'c' ], [ 'a', 'b', 'c' ])).toThrow('list.endsWith is not a function')\n})",
    "explanation": "It returns `true` if `input` string ends with `suffix`.",
    "example": "const input = 'foo-bar'\nconst suffix = '-bar'\n\nconst result = R.endsWith(suffix, input)\n// => true",
    "failedRamdaSpecs": "const eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\n\ndescribe('startsWith', () => {\n  it('should return true when an array ends with the provided value', () => {\n    eq(R.endsWith([ 'c' ], [ 'a', 'b', 'c' ]), true)\n  })\n  it('should return true when an array ends with the provided values', () => {\n    eq(R.endsWith([ 'b', 'c' ], [ 'a', 'b', 'c' ]), true)\n  })\n  it('should return false when an array does not end with the provided value', () => {\n    eq(R.endsWith([ 'b' ], [ 'a', 'b', 'c' ]), false)\n  })\n  it('should return false when an array does not end with the provided values', () => {\n    eq(R.endsWith([ 'a', 'b' ], [ 'a', 'b', 'c' ]), false)\n  })\n})\n",
    "failedSpecsReasons": "rambda doesn't support arrays"
  },
  "equals": {
    "typing": "equals<T>(a: T, b: T): boolean",
    "allTypings": "equals<T>(a: T, b: T): boolean;\nequals<T>(a: T): (b: T) => boolean;",
    "notes": "It doesn't handle cyclical data structures.",
    "rambdaSource": "import { type } from './type'\n\nfunction parseError(maybeError){\n  const typeofError = maybeError.__proto__.toString()\n  if (![ 'Error', 'TypeError' ].includes(typeofError)) return []\n\n  return [ typeofError, maybeError.message ]\n}\n\nfunction parseDate(maybeDate){\n  if (!maybeDate.toDateString) return [ false ]\n\n  return [ true, maybeDate.getTime() ]\n}\n\nfunction parseRegex(maybeRegex){\n  if (maybeRegex.constructor !== RegExp) return [ false ]\n\n  return [ true, maybeRegex.toString() ]\n}\n\nexport function equals(a, b){\n  if (arguments.length === 1) return _b => equals(a, _b)\n\n  const aType = type(a)\n\n  if (aType !== type(b)) return false\n  if ([ 'NaN', 'Undefined', 'Null' ].includes(aType)) return true\n  if ([ 'Boolean', 'Number', 'String' ].includes(aType))\n    return a.toString() === b.toString()\n\n  if (aType === 'Array'){\n    const aClone = Array.from(a)\n    const bClone = Array.from(b)\n\n    if (aClone.toString() !== bClone.toString()){\n      return false\n    }\n\n    let loopArrayFlag = true\n    aClone.forEach((aCloneInstance, aCloneIndex) => {\n      if (loopArrayFlag){\n        if (\n          aCloneInstance !== bClone[ aCloneIndex ] &&\n          !equals(aCloneInstance, bClone[ aCloneIndex ])\n        ){\n          loopArrayFlag = false\n        }\n      }\n    })\n\n    return loopArrayFlag\n  }\n\n  const aRegex = parseRegex(a)\n  const bRegex = parseRegex(b)\n\n  if (aRegex[ 0 ]){\n    return bRegex[ 0 ] ? aRegex[ 1 ] === bRegex[ 1 ] : false\n  } else if (bRegex[ 0 ]) return false\n\n  const aDate = parseDate(a)\n  const bDate = parseDate(b)\n\n  if (aDate[ 0 ]){\n    return bDate[ 0 ] ? aDate[ 1 ] === bDate[ 1 ] : false\n  } else if (bDate[ 0 ]) return false\n\n  const aError = parseError(a)\n  const bError = parseError(b)\n\n  if (aError[ 0 ]){\n    return bError[ 0 ] ?\n      aError[ 0 ] === bError[ 0 ] && aError[ 1 ] === bError[ 1 ] :\n      false\n  }\n\n  if (aType === 'Object'){\n    const aKeys = Object.keys(a)\n\n    if (aKeys.length !== Object.keys(b).length){\n      return false\n    }\n\n    let loopObjectFlag = true\n    aKeys.forEach(aKeyInstance => {\n      if (loopObjectFlag){\n        const aValue = a[ aKeyInstance ]\n        const bValue = b[ aKeyInstance ]\n\n        if (aValue !== bValue && !equals(aValue, bValue)){\n          loopObjectFlag = false\n        }\n      }\n    })\n\n    return loopObjectFlag\n  }\n\n  return false\n}",
    "rambdaSpecs": "import { equals } from './equals'\n\ntest('happy', () => {\n  const result = equals([ 1, { a : 1 }, [ { b : 3 } ] ], [ 1, { a : 2 }, [ { b : 3 } ] ])\n\n  expect(result).toBeFalse()\n})\n\ntest('with regex', () => {\n  expect(equals(/s/, /s/)).toEqual(true)\n  expect(equals(/s/, /d/)).toEqual(false)\n  expect(equals(/a/gi, /a/gi)).toEqual(true)\n  expect(equals(/a/gim, /a/gim)).toEqual(true)\n  expect(equals(/a/gi, /a/i)).toEqual(false)\n})\n\ntest('not a number', () => {\n  expect(equals([ NaN ], [ NaN ])).toBe(true)\n})\n\ntest('new number', () => {\n  expect(equals(new Number(0), new Number(0))).toEqual(true)\n  expect(equals(new Number(0), new Number(1))).toEqual(false)\n  expect(equals(new Number(1), new Number(0))).toEqual(false)\n})\n\ntest('new string', () => {\n  expect(equals(new String(''), new String(''))).toEqual(true)\n  expect(equals(new String(''), new String('x'))).toEqual(false)\n  expect(equals(new String('x'), new String(''))).toEqual(false)\n  expect(equals(new String('foo'), new String('foo'))).toEqual(true)\n  expect(equals(new String('foo'), new String('bar'))).toEqual(false)\n  expect(equals(new String('bar'), new String('foo'))).toEqual(false)\n})\n\ntest('new Boolean', () => {\n  expect(equals(new Boolean(true), new Boolean(true))).toEqual(true)\n  expect(equals(new Boolean(false), new Boolean(false))).toEqual(true)\n  expect(equals(new Boolean(true), new Boolean(false))).toEqual(false)\n  expect(equals(new Boolean(false), new Boolean(true))).toEqual(false)\n})\n\ntest('new Error', () => {\n  expect(equals(new Error('XXX'), {})).toEqual(false)\n  expect(equals(new Error('XXX'), new TypeError('XXX'))).toEqual(false)\n  expect(equals(new Error('XXX'), new Error('YYY'))).toEqual(false)\n  expect(equals(new Error('XXX'), new Error('XXX'))).toEqual(true)\n  expect(equals(new Error('XXX'), new TypeError('YYY'))).toEqual(false)\n})\n\ntest('with dates', () => {\n  expect(equals(new Date(0), new Date(0))).toEqual(true)\n  expect(equals(new Date(1), new Date(1))).toEqual(true)\n  expect(equals(new Date(0), new Date(1))).toEqual(false)\n  expect(equals(new Date(1), new Date(0))).toEqual(false)\n  expect(equals(new Date(0), {})).toEqual(false)\n  expect(equals({}, new Date(0))).toEqual(false)\n})\n\ntest('ramda spec', () => {\n  expect(equals({}, {})).toEqual(true)\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    a : 1,\n    b : 2,\n  })).toEqual(true)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n  },\n  {\n    b : 3,\n    a : 2,\n  })).toEqual(true)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n  },\n  {\n    a : 3,\n    b : 3,\n  })).toEqual(false)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n    c : 1,\n  },\n  {\n    a : 2,\n    b : 3,\n  })).toEqual(false)\n})\n\ntest('works with boolean tuple', () => {\n  expect(equals([ true, false ], [ true, false ])).toBeTrue()\n  expect(equals([ true, false ], [ true, true ])).toBeFalse()\n})\n\ntest('works with equal objects within array', () => {\n  const objFirst = {\n    a : {\n      b : 1,\n      c : 2,\n      d : [ 1 ],\n    },\n  }\n  const objSecond = {\n    a : {\n      b : 1,\n      c : 2,\n      d : [ 1 ],\n    },\n  }\n\n  const x = [ 1, 2, objFirst, null, '', [] ]\n  const y = [ 1, 2, objSecond, null, '', [] ]\n  expect(equals(x, y)).toBeTrue()\n})\n\ntest('works with different objects within array', () => {\n  const objFirst = { a : { b : 1 } }\n  const objSecond = { a : { b : 2 } }\n\n  const x = [ 1, 2, objFirst, null, '', [] ]\n  const y = [ 1, 2, objSecond, null, '', [] ]\n  expect(equals(x, y)).toBeFalse()\n})\n\ntest('works with undefined as second argument', () => {\n  expect(equals(1, undefined)).toBeFalse()\n\n  expect(equals(undefined, undefined)).toBeTrue()\n})\n\ntest('various examples', () => {\n  expect(equals([ 1, 2, 3 ])([ 1, 2, 3 ])).toBeTrue()\n\n  expect(equals([ 1, 2, 3 ], [ 1, 2 ])).toBeFalse()\n\n  expect(equals(1, 1)).toBeTrue()\n\n  expect(equals(1, '1')).toBeFalse()\n\n  expect(equals({}, {})).toBeTrue()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 2,\n    a : 1,\n  })).toBeTrue()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    a : 1,\n    b : 1,\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : false,\n  },\n  {\n    a : 1,\n    b : 1,\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 2,\n    a : 1,\n    c : 3,\n  })).toBeFalse()\n\n  expect(equals({\n    x : {\n      a : 1,\n      b : 2,\n    },\n  },\n  {\n    x : {\n      b : 2,\n      a : 1,\n      c : 3,\n    },\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 3,\n    a : 1,\n  })).toBeFalse()\n\n  expect(equals({ a : { b : { c : 1 } } }, { a : { b : { c : 1 } } })).toBeTrue()\n\n  expect(equals({ a : { b : { c : 1 } } }, { a : { b : { c : 2 } } })).toBeFalse()\n\n  expect(equals({ a : {} }, { a : {} })).toBeTrue()\n\n  expect(equals('', '')).toBeTrue()\n\n  expect(equals('foo', 'foo')).toBeTrue()\n\n  expect(equals('foo', 'bar')).toBeFalse()\n\n  expect(equals(0, false)).toBeFalse()\n\n  expect(equals(/\\s/g, null)).toBeFalse()\n\n  expect(equals(null, null)).toBeTrue()\n\n  expect(equals(false)(null)).toBeFalse()\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const a = { a : { b : { c : 1 } } }\nconst b = { a : { b : { c : 1 } } }\n\nconst equals = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.equals(a, b)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.equals(a, b)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.isEqual(a, b)\n    },\n  },\n]",
      "methodSummary": "Lodash is fastest. Rambda is 79.8% slower and Ramda is 82.41% slower"
    },
    "explanation": "It deeply compares `a` and `b` and returns `true` if they are equal.",
    "example": "R.equals(\n  [1, {a:2}, [{b: 3}]],\n  [1, {a:2}, [{b: 3}]]\n) // => true",
    "failedRamdaSpecs": "/* global Map, Set, WeakMap, WeakSet */\n\nconst eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\ndescribe('equals', () => {\n  const a = []\n  const b = a\n  it('never considers Boolean primitive equal to Boolean object', () => {\n    eq(R.equals(true, new Boolean(true)), false)\n    eq(R.equals(new Boolean(true), true), false)\n    eq(R.equals(false, new Boolean(false)), false)\n    eq(R.equals(new Boolean(false), false), false)\n  })\n  it('never considers number primitive equal to Number object', () => {\n    eq(R.equals(0, new Number(0)), false)\n    eq(R.equals(new Number(0), 0), false)\n  })\n  it('never considers string primitive equal to String object', () => {\n    eq(R.equals('', new String('')), false)\n    eq(R.equals(new String(''), ''), false)\n    eq(R.equals('x', new String('x')), false)\n    eq(R.equals(new String('x'), 'x'), false)\n  })\n  let supportsSticky = false\n  try {\n    RegExp('', 'y')\n    supportsSticky = true\n  } catch (e){}\n  let supportsUnicode = false\n  try {\n    RegExp('', 'u')\n    supportsUnicode = true\n  } catch (e){}\n  const listA = [ 1, 2, 3 ]\n  const listB = [ 1, 3, 2 ]\n  const c = {}\n  c.v = c\n  const d = {}\n  d.v = d\n  const e = []\n  e.push(e)\n  const f = []\n  f.push(f)\n  const nestA = {\n    a : [ 1, 2, { c : 1 } ],\n    b : 1,\n  }\n  const nestB = {\n    a : [ 1, 2, { c : 1 } ],\n    b : 1,\n  }\n  const nestC = {\n    a : [ 1, 2, { c : 2 } ],\n    b : 1,\n  }\n  it('handles recursive data structures', () => {\n    eq(R.equals(c, d), true)\n    eq(R.equals(e, f), true)\n    eq(R.equals(nestA, nestB), true)\n    eq(R.equals(nestA, nestC), false)\n  })\n  it('requires that both objects have the same enumerable properties with the same values', () => {\n    const a1 = []\n    const a2 = []\n    a2.x = 0\n    const b1 = new Boolean(false)\n    const b2 = new Boolean(false)\n    b2.x = 0\n    const d1 = new Date(0)\n    const d2 = new Date(0)\n    d2.x = 0\n    const n1 = new Number(0)\n    const n2 = new Number(0)\n    n2.x = 0\n    const r1 = /(?:)/\n    const r2 = /(?:)/\n    r2.x = 0\n    const s1 = new String('')\n    const s2 = new String('')\n    s2.x = 0\n    eq(R.equals(a1, a2), false)\n    eq(R.equals(b1, b2), false)\n    eq(R.equals(d1, d2), false)\n    eq(R.equals(n1, n2), false)\n    eq(R.equals(r1, r2), false)\n    eq(R.equals(s1, s2), false)\n  })\n  if (\n    typeof ArrayBuffer !== 'undefined' &&\n    typeof Int8Array !== 'undefined'\n  ){\n    const typArr1 = new ArrayBuffer(10)\n    typArr1[ 0 ] = 1\n    const typArr2 = new ArrayBuffer(10)\n    typArr2[ 0 ] = 1\n    const typArr3 = new ArrayBuffer(10)\n    const intTypArr = new Int8Array(typArr1)\n    typArr3[ 0 ] = 0\n    it('handles typed arrays', () => {\n      eq(R.equals(typArr1, typArr2), true)\n      eq(R.equals(typArr1, typArr3), false)\n      eq(R.equals(typArr1, intTypArr), false)\n    })\n  }\n  if (typeof Promise !== 'undefined'){\n    it('compares Promise objects by identity', () => {\n      const p = Promise.resolve(42)\n      const q = Promise.resolve(42)\n      eq(R.equals(p, p), true)\n      eq(R.equals(p, q), false)\n    })\n  }\n  if (typeof Map !== 'undefined'){\n    it('compares Map objects by value', () => {\n      eq(R.equals(new Map([]), new Map([])), true)\n      eq(R.equals(new Map([]), new Map([ [ 1, 'a' ] ])), false)\n      eq(R.equals(new Map([ [ 1, 'a' ] ]), new Map([])), false)\n      eq(R.equals(new Map([ [ 1, 'a' ] ]), new Map([ [ 1, 'a' ] ])), true)\n      eq(R.equals(new Map([\n        [ 1, 'a' ],\n        [ 2, 'b' ],\n      ]),\n      new Map([\n        [ 2, 'b' ],\n        [ 1, 'a' ],\n      ])),\n      true)\n      eq(R.equals(new Map([ [ 1, 'a' ] ]), new Map([ [ 2, 'a' ] ])), false)\n      eq(R.equals(new Map([ [ 1, 'a' ] ]), new Map([ [ 1, 'b' ] ])), false)\n      eq(R.equals(new Map([\n        [ 1, 'a' ],\n        [ 2, new Map([ [ 3, 'c' ] ]) ],\n      ]),\n      new Map([\n        [ 1, 'a' ],\n        [ 2, new Map([ [ 3, 'c' ] ]) ],\n      ])),\n      true)\n      eq(R.equals(new Map([\n        [ 1, 'a' ],\n        [ 2, new Map([ [ 3, 'c' ] ]) ],\n      ]),\n      new Map([\n        [ 1, 'a' ],\n        [ 2, new Map([ [ 3, 'd' ] ]) ],\n      ])),\n      false)\n      eq(R.equals(new Map([\n        [\n          [ 1, 2, 3 ],\n          [ 4, 5, 6 ],\n        ],\n      ]),\n      new Map([\n        [\n          [ 1, 2, 3 ],\n          [ 4, 5, 6 ],\n        ],\n      ])),\n      true)\n      eq(R.equals(new Map([\n        [\n          [ 1, 2, 3 ],\n          [ 4, 5, 6 ],\n        ],\n      ]),\n      new Map([\n        [\n          [ 1, 2, 3 ],\n          [ 7, 8, 9 ],\n        ],\n      ])),\n      false)\n    })\n    it('dispatches to `equals` method recursively in Set', () => {\n      const a = new Map()\n      const b = new Map()\n      a.set(a, a)\n      eq(R.equals(a, b), false)\n      a.set(b, b)\n      b.set(b, b)\n      b.set(a, a)\n      eq(R.equals(a, b), true)\n    })\n  }\n  if (typeof Set !== 'undefined'){\n    it('compares Set objects by value', () => {\n      eq(R.equals(new Set([]), new Set([])), true)\n      eq(R.equals(new Set([]), new Set([ 1 ])), false)\n      eq(R.equals(new Set([ 1 ]), new Set([])), false)\n      eq(R.equals(new Set([ 1, 2 ]), new Set([ 2, 1 ])), true)\n      eq(R.equals(new Set([ 1, new Set([ 2, new Set([ 3 ]) ]) ]),\n        new Set([ 1, new Set([ 2, new Set([ 3 ]) ]) ])),\n      true)\n      eq(R.equals(new Set([ 1, new Set([ 2, new Set([ 3 ]) ]) ]),\n        new Set([ 1, new Set([ 2, new Set([ 4 ]) ]) ])),\n      false)\n      eq(R.equals(new Set([\n        [ 1, 2, 3 ],\n        [ 4, 5, 6 ],\n      ]),\n      new Set([\n        [ 1, 2, 3 ],\n        [ 4, 5, 6 ],\n      ])),\n      true)\n      eq(R.equals(new Set([\n        [ 1, 2, 3 ],\n        [ 4, 5, 6 ],\n      ]),\n      new Set([\n        [ 1, 2, 3 ],\n        [ 7, 8, 9 ],\n      ])),\n      false)\n    })\n    it('dispatches to `equals` method recursively in Set', () => {\n      const a = new Set()\n      const b = new Set()\n      a.add(a)\n      eq(R.equals(a, b), false)\n      a.add(b)\n      b.add(b)\n      b.add(a)\n      eq(R.equals(a, b), true)\n    })\n  }\n  if (typeof WeakMap !== 'undefined'){\n    it('compares WeakMap objects by identity', () => {\n      const m = new WeakMap([])\n      eq(R.equals(m, m), true)\n      eq(R.equals(m, new WeakMap([])), false)\n    })\n  }\n  if (typeof WeakSet !== 'undefined'){\n    it('compares WeakSet objects by identity', () => {\n      const s = new WeakSet([])\n      eq(R.equals(s, s), true)\n      eq(R.equals(s, new WeakSet([])), false)\n    })\n  }\n  it('dispatches to `equals` method recursively', () => {\n    function Left(x){\n      this.value = x\n    }\n    Left.prototype.equals = function (x){\n      return x instanceof Left && R.equals(x.value, this.value)\n    }\n    function Right(x){\n      this.value = x\n    }\n    Right.prototype.equals = function (x){\n      return x instanceof Right && R.equals(x.value, this.value)\n    }\n    eq(R.equals(new Left([ 42 ]), new Left([ 42 ])), true)\n    eq(R.equals(new Left([ 42 ]), new Left([ 43 ])), false)\n    eq(R.equals(new Left(42), { value : 42 }), false)\n    eq(R.equals({ value : 42 }, new Left(42)), false)\n    eq(R.equals(new Left(42), new Right(42)), false)\n    eq(R.equals(new Right(42), new Left(42)), false)\n    eq(R.equals([ new Left(42) ], [ new Left(42) ]), true)\n    eq(R.equals([ new Left(42) ], [ new Right(42) ]), false)\n    eq(R.equals([ new Right(42) ], [ new Left(42) ]), false)\n    eq(R.equals([ new Right(42) ], [ new Right(42) ]), true)\n  })\n})\n",
    "failedSpecsReasons": "rambda doesn't support recursive data structures, objects with same enumerable properties, map/weakmap type of variables | ramda dispatches to `equals` method recursively"
  },
  "F": {
    "typing": "F(): boolean",
    "allTypings": "F(): boolean;",
    "rambdaSource": "export function F(){\n  return false\n}",
    "example": "F() // => false"
  },
  "filter": {
    "typing": "filter<T>(predicate: FilterFunctionArray<T>): (x: T[]) => T[]",
    "allTypings": "filter<T>(predicate: FilterFunctionArray<T>): (x: T[]) => T[];\nfilter<T>(predicate: FilterFunctionArray<T>, x: T[]): T[];\nfilter<T, U>(predicate: FilterFunctionObject<T>): (x: Dictionary<T>) => Dictionary<T>;\nfilter<T>(predicate: FilterFunctionObject<T>, x: Dictionary<T>): Dictionary<T>;",
    "rambdaSource": "function filterObject(fn, obj){\n  const willReturn = {}\n\n  for (const prop in obj){\n    if (fn(\n      obj[ prop ], prop, obj\n    )){\n      willReturn[ prop ] = obj[ prop ]\n    }\n  }\n\n  return willReturn\n}\n\nexport function filter(predicate, list){\n  if (arguments.length === 1) return _list => filter(predicate, _list)\n\n  if (!list) return []\n\n  if (!Array.isArray(list)){\n    return filterObject(predicate, list)\n  }\n\n  let index = -1\n  let resIndex = 0\n  const len = list.length\n  const willReturn = []\n\n  while (++index < len){\n    const value = list[ index ]\n\n    if (predicate(value, index)){\n      willReturn[ resIndex++ ] = value\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import Ramda from 'ramda'\n\nimport { filter } from './filter'\nimport { T } from './T'\n\nconst sampleObject = {\n  a : 1,\n  b : 2,\n  c : 3,\n  d : 4,\n}\n\ntest('happy', () => {\n  const isEven = n => n % 2 === 0\n\n  expect(filter(isEven, [ 1, 2, 3, 4 ])).toEqual([ 2, 4 ])\n  expect(filter(isEven, {\n    a : 1,\n    b : 2,\n    d : 3,\n  })).toEqual({ b : 2 })\n})\n\ntest('bad inputs', () => {\n  expect(filter(T)(undefined)).toEqual([])\n  expect(filter(T, null)).toEqual([])\n  expect(() => Ramda.filter(T, null)).toThrow()\n  expect(() => Ramda.filter(T, undefined)).toThrow()\n})\n\ntest('predicate when input is object', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n  }\n  const predicate = (\n    val, prop, inputObject\n  ) => {\n    expect(inputObject).toEqual(obj)\n    expect(typeof prop).toEqual('string')\n\n    return val < 2\n  }\n  expect(filter(predicate, obj)).toEqual({ a : 1 })\n})\n\ntest('pass index as second argument', () => {\n  let counter = 0\n  filter((x, i) => {\n    expect(i).toBe(counter)\n    counter++\n  },\n  [ 10, 20, 30 ])\n})\n\ntest('with object', () => {\n  const isEven = n => n % 2 === 0\n  const result = filter(isEven, sampleObject)\n  const expectedResult = {\n    b : 2,\n    d : 4,\n  }\n\n  expect(result).toEqual(expectedResult)\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const arr = [ 1, 2, 3, 4 ]\nconst fn = x => x > 2\nconst filter = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.filter(fn, arr)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.filter(fn, arr)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.filter(arr, fn)\n    },\n  },\n]",
      "methodSummary": "Lodash is fastest. Rambda is 85.25% slower and Ramda is 93.45% slower"
    },
    "explanation": "It filters list or object `input` with `predicate`.",
    "example": "const list = [3, 4, 3, 2]\nconst listPredicate = (x, index) => x - index > 2\n\nconst object = {abc: 'fo', xyz: 'bar', baz: 'foo'}\nconst objectPredicate = (x, prop) => x.length + prop.length > 5\n\nconst result = [\n  R.filter(listPredicate, list),\n  R.filter(objectPredicate, object)\n]\n// => [ [3, 4], { xyz: 'bar', baz: 'foo'} ]",
    "typescriptDefinitionTest": "import {filter} from 'rambda'\n\ndescribe('filter with array', () => {\n  it('1 curry', () => {\n    const x = filter<number>(a => {\n      a // $ExpectType number\n      return a > 1\n    })([1, 2, 3])\n    x // $ExpectType number[]\n  })\n  it('1', () => {\n    const x = filter<number>(\n      a => {\n        a // $ExpectType number\n        return a > 1\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType number[]\n  })\n  it('2', () => {\n    const x = filter<number>(\n      (a, b) => {\n        a // $ExpectType number\n        return a > 1\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType number[]\n  })\n})\n\ndescribe('filter with objects', () => {\n  it('curry', () => {\n    const x = filter<number, number>((a, b, c) => {\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n\n      return a > 1\n    })({a: 1, b: 2})\n    x // $ExpectType Dictionary<number>\n  })\n\n  it('object with three arguments predicate', () => {\n    const x = filter<number>(\n      (a, b, c) => {\n        b // $ExpectType string\n        c // $ExpectType Dictionary<number>\n\n        return a > 1\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<number>\n  })\n\n  it('object with two arguments predicate', () => {\n    const x = filter<number>(\n      (a, b) => {\n        b // $ExpectType string\n        return a > 1\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<number>\n  })\n  it('object with one argument predicate', () => {\n    const x = filter<number>(\n      a => {\n        a // $ExpectType number\n        return a > 1\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<number>\n  })\n})",
    "failedRamdaSpecs": "const eq = require('./shared/eq')\nconst Maybe = require('./shared/Maybe')\nconst R = require('../../../../dist/rambda.js')\n\ndescribe('filter', () => {\n  const even = function (x){\n    return x % 2 === 0\n  }\n  it('dispatches to passed-in non-Array object with a `filter` method', () => {\n    const f = {\n      filter : function (f){\n        return f('called f.filter')\n      },\n    }\n    eq(R.filter(s => s, f),\n      'called f.filter')\n  })\n  it('correctly uses fantasy-land implementations', () => {\n    const m1 = Maybe.Just(-1)\n    const m2 = R.filter(x => x > 0, m1)\n    eq(m2.isNothing, true)\n  })\n})\n",
    "failedSpecsReasons": "ramda dispatches to `filter` method of object"
  },
  "find": {
    "typing": "find<T>(predicate: (a: T) => boolean, arr: ReadonlyArray<T>): T | undefined",
    "allTypings": "find<T>(predicate: (a: T) => boolean, arr: ReadonlyArray<T>): T | undefined;\nfind<T>(predicate: (a: T) => boolean): (arr: ReadonlyArray<T>) => T | undefined;",
    "rambdaSource": "export function find(predicate, list){\n  if (arguments.length === 1) return _list => find(predicate, _list)\n\n  return list.find(predicate)\n}",
    "rambdaSpecs": "import { find } from './find'\nimport { propEq } from './propEq'\n\ntest('happy', () => {\n  expect(find(propEq('a', 2), [ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual({ a : 2 })\n})\n\ntest('with curry', () => {\n  expect(find(propEq('a', 4))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(undefined)\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const fn = x => x > 2\nconst list = [ 1, 2, 3, 4 ]\n\nconst find = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.find(fn, list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.find(fn, list)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.find(list, fn)\n    },\n  },\n]",
      "methodSummary": "Rambda is fastest. Ramda is 92.33% slower and Lodash is 39.13% slower"
    },
    "explanation": "It returns the first element of `list` that satisfy the `predicate`.\n\nIf there is no such element, it returns `undefined`.",
    "example": "const predicate = x => R.type(x.foo) === 'Number'\nconst list = [{foo: 'bar'}, {foo: 1}]\n\nconst result = R.find(predicate, list)\n// => {foo: 1}"
  },
  "findIndex": {
    "typing": "findIndex<T>(findFn: (a: T) => boolean, arr: ReadonlyArray<T>): number",
    "allTypings": "findIndex<T>(findFn: (a: T) => boolean, arr: ReadonlyArray<T>): number;\nfindIndex<T>(findFn: (a: T) => boolean): (arr: ReadonlyArray<T>) => number;",
    "rambdaSource": "export function findIndex(predicate, list){\n  if (arguments.length === 1) return _list => findIndex(predicate, _list)\n\n  const len = list.length\n  let index = -1\n\n  while (++index < len){\n    if (predicate(list[ index ], index)){\n      return index\n    }\n  }\n\n  return -1\n}",
    "rambdaSpecs": "import { findIndex } from './findIndex'\nimport { propEq } from './propEq'\n\ntest('happy', () => {\n  expect(findIndex(propEq('a', 2))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(1)\n\n  expect(findIndex(propEq('a', 1))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(0)\n\n  expect(findIndex(propEq('a', 4))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(-1)\n})\n\ntest('pass index as second argument', () => {\n  findIndex((x, i) => {\n    expect(typeof x).toBe('number')\n    expect(typeof i).toBe('number')\n  })([ 10, 12, 15 ])\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const fn = x => x > 2\nconst list = [ 1, 2, 3, 4 ]\n\nconst findIndex = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.findIndex(fn, list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.findIndex(fn, list)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.findIndex(list, fn)\n    },\n  },\n]",
      "methodSummary": "Rambda is fastest. Ramda is 98.67% slower and Lodash is 82.94% slower"
    },
    "explanation": "It returns the index of the first element of `list` satisfying the `predicate` function.\n\nIf there is no such element, then `-1` is returned.",
    "example": "const predicate = x => R.type(x.foo) === 'Number'\nconst list = [{foo: 'bar'}, {foo: 1}]\n\nconst result = R.findIndex(predicate, list)\n// => 1"
  },
  "flatten": {
    "typing": "flatten<T>(x: ReadonlyArray<T> | ReadonlyArray<T[]> | ReadonlyArray<ReadonlyArray<T>>): T[]",
    "allTypings": "flatten<T>(x: ReadonlyArray<T> | ReadonlyArray<T[]> | ReadonlyArray<ReadonlyArray<T>>): T[];",
    "rambdaSource": "export function flatten(list, input){\n  const willReturn = input === undefined ? [] : input\n\n  for (let i = 0; i < list.length; i++){\n    if (Array.isArray(list[ i ])){\n      flatten(list[ i ], willReturn)\n    } else {\n      willReturn.push(list[ i ])\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { flatten } from './flatten'\n\ntest('happy', () => {\n  expect(flatten([ 1, 2, 3, [ [ [ [ [ 4 ] ] ] ] ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, [ 2, [ [ 3 ] ] ], [ 4 ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, [ 2, [ [ [ 3 ] ] ] ], [ 4 ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, 2, [ 3, 4 ], 5, [ 6, [ 7, 8, [ 9, [ 10, 11 ], 12 ] ] ] ])).toEqual([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ])\n})\n\ntest('readme example', () => {\n  const result = flatten([ 1, 2, [ 3, 30, [ 300 ] ], [ 4 ] ])\n  expect(result).toEqual([ 1, 2, 3, 30, 300, 4 ])\n})",
    "benchmarkInfo": {
      "benchmarkContent": "const list = [ 1, [ 2, [ 3, 4, 6 ] ] ]\n\nconst flatten = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.flatten(list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.flatten(list)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.flatten(list)\n    },\n  },\n]",
      "methodSummary": "Lodash is fastest. Rambda is 96.51% slower and Ramda is 95.67% slower"
    },
    "explanation": "It deeply flattens an array.",
    "example": "const result = R.flatten([\n  1, \n  2, \n  [3, 30, [300]], \n  [4]\n])\n// => [ 1, 2, 3, 30, 300, 4 ]"
  },
  "flip": {
    "typing": "flip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult",
    "allTypings": "flip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult;",
    "rambdaSource": "function flipExport(fn){\n  return (...input) => {\n    if (input.length === 1){\n      return holder => fn(holder, input[ 0 ])\n    } else if (input.length === 2){\n      return fn(input[ 1 ], input[ 0 ])\n    }\n\n    return undefined\n  }\n}\n\nexport function flip(fn){\n  return flipExport(fn)\n}",
    "rambdaSpecs": "import { flip } from './flip'\nimport { subtract } from './subtract'\n\ntest('flip', () => {\n  const fn = flip(subtract)\n\n  expect(fn(1)(7)).toEqual(6)\n  expect(fn(1, 7)).toEqual(6)\n  expect(fn(\n    1, 7, 9\n  )).toEqual(undefined)\n})",
    "explanation": "It returns function which calls `fn` with exchanged first and second argument.",
    "example": "const subtractFlip = R.flip(R.subtract)\n\nconst result = [\n  subtractFlip(1,7),\n  R.flip(1,6)\n]  \n// => [6, -6]",
    "failedRamdaSpecs": "const jsv = require('jsverify')\n\nconst eq = require('./shared/eq')\nconst funcN = require('./shared/funcN')\nconst R = require('../../../../dist/rambda.js')\ndescribe('flip', () => {\n  it('returns a function which inverts the first two arguments to the supplied function', () => {\n    const f = function (\n      a, b, c\n    ){\n      return a + ' ' + b + ' ' + c\n    }\n    const g = R.flip(f)\n    eq(f(\n      'a', 'b', 'c'\n    ), 'a b c')\n    eq(g(\n      'a', 'b', 'c'\n    ), 'b a c')\n  })\n  it('returns a curried function', () => {\n    const f = function (\n      a, b, c\n    ){\n      return a + ' ' + b + ' ' + c\n    }\n    const g = R.flip(f)('a')\n    eq(g('b', 'c'), 'b a c')\n  })\n  it('returns a function with the correct arity', () => {\n    const f2 = function (a, b){\n      return a + ' ' + b\n    }\n    const f3 = function (\n      a, b, c\n    ){\n      return a + ' ' + b + ' ' + c\n    }\n    eq(R.flip(f2).length, 2)\n    eq(R.flip(f3).length, 3)\n  })\n})\ndescribe('flip properties', () => {\n  jsv.property(\n    'inverts first two arguments',\n    funcN(3),\n    jsv.json,\n    jsv.json,\n    jsv.json,\n    (\n      f, a, b, c\n    ) => {\n      const g = R.flip(f)\n\n      return R.equals(f(\n        a, b, c\n      ), g(\n        b, a, c\n      ))\n    }\n  )\n})\n",
    "failedSpecsReasons": "rambda flip work only for functions with two arguments"
  },
  "forEach": {
    "typing": "forEach<T>(fn: (x: T) => void, list: T[]): T[]",
    "allTypings": "forEach<T>(fn: (x: T) => void, list: T[]): T[];\nforEach<T>(fn: (x: T) => void): (list: T[]) => T[];\nforEach<T>(fn: (x: T) => void, list: ReadonlyArray<T>): ReadonlyArray<T>;\nforEach<T>(fn: (x: T) => void): (list: ReadonlyArray<T>) => ReadonlyArray<T>;\nforEach<T>(fn: (value: T, key: string, obj: { [key: string]: T }) => void, obj: { [key: string]: T }): void;\nforEach<T>(fn: (value: T, key: string, obj: { [key: string]: T }) => void): (obj: { [key: string]: T }) => void;",
    "notes": "It works with objects, unlike `Ramda`.",
    "rambdaSource": "import { map } from './map'\n\nexport function forEach(predicate, list){\n  if (arguments.length === 1) return _list => forEach(predicate, _list)\n\n  map(predicate, list)\n\n  return list\n}",
    "rambdaSpecs": "import { forEach } from './forEach'\nimport { type } from './type'\n\ntest('iterate over object', () => {\n  const obj = {\n    a : 1,\n    b : [ 1, 2 ],\n    c : { d : 7 },\n    f : 'foo',\n  }\n  const result = {}\n  const returned = forEach((\n    val, prop, inputObj\n  ) => {\n    expect(type(inputObj)).toBe('Object')\n    result[ prop ] = `${ prop }-${ type(val) }`\n  })(obj)\n\n  const expected = {\n    a : 'a-Number',\n    b : 'b-Array',\n    c : 'c-Object',\n    f : 'f-String',\n  }\n\n  expect(result).toEqual(expected)\n  expect(returned).toEqual(obj)\n})\n\ntest('happy', () => {\n  const sideEffect = {}\n  forEach(x => sideEffect[ `foo${ x }` ] = x + 10)([ 1, 2 ])\n\n  expect(sideEffect).toEqual({\n    foo1 : 11,\n    foo2 : 12,\n  })\n})\n\ntest('happy 2', () => {\n  const list = [\n    {\n      x : 1,\n      y : 2,\n    },\n    {\n      x : 100,\n      y : 200,\n    },\n    {\n      x : 300,\n      y : 400,\n    },\n    {\n      x : 234,\n      y : 345,\n    },\n  ]\n  const sideEffect = {}\n  const result = forEach(elem => {\n    sideEffect[ elem.x ] = elem.y\n  }, list)\n  const expectedSideEffect = {\n    1   : 2,\n    100 : 200,\n    300 : 400,\n    234 : 345,\n  }\n\n  expect(sideEffect).toEqual(expectedSideEffect)\n  expect(result).toEqual(list)\n})\n\ntest('with empty list', () => {\n  const list = []\n  const result = forEach(x => x * x)(list)\n\n  expect(result).toEqual(list)\n})\n\ntest('returns the input', () => {\n  const list = [ 1, 2, 3 ]\n  const result = forEach(x => x * x)(list)\n\n  expect(result).toEqual(list)\n})\n\ntest('pass index as second argument', () => {\n  const list = [ 11, 21, 31 ]\n  const indexes = []\n  const result = forEach((x, i) => indexes.push(i))(list)\n\n  expect(indexes).toEqual([ 0, 1, 2 ])\n})",
    "explanation": "It applies `iterable` function over all members of `list` and returns `list`.",
    "example": "const sideEffect = {}\nconst result = R.forEach(\n  x => sideEffect[`foo${x}`] = x\n)([1, 2])\n\nsideEffect //=> {foo1: 1, foo2: 2}\nresult //=> [1, 2]",
    "failedRamdaSpecs": "const eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\n\ndescribe('forEach', () => {\n  const list = [\n    {\n      x : 1,\n      y : 2,\n    },\n    {\n      x : 100,\n      y : 200,\n    },\n    {\n      x : 300,\n      y : 400,\n    },\n    {\n      x : 234,\n      y : 345,\n    },\n  ]\n  it('dispatches to `forEach` method', () => {\n    let dispatched = false\n    const fn = function (){}\n    function DummyList(){}\n    DummyList.prototype.forEach = function (callback){\n      dispatched = true\n      eq(callback, fn)\n    }\n    R.forEach(fn, new DummyList())\n    eq(dispatched, true)\n  })\n})\n",
    "failedSpecsReasons": "ramda method dispatches to `forEach` method"
  },
  "fromPairs": {
    "typing": "fromPairs<V>(listOfPairs: KeyValuePair<string, V>[]): { [index: string]: V }",
    "allTypings": "fromPairs<V>(listOfPairs: KeyValuePair<string, V>[]): { [index: string]: V };\nfromPairs<V>(listOfPairs: KeyValuePair<number, V>[]): { [index: number]: V };",
    "rambdaSource": "export function fromPairs(listOfPairs){\n  const toReturn = {}\n  listOfPairs.forEach(([ prop, value ]) => toReturn[ prop ] = value)\n\n  return toReturn\n}",
    "rambdaSpecs": "import { fromPairs } from './fromPairs'\n\nconst list = [\n  [ 'a', 1 ],\n  [ 'b', 2 ],\n  [ 'c', [ 3, 4 ] ],\n]\nconst expected = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\n\ntest('happy', () => {\n  expect(fromPairs(list)).toEqual(expected)\n})",
    "explanation": "It transforms a `listOfPairs` to an object.",
    "example": "const listOfPairs = [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', [ 3, 4 ] ] ]\nconst expected = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\n\nconst result = R.fromPairs(listOfPairs)\n// expected === result"
  },
  "groupBy": {
    "typing": "groupBy<T>(groupFn: (a: T) => string, list: ReadonlyArray<T>): { [index: string]: T[] }",
    "allTypings": "groupBy<T>(groupFn: (a: T) => string, list: ReadonlyArray<T>): { [index: string]: T[] };\ngroupBy<T>(groupFn: (a: T) => string): (list: ReadonlyArray<T>) => { [index: string]: T[] };",
    "rambdaSource": "export function groupBy(groupFn, list){\n  if (arguments.length === 1) return _list => groupBy(groupFn, _list)\n\n  const result = {}\n  for (let i = 0; i < list.length; i++){\n    const item = list[ i ]\n    const key = groupFn(item)\n\n    if (!result[ key ]){\n      result[ key ] = []\n    }\n\n    result[ key ].push(item)\n  }\n\n  return result\n}",
    "rambdaSpecs": "import { groupBy } from './groupBy'\nimport { prop } from './prop'\n\ntest('groupBy', () => {\n  const list = [\n    {\n      age  : 12,\n      name : 'john',\n    },\n    {\n      age  : 12,\n      name : 'jack',\n    },\n    {\n      age  : 24,\n      name : 'mary',\n    },\n    {\n      age  : 24,\n      name : 'steve',\n    },\n  ]\n  const expectedResult = {\n    12 : [\n      {\n        age  : 12,\n        name : 'john',\n      },\n      {\n        age  : 12,\n        name : 'jack',\n      },\n    ],\n    24 : [\n      {\n        age  : 24,\n        name : 'mary',\n      },\n      {\n        age  : 24,\n        name : 'steve',\n      },\n    ],\n  }\n\n  expect(groupBy(prop('age'))(list)).toEqual(expectedResult)\n  expect(groupBy(prop('age'), list)).toEqual(expectedResult)\n})",
    "explanation": "It splits `list` according to a provided `groupFn` function and returns an object.",
    "example": "const list = [ 'a', 'b', 'aa', 'bb' ]\nconst groupFn = x => x.length\n\nconst result = R.groupBy(groupFn, list)\n// => { '1': ['a', 'b'], '2': ['aa', 'bb'] }",
    "failedRamdaSpecs": "const _isTransformer = require('rambda/internal/_isTransformer')\nconst eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\n\ndescribe('groupBy', () => {\n  it('dispatches on transformer objects in list position', () => {\n    const byType = R.prop('type')\n    const xf = {\n      '@@transducer/init' : function (){\n        return {}\n      },\n      '@@transducer/result' : function (x){\n        return x\n      },\n      '@@transducer/step' : R.mergeRight,\n    }\n    eq(_isTransformer(R.groupBy(byType, xf)), true)\n  })\n})\n",
    "failedSpecsReasons": "ramda support transforms"
  },
  "groupWith": {
    "typing": "groupWith<T>(compareFn: (x: T, y: T) => boolean): (list: ReadonlyArray<T>) => T[][]",
    "allTypings": "groupWith<T>(compareFn: (x: T, y: T) => boolean): (list: ReadonlyArray<T>) => T[][];\ngroupWith<T>(compareFn: (x: T, y: T) => boolean, list: ReadonlyArray<T>): T[][];\ngroupWith<T>(compareFn: (x: T, y: T) => boolean, list: string): string[];",
    "rambdaSource": "export function groupWith(compareFn, list){\n  if (!Array.isArray(list))\n    throw new TypeError('list.reduce is not a function')\n\n  const clone = list.slice()\n  const toReturn = []\n  let holder = []\n\n  clone.reduce((\n    prev, current, i\n  ) => {\n    if (i === 0) return current\n\n    const okCompare = compareFn(prev, current)\n    const holderIsEmpty = holder.length === 0\n    const lastCall = i === list.length - 1\n\n    if (okCompare){\n      if (holderIsEmpty) holder.push(prev)\n      holder.push(current)\n      if (lastCall) toReturn.push(holder)\n\n      return current\n    }\n\n    if (holderIsEmpty){\n      toReturn.push([ prev ])\n      if (lastCall) toReturn.push([ current ])\n\n      return current\n    }\n\n    toReturn.push(holder)\n    if (lastCall) toReturn.push([ current ])\n    holder = []\n\n    return current\n  }, undefined)\n\n  return toReturn\n}",
    "rambdaSpecs": "import { equals } from './equals'\nimport { groupWith } from './groupWith'\n\ntest('issue is fixed', () => {\n  const result = groupWith(equals, [ 1, 2, 2, 3 ])\n  const expected = [ [ 1 ], [ 2, 2 ], [ 3 ] ]\n  expect(result).toEqual(expected)\n})\n\ntest('long list', () => {\n  const result = groupWith(equals, [\n    0,\n    1,\n    1,\n    2,\n    3,\n    5,\n    8,\n    13,\n    21,\n    21,\n    21,\n    1,\n    2,\n  ])\n\n  const expected = [\n    [ 0 ],\n    [ 1, 1 ],\n    [ 2 ],\n    [ 3 ],\n    [ 5 ],\n    [ 8 ],\n    [ 13 ],\n    [ 21, 21, 21 ],\n    [ 1 ],\n    [ 2 ],\n  ]\n  expect(result).toEqual(expected)\n})\n\ntest('readme example', () => {\n  const list = [ 4, 3, 6, 2, 2, 1 ]\n\n  const result = groupWith((a, b) => a - b === 1, list)\n  const expected = [ [ 4, 3 ], [ 6 ], [ 2 ], [ 2, 1 ] ]\n  expect(result).toEqual(expected)\n})\n\ntest('throw with string as input', () => {\n  expect(() => groupWith(equals, 'Mississippi')).toThrowWithMessage(TypeError,\n    'list.reduce is not a function')\n})\n\nconst isConsecutive = function (a, b){\n  return a + 1 === b\n}\n\ntest('fix coverage', () => {\n  expect(groupWith(isConsecutive, [ 1, 2, 3, 0 ])).toEqual([ [ 1, 2, 3 ], [ 0 ] ])\n})\n\ntest('from ramda 0', () => {\n  expect(groupWith(equals, [])).toEqual([])\n  expect(groupWith(isConsecutive, [])).toEqual([])\n})\n\ntest('from ramda 1', () => {\n  expect(groupWith(isConsecutive, [ 4, 3, 2, 1 ])).toEqual([\n    [ 4 ],\n    [ 3 ],\n    [ 2 ],\n    [ 1 ],\n  ])\n})\n\ntest('from ramda 2', () => {\n  expect(groupWith(isConsecutive, [ 1, 2, 3, 4 ])).toEqual([ [ 1, 2, 3, 4 ] ])\n})\n\ntest('from ramda 3', () => {\n  expect(groupWith(isConsecutive, [ 1, 2, 2, 3 ])).toEqual([\n    [ 1, 2 ],\n    [ 2, 3 ],\n  ])\n  expect(groupWith(isConsecutive, [ 1, 2, 9, 3, 4 ])).toEqual([\n    [ 1, 2 ],\n    [ 9 ],\n    [ 3, 4 ],\n  ])\n})",
    "explanation": "It returns splitted version of `list`, where separation is done with equality `compareFn` function.",
    "example": "const compareFn = (x, y) => x === y\nconst list = [1, 2, 2, 1, 1, 2]\n\nconst result = R.groupWith(isConsecutive, list)\n// => [[1], [2,2], [1,1], [2]]",
    "failedRamdaSpecs": "const eq = require('./shared/eq')\nconst R = require('../../../../dist/rambda.js')\n\ndescribe('groupWith', () => {\n  it('can be turned into the original list through concatenation', () => {\n    const list = [ 1, 1, 2, 3, 4, 4, 5, 5 ]\n    eq(R.unnest(R.groupWith(R.equals, list)), list)\n    eq(R.unnest(R.groupWith(R.complement(R.equals), list)), list)\n    eq(R.unnest(R.groupWith(R.T, list)), list)\n    eq(R.unnest(R.groupWith(R.F, list)), list)\n  })\n  it('also works on strings', () => {\n    eq(R.groupWith(R.equals)('Mississippi'), [\n      'M',\n      'i',\n      'ss',\n      'i',\n      'ss',\n      'i',\n      'pp',\n      'i',\n    ])\n  })\n})\n"
  },
  "has": {
    "typing": "has<T>(prop: string, obj: T): boolean",
    "allTypings": "has<T>(prop: string, obj: T): boolean;\nhas(prop: string): <T>(obj: T) => boolean;"
  },
  "head": {
    "typing": "head<T>(listOrString: T[]): T | undefined",
    "allTypings": "head<T>(listOrString: T[]): T | undefined;\nhead(listOrString: string): string;"
  },
  "identical": {
    "typing": "identical<T>(a: T, b: T): boolean",
    "allTypings": "identical<T>(a: T, b: T): boolean;\nidentical<T>(a: T): (b: T) => boolean;"
  },
  "identity": {
    "typing": "identity<T>(x: T): T",
    "allTypings": "identity<T>(x: T): T;"
  },
  "ifElse": {
    "typing": "ifElse(fn: Pred, onTrue: Arity1Fn, onFalse: Arity1Fn): Arity1Fn",
    "allTypings": "ifElse(fn: Pred, onTrue: Arity1Fn, onFalse: Arity1Fn): Arity1Fn;\nifElse(fn: Pred, onTrue: Arity2Fn, onFalse: Arity2Fn): Arity2Fn;"
  },
  "inc": {
    "typing": "inc(n: number): number",
    "allTypings": "inc(n: number): number;"
  },
  "includes": {
    "typing": "includes(valueToFind: string, input: ReadonlyArray<string> | string): boolean",
    "allTypings": "includes(valueToFind: string, input: ReadonlyArray<string> | string): boolean;\nincludes(valueToFind: string): (input: ReadonlyArray<string> | string) => boolean;\nincludes<T>(valueToFind: T, input: ReadonlyArray<T>): boolean;\nincludes<T>(valueToFind: T): (input: ReadonlyArray<T>) => boolean;"
  },
  "indexBy": {
    "typing": "indexBy<T>(condition: (a: T) => string, arr: ReadonlyArray<T>): { [key: string]: T }",
    "allTypings": "indexBy<T>(condition: (a: T) => string, arr: ReadonlyArray<T>): { [key: string]: T };\nindexBy<T>(condition: string, arr: ReadonlyArray<T>): { [key: string]: T };\nindexBy<T>(condition: (a: T) => string): (arr: ReadonlyArray<T>) => { [key: string]: T };\nindexBy<T>(condition: string): (arr: ReadonlyArray<T>) => { [key: string]: T };"
  },
  "indexOf": {
    "typing": "indexOf<T>(target: T, arr: ReadonlyArray<T>): number",
    "allTypings": "indexOf<T>(target: T, arr: ReadonlyArray<T>): number;\nindexOf<T>(target: T): (arr: ReadonlyArray<T>) => number;"
  },
  "init": {
    "typing": "init<T>(listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "init<T>(listOrString: ReadonlyArray<T>): T[];\ninit(listOrString: string): string;"
  },
  "intersperse": {
    "typing": "intersperse<T>(separator: T, list: ReadonlyArray<T>): T[]",
    "allTypings": "intersperse<T>(separator: T, list: ReadonlyArray<T>): T[];\nintersperse<T>(separator: T): (list: ReadonlyArray<T>) => T[];"
  },
  "intersection": {
    "typing": "intersection<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]",
    "allTypings": "intersection<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\nintersection<T>(list1: ReadonlyArray<T>): (list2: ReadonlyArray<T>) => T[];"
  },
  "is": {
    "typing": "is(xPrototype: any, x: any): boolean",
    "allTypings": "is(xPrototype: any, x: any): boolean;\nis(xPrototype: any): (x: any) => boolean;"
  },
  "isEmpty": {
    "typing": "isEmpty<T>(input: T): boolean",
    "allTypings": "isEmpty<T>(input: T): boolean;"
  },
  "isNil": {
    "typing": "isNil(x: any): x is null | undefined",
    "allTypings": "isNil(x: any): x is null | undefined;"
  },
  "join": {
    "typing": "join(x: string, xs: ReadonlyArray<any>): string",
    "allTypings": "join(x: string, xs: ReadonlyArray<any>): string;\njoin(x: string): (xs: ReadonlyArray<any>) => string;"
  },
  "keys": {
    "typing": "keys<T extends object>(x: T): (keyof T)[]",
    "allTypings": "keys<T extends object>(x: T): (keyof T)[];\nkeys<T>(x: T): string[];"
  },
  "last": {
    "typing": "last<T>(listOrString: T[]): T | undefined",
    "allTypings": "last<T>(listOrString: T[]): T | undefined;\nlast(listOrString: string): string;"
  },
  "lastIndexOf": {
    "typing": "lastIndexOf<T>(x: T, arr: ReadonlyArray<T>): number",
    "allTypings": "lastIndexOf<T>(x: T, arr: ReadonlyArray<T>): number;"
  },
  "length": {
    "typing": "length<T>(list: ReadonlyArray<T>): number",
    "allTypings": "length<T>(list: ReadonlyArray<T>): number;"
  },
  "lens": {
    "typing": "lens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens",
    "allTypings": "lens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens;\nlens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens;"
  },
  "lensIndex": {
    "typing": "lensIndex(n: number): Lens",
    "allTypings": "lensIndex(n: number): Lens;\nlensPath(path: RamdaPath): Lens;"
  },
  "lensProp": {
    "typing": "lensProp(str: string): {\n  <T, U>(obj: T): U",
    "allTypings": "lensProp(str: string): {"
  },
  "over": {
    "typing": "over<T>(lens: Lens, fn: Arity1Fn, value: T): T",
    "allTypings": "over<T>(lens: Lens, fn: Arity1Fn, value: T): T;\nover<T>(lens: Lens, fn: Arity1Fn, value: readonly T[]): T[];\nover(lens: Lens, fn: Arity1Fn): <T>(value: T) => T;\nover(lens: Lens, fn: Arity1Fn): <T>(value: readonly T[]) => T[];\nover(lens: Lens): <T>(fn: Arity1Fn, value: T) => T;\nover(lens: Lens): <T>(fn: Arity1Fn, value: readonly T[]) => T[];"
  },
  "set": {
    "typing": "set<T, U>(lens: Lens, a: U, obj: T): T",
    "allTypings": "set<T, U>(lens: Lens, a: U, obj: T): T;\nset<U>(lens: Lens, a: U): <T>(obj: T) => T;\nset(lens: Lens): <T, U>(a: U, obj: T) => T;"
  },
  "view": {
    "typing": "view<T, U>(lens: Lens): (obj: T) => U",
    "allTypings": "view<T, U>(lens: Lens): (obj: T) => U;\nview<T, U>(lens: Lens, obj: T): U;"
  },
  "map": {
    "typing": "map<T, U>(mapFn: MapFunctionObject<T, U>, x: Dictionary<T>): Dictionary<U>",
    "allTypings": "map<T, U>(mapFn: MapFunctionObject<T, U>, x: Dictionary<T>): Dictionary<U>;\nmap<T, U>(mapFn: MapFunctionArray<T, U>, x: T[]): U[];\nmap<T, U>(mapFn: MapFunctionArray<T, U>): (x: T[]) => U[];\nmap<T, U, S>(mapFn: MapFunctionObject<T, U>): (x: Dictionary<T>) => Dictionary<U>;\nmap<T>(mapFn: MapFunctionArray<T, T>): (x: T[]) => T[];\nmap<T>(mapFn: MapFunctionArray<T, T>, x: ReadonlyArray<T>): T[];"
  },
  "match": {
    "typing": "match(regexp: RegExp, str: string): any[]",
    "allTypings": "match(regexp: RegExp, str: string): any[];\nmatch(regexp: RegExp): (str: string) => any[];"
  },
  "max": {
    "typing": "max<T extends Ord>(a: T, b: T): T",
    "allTypings": "max<T extends Ord>(a: T, b: T): T;\nmax<T extends Ord>(a: T): (b: T) => T;"
  },
  "maxBy": {
    "typing": "maxBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T",
    "allTypings": "maxBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T;\nmaxBy<T>(keyFn: (a: T) => Ord, a: T): (b: T) => T;\nmaxBy<T>(keyFn: (a: T) => Ord): FToolbelt.Curry<(a: T, b: T) => T>;"
  },
  "mean": {
    "typing": "mean(list: ReadonlyArray<number>): number",
    "allTypings": "mean(list: ReadonlyArray<number>): number;"
  },
  "median": {
    "typing": "median(list: ReadonlyArray<number>): number",
    "allTypings": "median(list: ReadonlyArray<number>): number;"
  },
  "merge": {
    "typing": "merge<T1, T2>(a: T1, b: T2): Merge<T2, T1>",
    "allTypings": "merge<T1, T2>(a: T1, b: T2): Merge<T2, T1>;\nmerge<T1>(a: T1): <T2>(b: T2) => Merge<T2, T1>;"
  },
  "min": {
    "typing": "min<T extends Ord>(a: T, b: T): T",
    "allTypings": "min<T extends Ord>(a: T, b: T): T;\nmin<T extends Ord>(a: T): (b: T) => T;"
  },
  "minBy": {
    "typing": "minBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T",
    "allTypings": "minBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T;\nminBy<T>(keyFn: (a: T) => Ord, a: T): (b: T) => T;\nminBy<T>(keyFn: (a: T) => Ord): FToolbelt.Curry<(a: T, b: T) => T>;"
  },
  "modulo": {
    "typing": "modulo(a: number, b: number): number",
    "allTypings": "modulo(a: number, b: number): number;\nmodulo(a: number): (b: number) => number;"
  },
  "multiply": {
    "typing": "multiply(a: number, b: number): number",
    "allTypings": "multiply(a: number, b: number): number;\nmultiply(a: number): (b: number) => number;"
  },
  "negate": {
    "typing": "negate(a: number): number",
    "allTypings": "negate(a: number): number;"
  },
  "none": {
    "typing": "none<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): boolean",
    "allTypings": "none<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): boolean;\nnone<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => boolean;"
  },
  "not": {
    "typing": "not(x: any): boolean",
    "allTypings": "not(x: any): boolean;"
  },
  "nth": {
    "typing": "nth<T>(n: number, list: ReadonlyArray<T>): T | undefined",
    "allTypings": "nth<T>(n: number, list: ReadonlyArray<T>): T | undefined;\nnth(n: number): <T>(list: ReadonlyArray<T>) => T | undefined;"
  },
  "omit": {
    "typing": "omit<T>(propsToOmit: string | string[], obj: Dictionary<T>): Dictionary<T>",
    "allTypings": "omit<T>(propsToOmit: string | string[], obj: Dictionary<T>): Dictionary<T>;\nomit<T>(propsToOmit: string | string[]): (obj: Dictionary<T>) => Dictionary<T>;\nomit<T, U>(propsToOmit: string | string[], obj: Dictionary<T>): U;\nomit<T, U>(propsToOmit: string | string[]): (obj: Dictionary<T>) => U;"
  },
  "partial": {
    "typing": "partial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, x0: V0): (x1: V1) => T",
    "allTypings": "partial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, x0: V0): (x1: V1) => T;\npartial<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, x0: V0, x1: V1): (x2: V2) => T;\npartial<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, x0: V0): (x1: V1, x2: V2) => T;\npartial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, x0: V0, x1: V1, x2: V2): (x2: V3) => T;\npartial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, x0: V0, x1: V1): (x2: V2, x3: V3) => T;\npartial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, x0: V0): (x1: V1, x2: V2, x3: V3) => T;\npartial<T>(fn: (...a: any[]) => T, ...args: any[]): (...a: any[]) => T;"
  },
  "path": {
    "typing": "path<Input, T>(pathToSearch: string | string[], obj: Input): T | undefined",
    "allTypings": "path<Input, T>(pathToSearch: string | string[], obj: Input): T | undefined;\npath<T>(pathToSearch: string | string[], obj: any): T | undefined;\npath<T>(pathToSearch: string | string[]): (obj: any) => T | undefined;\npath<Input, T>(pathToSearch: string | string[]): (obj: Input) => T | undefined;"
  },
  "paths": {
    "typing": "paths<Input, T>(pathsToSearch: (string | string[])[], obj: Input): (T | undefined)[]",
    "allTypings": "paths<Input, T>(pathsToSearch: (string | string[])[], obj: Input): (T | undefined)[];\npaths<T>(pathsToSearch: (string | string[])[], obj: any): (T | undefined)[];\npaths<T>(pathsToSearch: (string | string[])[]): (obj: any) => (T | undefined)[];\npaths<Input, T>(pathsToSearch: (string | string[])[]): (obj: Input) => (T | undefined)[];"
  },
  "pathOr": {
    "typing": "pathOr<T>(defaultValue: T, pathToSearch: Path, obj: any): T",
    "allTypings": "pathOr<T>(defaultValue: T, pathToSearch: Path, obj: any): T;\npathOr<T>(defaultValue: T, pathToSearch: Path): (obj: any) => T;\npathOr<T>(defaultValue: T): FToolbelt.Curry<(a: Path, b: any) => T>;"
  },
  "pick": {
    "typing": "pick<T>(propsToPick: string | string[], obj: Dictionary<T>): Dictionary<T>",
    "allTypings": "pick<T>(propsToPick: string | string[], obj: Dictionary<T>): Dictionary<T>;\npick<T>(propsToPick: string | string[]): (obj: Dictionary<T>) => Dictionary<T>;\npick<T, U>(propsToPick: string | string[], obj: Dictionary<T>): U;\npick<T, U>(propsToPick: string | string[]): (obj: Dictionary<T>) => U;"
  },
  "pickAll": {
    "typing": "pickAll<T, U>(names: ReadonlyArray<string>, obj: T): U",
    "allTypings": "pickAll<T, U>(names: ReadonlyArray<string>, obj: T): U;\npickAll(names: ReadonlyArray<string>): <T, U>(obj: T) => U;"
  },
  "pipe": {
    "typing": "pipe<T1>(fn0: () => T1): () => T1",
    "allTypings": "pipe<T1>(fn0: () => T1): () => T1;\npipe<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;\npipe<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;\npipe<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;"
  },
  "pluck": {
    "typing": "pluck<T>(property: number, arr: ReadonlyArray<T>): T",
    "allTypings": "pluck<T>(property: number, arr: ReadonlyArray<T>): T;\npluck<K extends keyof T, T>(property: K, arr: ReadonlyArray<T>): T[K][];\npluck(property: number): <T>(arr: ReadonlyArray<T>) => T;\npluck<P extends string>(property: P): <T>(arr: ReadonlyArray<Record<P, T>>) => T[];"
  },
  "prepend": {
    "typing": "prepend<T>(x: T, arr: ReadonlyArray<T>): T[]",
    "allTypings": "prepend<T>(x: T, arr: ReadonlyArray<T>): T[];\nprepend<T>(x: T): (arr: ReadonlyArray<T>) => T[];"
  },
  "product": {
    "typing": "product(list: ReadonlyArray<number>): number",
    "allTypings": "product(list: ReadonlyArray<number>): number;"
  },
  "prop": {
    "typing": "prop<P extends keyof T, T>(propToFind: P, obj: T): T[P]",
    "allTypings": "prop<P extends keyof T, T>(propToFind: P, obj: T): T[P];\nprop<P extends string>(p: P): <T>(propToFind: Record<P, T>) => T;\nprop<P extends string, T>(p: P): (propToFind: Record<P, T>) => T;"
  },
  "propEq": {
    "typing": "propEq<T>(propToFind: string | number, valueToMatch: T, obj: any): boolean",
    "allTypings": "propEq<T>(propToFind: string | number, valueToMatch: T, obj: any): boolean;\npropEq<T>(propToFind: string | number, valueToMatch: T): (obj: any) => boolean;\npropEq(propToFind: string | number): {"
  },
  "propIs": {
    "typing": "propIs<P extends keyof T, T>(type: any, name: P, obj: T): boolean",
    "allTypings": "propIs<P extends keyof T, T>(type: any, name: P, obj: T): boolean;\npropIs<P extends string>(type: any, name: P): <T>(obj: Record<P, T>) => boolean;"
  },
  "propOr": {
    "typing": "propOr<T, U, V>(val: T, p: string, obj: U): V",
    "allTypings": "propOr<T, U, V>(val: T, p: string, obj: U): V;\npropOr<T>(val: T, p: string): <U, V>(obj: U) => V;\npropOr<T>(val: T): <U, V>(p: string, obj: U) => V;"
  },
  "range": {
    "typing": "range(start: number, end: number): number[]",
    "allTypings": "range(start: number, end: number): number[];\nrange(start: number): (end: number) => number[];"
  },
  "reduce": {
    "typing": "reduce<T, TResult>(fn: (acc: TResult, elem: T, i: number) => TResult, acc: TResult, list: ReadonlyArray<T>): TResult",
    "allTypings": "reduce<T, TResult>(fn: (acc: TResult, elem: T, i: number) => TResult, acc: TResult, list: ReadonlyArray<T>): TResult;\nreduce<T, TResult>(fn: (acc: TResult, elem: T) => TResult, acc: TResult, list: ReadonlyArray<T>): TResult;\nreduce<T, TResult>(fn: (acc: TResult, elem: T, i?: number) => TResult): (acc: TResult, list: ReadonlyArray<T>) => TResult;\nreduce<T, TResult>(fn: (acc: TResult, elem: T, i?: number) => TResult, acc: TResult): (list: ReadonlyArray<T>) => TResult;"
  },
  "reject": {
    "typing": "reject<T>(filterFn: FilterFunctionArray<T>): (x: T[]) => T[]",
    "allTypings": "reject<T>(filterFn: FilterFunctionArray<T>): (x: T[]) => T[];\nreject<T>(filterFn: FilterFunctionArray<T>, x: T[]): T[];\nreject<T, U>(filterFn: FilterFunctionObject<T>): (x: Dictionary<T>) => Dictionary<T>;\nreject<T>(filterFn: FilterFunctionObject<T>, x: Dictionary<T>): Dictionary<T>;"
  },
  "repeat": {
    "typing": "repeat<T>(a: T, n: number): T[]",
    "allTypings": "repeat<T>(a: T, n: number): T[];\nrepeat<T>(a: T): (n: number) => T[];"
  },
  "replace": {
    "typing": "replace(strOrRegex: RegExp | string, replacer: string, str: string): string",
    "allTypings": "replace(strOrRegex: RegExp | string, replacer: string, str: string): string;\nreplace(strOrRegex: RegExp | string, replacer: string): (str: string) => string;\nreplace(strOrRegex: RegExp | string): (replacer: string) => (str: string) => string;"
  },
  "reverse": {
    "typing": "reverse<T>(list: ReadonlyArray<T>): T[]",
    "allTypings": "reverse<T>(list: ReadonlyArray<T>): T[];\nreverse(str: string): string;"
  },
  "slice": {
    "typing": "slice(a: number, b: number, list: string): string",
    "allTypings": "slice(a: number, b: number, list: string): string;\nslice<T>(a: number, b: number, list: T[]): T[];\nslice(a: number, b: number): {"
  },
  "sort": {
    "typing": "sort<T>(sortFn: (a: T, b: T) => number, arr: ReadonlyArray<T>): T[]",
    "allTypings": "sort<T>(sortFn: (a: T, b: T) => number, arr: ReadonlyArray<T>): T[];\nsort<T>(sortFn: (a: T, b: T) => number): (arr: ReadonlyArray<T>) => T[];"
  },
  "sortBy": {
    "typing": "sortBy<T>(sortFn: (a: T) => Ord, arr: ReadonlyArray<T>): T[]",
    "allTypings": "sortBy<T>(sortFn: (a: T) => Ord, arr: ReadonlyArray<T>): T[];\nsortBy(sortFn: (a: any) => Ord): <T>(arr: ReadonlyArray<T>) => T[];"
  },
  "split": {
    "typing": "split(sep: string | RegExp): (str: string) => string[]",
    "allTypings": "split(sep: string | RegExp): (str: string) => string[];\nsplit(sep: string | RegExp, str: string): string[];"
  },
  "splitEvery": {
    "typing": "splitEvery<T>(a: number, list: ReadonlyArray<T>): T[][]",
    "allTypings": "splitEvery<T>(a: number, list: ReadonlyArray<T>): T[][];\nsplitEvery(a: number, list: string): string[];\nsplitEvery(a: number): {"
  },
  "startsWith": {
    "typing": "startsWith(a: string, list: string): boolean",
    "allTypings": "startsWith(a: string, list: string): boolean;\nstartsWith(a: string): (list: string) => boolean;\nstartsWith<T>(a: T | ReadonlyArray<T>, list: ReadonlyArray<T>): boolean;\nstartsWith<T>(a: T | ReadonlyArray<T>): (list: ReadonlyArray<T>) => boolean;"
  },
  "subtract": {
    "typing": "subtract(a: number, b: number): number",
    "allTypings": "subtract(a: number, b: number): number;\nsubtract(a: number): (b: number) => number;"
  },
  "sum": {
    "typing": "sum(list: ReadonlyArray<number>): number",
    "allTypings": "sum(list: ReadonlyArray<number>): number;"
  },
  "symmetricDifference": {
    "typing": "symmetricDifference<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]",
    "allTypings": "symmetricDifference<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\nsymmetricDifference<T>(list: ReadonlyArray<T>): <T>(list: ReadonlyArray<T>) => T[];"
  },
  "T": {
    "typing": "T(): boolean",
    "allTypings": "T(): boolean;"
  },
  "tail": {
    "typing": "tail<T>(listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "tail<T>(listOrString: ReadonlyArray<T>): T[];\ntail(listOrString: string): string;"
  },
  "take": {
    "typing": "take<T>(num: number, listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "take<T>(num: number, listOrString: ReadonlyArray<T>): T[];\ntake(num: number, listOrString: string): string;\ntake<T>(num: number): {"
  },
  "takeLast": {
    "typing": "takeLast<T>(num: number, listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "takeLast<T>(num: number, listOrString: ReadonlyArray<T>): T[];\ntakeLast(num: number, listOrString: string): string;\ntakeLast(num: number): {"
  },
  "tap": {
    "typing": "tap<T>(fn: (a: T) => any, value: T): T",
    "allTypings": "tap<T>(fn: (a: T) => any, value: T): T;\ntap<T>(fn: (a: T) => any): (value: T) => T;"
  },
  "test": {
    "typing": "test(regExpression: RegExp): (str: string) => boolean",
    "allTypings": "test(regExpression: RegExp): (str: string) => boolean;\ntest(regExpression: RegExp, str: string): boolean;"
  },
  "times": {
    "typing": "times<T>(fn: (i: number) => T, n: number): T[]",
    "allTypings": "times<T>(fn: (i: number) => T, n: number): T[];\ntimes<T>(fn: (i: number) => T): (n: number) => T[];"
  },
  "transpose": {
    "typing": "transpose<T>(list: T[][]): T[][]",
    "allTypings": "transpose<T>(list: T[][]): T[][];"
  },
  "toPairs": {
    "typing": "toPairs<S>(obj: { [k: string]: S } | { [k: number]: S }): [string, S][]",
    "allTypings": "toPairs<S>(obj: { [k: string]: S } | { [k: number]: S }): [string, S][];"
  },
  "toLower": {
    "typing": "toLower(str: string): string",
    "allTypings": "toLower(str: string): string;"
  },
  "toString": {
    "typing": "toString<T>(val: T): string",
    "allTypings": "toString<T>(val: T): string;"
  },
  "toUpper": {
    "typing": "toUpper(str: string): string",
    "allTypings": "toUpper(str: string): string;"
  },
  "trim": {
    "typing": "trim(str: string): string",
    "allTypings": "trim(str: string): string;"
  },
  "type": {
    "typing": "type(val: any): \"Object\" | \"Number\" | \"Boolean\" | \"String\" | \"Null\" | \"Array\" | \"Function\" | \"Undefined\" | \"Async\" | \"Promise\" | \"RegExp\" | \"NaN\"",
    "allTypings": "type(val: any): \"Object\" | \"Number\" | \"Boolean\" | \"String\" | \"Null\" | \"Array\" | \"Function\" | \"Undefined\" | \"Async\" | \"Promise\" | \"RegExp\" | \"NaN\";"
  },
  "uniq": {
    "typing": "uniq<T>(arr: ReadonlyArray<T>): T[]",
    "allTypings": "uniq<T>(arr: ReadonlyArray<T>): T[];"
  },
  "uniqWith": {
    "typing": "uniqWith<T, U>(fn: (x: T, y: T) => boolean, arr: ReadonlyArray<T>): T[]",
    "allTypings": "uniqWith<T, U>(fn: (x: T, y: T) => boolean, arr: ReadonlyArray<T>): T[];\nuniqWith<T, U>(fn: (x: T, y: T) => boolean): (arr: ReadonlyArray<T>) => T[];"
  },
  "update": {
    "typing": "update<T>(index: number, value: T, list: ReadonlyArray<T>): T[]",
    "allTypings": "update<T>(index: number, value: T, list: ReadonlyArray<T>): T[];\nupdate<T>(index: number, value: T): (list: ReadonlyArray<T>) => T[];"
  },
  "values": {
    "typing": "values<T extends object, K extends keyof T>(obj: T): T[K][]",
    "allTypings": "values<T extends object, K extends keyof T>(obj: T): T[K][];"
  },
  "without": {
    "typing": "without<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]",
    "allTypings": "without<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\nwithout<T>(list1: ReadonlyArray<T>): (list2: ReadonlyArray<T>) => T[];"
  },
  "xor": {
    "typing": "xor(a: boolean, b: boolean): boolean",
    "allTypings": "xor(a: boolean, b: boolean): boolean;\nxor(a: boolean): (b: boolean) => boolean;"
  },
  "zip": {
    "typing": "zip<K, V>(list1: ReadonlyArray<K>, list2: ReadonlyArray<V>): KeyValuePair<K, V>[]",
    "allTypings": "zip<K, V>(list1: ReadonlyArray<K>, list2: ReadonlyArray<V>): KeyValuePair<K, V>[];\nzip<K>(list1: ReadonlyArray<K>): <V>(list2: ReadonlyArray<V>) => KeyValuePair<K, V>[];"
  },
  "zipObj": {
    "typing": "zipObj<T>(keys: ReadonlyArray<string>, values: ReadonlyArray<T>): { [index: string]: T }",
    "allTypings": "zipObj<T>(keys: ReadonlyArray<string>, values: ReadonlyArray<T>): { [index: string]: T };\nzipObj(keys: ReadonlyArray<string>): <T>(values: ReadonlyArray<T>) => { [index: string]: T };"
  }
}
