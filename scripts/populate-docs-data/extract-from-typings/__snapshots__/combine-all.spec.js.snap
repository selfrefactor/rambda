// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`happy 1`] = `
Object {
  "F": Object {
    "typing": "F(): boolean",
  },
  "T": Object {
    "typing": "T(): boolean",
  },
  "add": Object {
    "examples": "It adds \`a\` and \`b\`. It doesn't work with strings, as the inputs are parsed to numbers before calculation.",
    "explanations": "It adds \`a\` and \`b\`. It doesn't work with strings, as the inputs are parsed to numbers before calculation.",
    "typing": "add(a: number, b: number): number",
  },
  "adjust": Object {
    "examples": "It replaces \`index\` in array \`list\` with the result of \`replaceFn(arr[i])\`.",
    "explanations": "It replaces \`index\` in array \`list\` with the result of \`replaceFn(arr[i])\`.",
    "typing": "adjust<T>(index: number, replaceFn: (a: T) => T, list: ReadonlyArray<T>): T[]",
  },
  "all": Object {
    "typing": "all<T>(fn: (x: T) => boolean, list: ReadonlyArray<T>): boolean",
  },
  "allFalse": Object {
    "typing": "allFalse(...input: Array<any>): boolean
export function anyFalse(...input: Array<any>): boolean


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function allTrue(...input: Array<any>): boolean
export function anyTrue(...input: Array<any>): boolean


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function allType(targetType: RambdaTypes): (...input: Array<any>) => boolean
export function anyType(targetType: RambdaTypes): (...input: Array<any>) => boolean


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function change<T>(
  origin: object, 
  path: string, 
  changeData: any
): T

export function change<Input, Output>(
  origin: Input, 
  path: string, 
  changeData: any
): Output


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function compact<T>(x: any[]): T[]


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function composeAsync<Out>(
  ...fns: Array<Async<any> | Func<any>>
): (input: any) => Promise<Out>
export function pipeAsync<Out>(
  ...fns: Array<Async<any> | Func<any>>
): (input: any) => Promise<Out>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function count<T>(target: T, list: any[]): number
export function count<T>(target: T) : (list: any[]) => number

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function debounce<T>(fn: T, ms: number): ReplaceReturnType<T, void>


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function defaultToStrict<T>(
  fallback: T, 
  ...inputs: Array<T>
): T


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function  delay(ms: number): Promise<'RAMBDAX_DELAY'>

//  export const DELAY: 'RAMBDAX_DELAY'


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function glue(input: string, glueString?: string): string


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function getter<T>(keyOrKeys: string|string[]|undefined): T


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function setter(keyOrobject: string|object, value?: any): void

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function reset(): void


/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function hasPath<T>(
  path: string|string[], 
  input: object
): boolean  
export function hasPath<T>(
  path: string|string[]
) : (input: object) => boolean

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER   
export function ifElseAsync<T>(
  condition: Async<any> | Func<any>,
  ifFn: Async<any> | Func<any>,
  elseFn: Async<any> | Func<any>
): Async<T>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function includesType(
  targetType: RambdaTypes, 
): (list: any[]) => boolean
export function includesType(
  targetType: RambdaTypes, 
  list: any[]
): boolean

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function isFalsy(input: any): boolean
export function isType(targetType: RambdaTypes, input: any): boolean

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function isPromise(
  maybePromiseOrAsync: any
): boolean

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function isFunction(
  maybePromiseFunctionOrAsync: any
): boolean
   
/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function maybe<T>(ifRule: any, whenIf: any, whenElse: any, maybeInput?: any): T

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function filterAsync<T>(fn: (x: T) => Promise<boolean>, list: T[]): Promise<Array<T>>
export function filterAsync<T>(fn: (x: T) => Promise<boolean>, obj: object): Promise<{
  [prop: string]: T
}>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function mapAsync<T>(fn: AsyncWithMap<any>, list: any[]): Promise<Array<T>>
export function mapAsync<T>(fn: AsyncWithProp<any>, obj: object): Promise<Array<T>>
export function mapAsync<T>(fn: AsyncWithMap<any>): (list: any[]) => Promise<Array<T>>
export function mapAsync<T>(fn: AsyncWithProp<any>): (obj: object) => Promise<Array<T>>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function mapFastAsync<T>(fn: AsyncWithMap<any>, list: any[]): Promise<Array<T>>
export function mapFastAsync<T>(fn: AsyncWithProp<any>, obj: object): Promise<Array<T>>
export function mapFastAsync<T>(fn: AsyncWithMap<any>): (list: any[]) => Promise<Array<T>>
export function mapFastAsync<T>(fn: AsyncWithProp<any>): (obj: object) => Promise<Array<T>>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function mapAsyncLimit<T, U>(iterable: (x: T) => Promise<U>, limit: number, list: Array<T>): Promise<Array<U>>
export function mapAsyncLimit<T, U>(iterable: (x: T) => Promise<U>, limit: number) : ( list: Array<T>) => Promise<Array<U>>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function mapToObject<T, U>(fn: (input: T) => object, list: T[]): U  
export function mapToObject<T, U>(fn: (input: T) => object): (list: T[]) => U  

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function memoize<T>(fn: Func<any> | Async<any>): T

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function mergeRight(x: object, y: object): object
export function mergeRight(x: object): (y: object) => object
   
/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function mergeAll(input: object[]): object
export function mergeDeep<T>(slave: object, master: object): T

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function nextIndex(index: number, list: any[]): number
export function nextIndex(index: number, list: number): number

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function prevIndex(index: number, list: any[]): number
export function prevIndex(index: number, list: number): number

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function ok(...inputs: any[]): (...rules: any[]) => true | never 

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function pass(...inputs: any[]): (...rules: any[]) => boolean 

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function isValid(x: IsValid): boolean

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER 
export function isValidAsync(x: IsValidAsync): Promise<boolean> 

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function once(fn: Func<any>): Func<any>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function partition<T>(
  rule: PartitionPredicate<T>,
  input: {[key: string]: T}
): [object, object]
export function partition<T>(
  rule: PartitionPredicate<T>
): (input: {[key: string]: T}) => [object, object]

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function partition<T>(
  rule: Predicatex<T>,
  input: Array<T>
): [Array<T>, Array<T>]
export function partition<T>(
  rule: Predicatex<T>
): (input: Array<T>) => [Array<T>, Array<T>]

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function pathEq(path:string|string[], target: any, obj: object): boolean
export function pathEq(path:string|string[], target: any): (obj: object) => boolean

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function piped<T>(input: any, ...fnList: Array<Func<any>>): T

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function pipedAsync<T>(
  input: any, 
  ...fns: Array< Func<any> | Async<any> >
): Promise<T>  

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function produce<T>(
  conditions: any,
  input: any
): T
export function produce<T>(
  conditions: any,
): (input: any) => T

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function promiseAllObject<T>(
  input: ObjectWithPromises
): Promise<T>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function random(minInclusive: number, maxInclusive: number): number

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function remove(
  inputs: string|RegExp|Array<string|RegExp>,
  text: string
): string
export function remove(
  inputs: string|RegExp|Array<string|RegExp>
): (text: string) => string

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function renameProps(fromKeyToProp: object, input: object): object
export function renameProps(fromKeyToProp: object): (input: object) => object

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function s(): boolean

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function shuffle<T>(arr: T[]): T[]

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function sortObject<T>(predicate: SortObjectPredicate<T>, obj: { [key: string]: T}): { [keyOutput: string]: T}
export function sortObject<T>(predicate: SortObjectPredicate<T>): (obj : { [key: string] : T }) => { [keyOutput: string] : T }

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function switcher<T>(valueToMatch: any): Switchem<T>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function tapAsync<T>(fn: Func<any> | Promise<any>, input: T): T
export function tapAsync<T>(fn: Func<any> | Promise<any>): (input: T) => T

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function throttle<T>(fn: T, ms: number): ReplaceReturnType<T, void>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER   
export function toDecimal(num: number, charsAfterDecimalPoint?: number): number    

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER   
export function template(inputWithTags: string, templateArguments: object): string
export function template(inputWithTags: string): (templateArguments: object) => string

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function tryCatch<T>(
  fn:  any, 
  fallback: any
): Async<T> | T

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER   
export function where(conditions: object, input: object): boolean

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function wait<T>(fn: Async<T>): Promise<[T, Error]>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function waitFor(
  waitForTrueCondition: () => any|Promise<any>, 
  msHowLong: number
): (input?: any) => Promise<boolean>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function when<T>(
  rule: Func<boolean> | boolean, ruleTrue: any
): IdentityFunction<T>
export function when<T>(
  rule: Func<boolean> | boolean
): (ruleTrue: any) => IdentityFunction<T>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER   
export function unless<T>(
  rule: Func<boolean> | boolean, ruleFalse: any
): IdentityFunction<T>
export function unless<T>(
  ruleFalse: Func<boolean> | boolean
): (ruleTrue: any) => IdentityFunction<T>

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function randomString(length?: number, alphabetOnlyFlag?: boolean): string",
  },
  "allPass": Object {
    "typing": "allPass<T>(predicates: Array<(x: T) => boolean>): (input: T) => boolean",
  },
  "always": Object {
    "typing": "always<T>(x: T): () => T",
  },
  "and": Object {
    "typing": "and<T extends { and?: ((...a: readonly any[]) => any)",
  },
  "any": Object {
    "typing": "any<T>(fn: (x: T, i: number) => boolean, arr: ReadonlyArray<T>): boolean",
  },
  "anyPass": Object {
    "typing": "anyPass<T>(preds: ReadonlyArray<SafePred<T>>): SafePred<T>",
  },
  "append": Object {
    "typing": "append<T>(el: T, list: ReadonlyArray<T>): T[]",
  },
  "applySpec": Object {
    "typing": "applySpec<Obj extends Record<string, (...args: readonly any[]) => any>>(
      obj: Obj
    ): (
        ...args: Parameters<ValueOfRecord<Obj>>
    ) => { [Key in keyof Obj]: ReturnType<Obj[Key]> }",
  },
  "assoc": Object {
    "typing": "assoc<T, U, K extends string>(prop: K, value: T, obj: U): Record<K, T> & U",
  },
  "assocPath": Object {
    "typing": "assocPath<T, U>(path: Path, val: T, obj: U): U",
  },
  "both": Object {
    "typing": "both(pred1: Pred, pred2: Pred): Pred",
  },
  "clamp": Object {
    "typing": "clamp(min: number, max: number, input: number): number",
  },
  "clone": Object {
    "typing": "clone<T>(value: T): T",
  },
  "complement": Object {
    "typing": "complement(pred: (...args: any[]) => boolean): (...args: any[]) => boolean",
  },
  "compose": Object {
    "typing": "compose<T1>(fn0: () => T1): () => T1",
  },
  "concat": Object {
    "typing": "concat<T>(x: ReadonlyArray<T>, y: ReadonlyArray<T>): T[]",
  },
  "cond": Object {
    "typing": "cond(fns: Array<[Pred, (...a: readonly any[]) => any]>): (...a: readonly any[]) => any",
  },
  "curry": Object {
    "typing": "curry<F extends (...args: any) => any>(f: F): FToolbelt.Curry<F>",
  },
  "dec": Object {
    "typing": "dec(n: number): number",
  },
  "defaultTo": Object {
    "typing": "defaultTo<T>(defaultValue: T): (...inputArguments: Array<T | null | undefined>) => T",
  },
  "difference": Object {
    "typing": "difference<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]",
  },
  "dissoc": Object {
    "typing": "dissoc<T>(prop: string, obj: any): T",
  },
  "divide": Object {
    "typing": "divide(a: number, b: number): number",
  },
  "drop": Object {
    "typing": "drop<T>(howManyToDrop: number, arrOrStr: ReadonlyArray<T>): T[]",
  },
  "dropLast": Object {
    "typing": "dropLast<T>(howManyToDrop: number, arrOrStr: ReadonlyArray<T>): T[]",
  },
  "either": Object {
    "typing": "either(pred1: Pred, pred2: Pred): Pred",
  },
  "endsWith": Object {
    "typing": "endsWith(a: string, list: string): boolean",
  },
  "equals": Object {
    "typing": "equals<T>(a: T, b: T): boolean",
  },
  "filter": Object {
    "typing": "filter<T>(filterFn: FilterFunctionArray<T>): (x: T[]) => T[]",
  },
  "find": Object {
    "typing": "find<T>(findFn: (a: T) => boolean, arr: ReadonlyArray<T>): T | undefined",
  },
  "findIndex": Object {
    "typing": "findIndex<T>(findFn: (a: T) => boolean, arr: ReadonlyArray<T>): number",
  },
  "findLast": Object {
    "typing": "findLast<T>(fn: (a: T) => boolean, list: T[]): T | undefined",
  },
  "findLastIndex": Object {
    "typing": "findLastIndex<T>(fn: (a: T) => boolean, list: T[]): number",
  },
  "flatten": Object {
    "typing": "flatten<T>(x: ReadonlyArray<T> | ReadonlyArray<T[]> | ReadonlyArray<ReadonlyArray<T>>): T[]",
  },
  "flip": Object {
    "typing": "flip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult",
  },
  "forEach": Object {
    "typing": "forEach<T>(fn: (x: T) => void, list: T[]): T[]",
  },
  "fromPairs": Object {
    "typing": "fromPairs<V>(pairs: Array<KeyValuePair<string, V>>): { [index: string]: V }",
  },
  "groupBy": Object {
    "typing": "groupBy<T>(fn: (a: T) => string, list: ReadonlyArray<T>): { [index: string]: T[] }",
  },
  "groupWith": Object {
    "typing": "groupWith<T>(fn: (x: T, y: T) => boolean): (list: ReadonlyArray<T>) => T[][]",
  },
  "has": Object {
    "typing": "has<T>(prop: string, obj: T): boolean",
  },
  "head": Object {
    "typing": "head<T>(arrOrStr: Array<T>): T | undefined",
  },
  "identical": Object {
    "typing": "identical<T>(a: T, b: T): boolean",
  },
  "identity": Object {
    "typing": "identity<T>(x: T): T",
  },
  "ifElse": Object {
    "typing": "ifElse(fn: Pred, onTrue: Arity1Fn, onFalse: Arity1Fn): Arity1Fn",
  },
  "inc": Object {
    "typing": "inc(n: number): number",
  },
  "includes": Object {
    "typing": "includes(valueToFind: string, input: ReadonlyArray<string> | string): boolean",
  },
  "indexBy": Object {
    "typing": "indexBy<T>(condition: (a: T) => string, arr: ReadonlyArray<T>): { [key: string]: T }",
  },
  "indexOf": Object {
    "typing": "indexOf<T>(target: T, arr: ReadonlyArray<T>): number",
  },
  "init": Object {
    "typing": "init<T>(arrOrStr: ReadonlyArray<T>): T[]",
  },
  "intersection": Object {
    "typing": "intersection<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]",
  },
  "intersperse": Object {
    "typing": "intersperse<T>(separator: T, list: ReadonlyArray<T>): T[]",
  },
  "is": Object {
    "typing": "is(xPrototype: any, x: any): boolean",
  },
  "isEmpty": Object {
    "typing": "isEmpty<T>(input: T): boolean",
  },
  "isNil": Object {
    "typing": "isNil(x: any): x is null | undefined",
  },
  "join": Object {
    "typing": "join(x: string, xs: ReadonlyArray<any>): string",
  },
  "keys": Object {
    "typing": "keys<T extends object>(x: T): Array<keyof T>",
  },
  "last": Object {
    "typing": "last<T>(arrOrStr: Array<T>): T | undefined",
  },
  "lastIndexOf": Object {
    "typing": "lastIndexOf<T>(x: T, arr: ReadonlyArray<T>): number",
  },
  "length": Object {
    "typing": "length<T>(list: ReadonlyArray<T>): number",
  },
  "lens": Object {
    "typing": "lens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens",
  },
  "lensIndex": Object {
    "typing": "lensIndex(n: number): Lens",
  },
  "lensProp": Object {
    "typing": "lensProp(str: string): {
  <T, U>(obj: T): U",
  },
  "map": Object {
    "typing": "map<T, U>(mapFn: MapFunctionObject<T, U>, x: Dictionary<T>): Dictionary<U>",
  },
  "match": Object {
    "typing": "match(regexp: RegExp, str: string): any[]",
  },
  "max": Object {
    "typing": "max<T extends Ord>(a: T, b: T): T",
  },
  "maxBy": Object {
    "typing": "maxBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T",
  },
  "mean": Object {
    "typing": "mean(list: ReadonlyArray<number>): number",
  },
  "median": Object {
    "typing": "median(list: ReadonlyArray<number>): number",
  },
  "merge": Object {
    "typing": "merge<T1, T2>(a: T1, b: T2): Merge<T2, T1>",
  },
  "min": Object {
    "typing": "min<T extends Ord>(a: T, b: T): T",
  },
  "minBy": Object {
    "typing": "minBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T",
  },
  "modulo": Object {
    "typing": "modulo(a: number, b: number): number",
  },
  "multiply": Object {
    "typing": "multiply(a: number, b: number): number",
  },
  "negate": Object {
    "typing": "negate(a: number): number",
  },
  "none": Object {
    "typing": "none<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): boolean",
  },
  "not": Object {
    "typing": "not(x: any): boolean",
  },
  "nth": Object {
    "typing": "nth<T>(n: number, list: ReadonlyArray<T>): T | undefined",
  },
  "omit": Object {
    "typing": "omit<T>(propsToOmit: string | string[], obj: Dictionary<T>): Dictionary<T>",
  },
  "over": Object {
    "typing": "over<T>(lens: Lens, fn: Arity1Fn, value: T): T",
  },
  "partial": Object {
    "typing": "partial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, x0: V0): (x1: V1) => T",
  },
  "path": Object {
    "typing": "path<Input, T>(pathToSearch: string | string[], obj: Input): T | undefined",
  },
  "pathOr": Object {
    "typing": "pathOr<T>(defaultValue: T, pathToSearch: Path, obj: any): T",
  },
  "paths": Object {
    "typing": "paths<Input, T>(pathsToSearch: Array<string | string[]>, obj: Input): Array<T | undefined>",
  },
  "pick": Object {
    "typing": "pick<T>(propsToPick: string | string[], obj: Dictionary<T>): Dictionary<T>",
  },
  "pickAll": Object {
    "typing": "pickAll<T, U>(names: ReadonlyArray<string>, obj: T): U",
  },
  "pipe": Object {
    "typing": "pipe<T1>(fn0: () => T1): () => T1",
  },
  "pluck": Object {
    "typing": "pluck<T>(property: number, arr: ReadonlyArray<T>): T",
  },
  "prepend": Object {
    "typing": "prepend<T>(x: T, arr: ReadonlyArray<T>): T[]",
  },
  "product": Object {
    "typing": "product(list: ReadonlyArray<number>): number",
  },
  "prop": Object {
    "typing": "prop<P extends keyof T, T>(propToFind: P, obj: T): T[P]",
  },
  "propEq": Object {
    "typing": "propEq<T>(propToFind: string | number, valueToMatch: T, obj: any): boolean",
  },
  "propIs": Object {
    "typing": "propIs<P extends keyof T, T>(type: any, name: P, obj: T): boolean",
  },
  "propOr": Object {
    "typing": "propOr<T, U, V>(val: T, p: string, obj: U): V",
  },
  "range": Object {
    "typing": "range(start: number, end: number): number[]",
  },
  "reduce": Object {
    "typing": "reduce<T, TResult>(fn: (acc: TResult, elem: T, i: number) => TResult, acc: TResult, list: ReadonlyArray<T>): TResult",
  },
  "reject": Object {
    "typing": "reject<T>(filterFn: FilterFunctionArray<T>): (x: T[]) => T[]",
  },
  "repeat": Object {
    "typing": "repeat<T>(a: T, n: number): T[]",
  },
  "replace": Object {
    "typing": "replace(strOrRegex: RegExp | string, replacer: string, str: string): string",
  },
  "reverse": Object {
    "typing": "reverse<T>(list: ReadonlyArray<T>): T[]",
  },
  "set": Object {
    "typing": "set<T, U>(lens: Lens, a: U, obj: T): T",
  },
  "slice": Object {
    "typing": "slice(a: number, b: number, list: string): string",
  },
  "sort": Object {
    "typing": "sort<T>(sortFn: (a: T, b: T) => number, arr: ReadonlyArray<T>): T[]",
  },
  "sortBy": Object {
    "typing": "sortBy<T>(sortFn: (a: T) => Ord, arr: ReadonlyArray<T>): T[]",
  },
  "split": Object {
    "typing": "split(sep: string | RegExp): (str: string) => string[]",
  },
  "splitEvery": Object {
    "typing": "splitEvery<T>(a: number, list: ReadonlyArray<T>): T[][]",
  },
  "startsWith": Object {
    "typing": "startsWith(a: string, list: string): boolean",
  },
  "subtract": Object {
    "typing": "subtract(a: number, b: number): number",
  },
  "sum": Object {
    "typing": "sum(list: ReadonlyArray<number>): number",
  },
  "symmetricDifference": Object {
    "typing": "symmetricDifference<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]",
  },
  "tail": Object {
    "typing": "tail<T>(arrOrStr: ReadonlyArray<T>): T[]",
  },
  "take": Object {
    "typing": "take<T>(num: number, arrOrStr: ReadonlyArray<T>): T[]",
  },
  "takeLast": Object {
    "typing": "takeLast<T>(num: number, arrOrStr: ReadonlyArray<T>): T[]",
  },
  "tap": Object {
    "typing": "tap<T>(fn: (a: T) => any, value: T): T",
  },
  "test": Object {
    "typing": "test(regExpression: RegExp): (str: string) => boolean",
  },
  "times": Object {
    "typing": "times<T>(fn: (i: number) => T, n: number): T[]",
  },
  "toLower": Object {
    "typing": "toLower(str: string): string",
  },
  "toPairs": Object {
    "typing": "toPairs<S>(obj: { [k: string]: S } | { [k: number]: S }): Array<[string, S]>",
  },
  "toString": Object {
    "examples": [Function],
    "explanations": [Function],
    "typing": "toString<T>(val: T): string",
  },
  "toUpper": Object {
    "typing": "toUpper(str: string): string",
  },
  "transpose": Object {
    "typing": "transpose<T>(list: T[][]): T[][]",
  },
  "trim": Object {
    "typing": "trim(str: string): string",
  },
  "type": Object {
    "typing": "type(val: any): \\"Object\\" | \\"Number\\" | \\"Boolean\\" | \\"String\\" | \\"Null\\" | \\"Array\\" | \\"Function\\" | \\"Undefined\\" | \\"Async\\" | \\"Promise\\" | \\"RegExp\\" | \\"NaN\\"",
  },
  "uniq": Object {
    "typing": "uniq<T>(arr: ReadonlyArray<T>): T[]",
  },
  "uniqWith": Object {
    "typing": "uniqWith<T, U>(fn: (x: T, y: T) => boolean, arr: ReadonlyArray<T>): T[]",
  },
  "update": Object {
    "typing": "update<T>(index: number, value: T, list: ReadonlyArray<T>): T[]",
  },
  "values": Object {
    "typing": "values<T extends object, K extends keyof T>(obj: T): Array<T[K]>",
  },
  "view": Object {
    "typing": "view<T, U>(lens: Lens): (obj: T) => U",
  },
  "whereEq": Object {
    "typing": "whereEq(rule: object, input: any): boolean  
export function whereEq(rule: object) : (input: any) => boolean  

// RAMBDAX_MARKER_END
// ============================================

export as namespace R",
  },
  "without": Object {
    "typing": "without<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]",
  },
  "xor": Object {
    "typing": "xor(a: boolean, b:boolean): boolean
export function xor(a: boolean): (b:boolean) => boolean

/*
Method: 

Explanation:



Example:

\`\`\`

\`\`\`

Categories:

*/
// @SINGLE_MARKER
export function zip<K, V>(list1: ReadonlyArray<K>, list2: ReadonlyArray<V>): Array<KeyValuePair<K, V>>",
  },
  "zipObj": Object {
    "typing": "zipObj<T>(keys: ReadonlyArray<string>, values: ReadonlyArray<T>): { [index: string]: T }",
  },
}
`;
