{
  "add": {
    "typing": "add(a: number, b: number): number",
    "allTypings": "add(a: number, b: number): number;\nadd(a: number): (b: number) => number;",
    "notes": "It doesn't work with strings, as the inputs are parsed to numbers before calculation.",
    "rambdaSource": "export function add(a, b){\n  if (arguments.length === 1) return _b => add(a, _b)\n\n  return Number(a) + Number(b)\n}",
    "rambdaSpecs": "import { add } from './add'\n\ntest('with number', () => {\n  expect(add(2, 3)).toEqual(5)\n  expect(add(7)(10)).toEqual(17)\n})\n\ntest('string is bad input', () => {\n  expect(add('foo', 'bar')).toBeNaN()\n})\n\ntest('ramda specs', () => {\n  expect(add('1', '2')).toEqual(3)\n  expect(add(1, '2')).toEqual(3)\n  expect(add(true, false)).toEqual(1)\n  expect(add(null, null)).toEqual(0)\n  expect(add(undefined, undefined)).toEqual(NaN)\n  expect(add(new Date(1), new Date(2))).toEqual(3)\n})",
    "explanation": "It adds `a` and `b`.",
    "example": "R.add(2, 3) // =>  5",
    "typescriptDefinitionTest": "import {add} from 'rambda'\n\ndescribe('add', () => {\n  it('number', () => {\n    const result = [\n      add(4)(1),\n      add(4,1)\n    ]  \n    result[0] // $ExpectType number\n    result[1] // $ExpectType number\n  })\n})"
  },
  "adjust": {
    "typing": "adjust<T>(index: number, replaceFn: (a: T) => T, list: ReadonlyArray<T>): T[]",
    "allTypings": "adjust<T>(index: number, replaceFn: (a: T) => T, list: ReadonlyArray<T>): T[];\nadjust<T>(index: number, replaceFn: (a: T) => T): (list: ReadonlyArray<T>) => T[];",
    "rambdaSource": "import { curry } from './curry'\n\nfunction adjustFn(\n  index, replaceFn, list\n){\n  const actualIndex = index < 0 ? list.length + index : index\n  if (index >= list.length || actualIndex < 0) return list\n\n  const clone = list.slice()\n  clone[ actualIndex ] = replaceFn(clone[ actualIndex ])\n\n  return clone\n}\n\nexport const adjust = curry(adjustFn)",
    "rambdaSpecs": "import { add } from './add'\nimport { adjust } from './adjust'\n\nconst expected = [ 0, 11, 2 ]\n\ntest('without curring', () => {\n  expect(adjust(\n    1, add(10), [ 0, 1, 2 ]\n  )).toEqual(expected)\n})\n\ntest('with curring type 1 1 1', () => {\n  expect(adjust(1)(add(10))([ 0, 1, 2 ])).toEqual(expected)\n})\n\ntest('with curring type 1 2', () => {\n  expect(adjust(1)(add(10), [ 0, 1, 2 ])).toEqual(expected)\n})\n\ntest('with curring type 2 1', () => {\n  expect(adjust(1, add(10))([ 0, 1, 2 ])).toEqual(expected)\n})\n\ntest('with negative index', () => {\n  expect(adjust(\n    -2, add(10), [ 0, 1, 2 ]\n  )).toEqual(expected)\n})\n\ntest('when index is out of bounds', () => {\n  const list = [ 0, 1, 2, 3 ]\n  expect(adjust(\n    4, add(1), list\n  )).toEqual(list)\n  expect(adjust(\n    -5, add(1), list\n  )).toEqual(list)\n})",
    "explanation": "It replaces `index` in array `list` with the result of `replaceFn(list[i])`.",
    "example": "R.adjust(\n  0,\n  a => a + 1,\n  [0, 100]\n) // => [1, 100]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('adjust', function() {\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.adjust(2, R.add(1), args(0, 1, 2, 3)), [0, 1, 3, 3]);\n  });\n});",
    "failedSpecsReasons": "ramda accepts an array-like object",
    "failedSpecsCount": 1
  },
  "all": {
    "typing": "all<T>(predicate: (x: T) => boolean, list: ReadonlyArray<T>): boolean",
    "allTypings": "all<T>(predicate: (x: T) => boolean, list: ReadonlyArray<T>): boolean;\nall<T>(predicate: (x: T) => boolean): (list: ReadonlyArray<T>) => boolean;",
    "rambdaSource": "export function all(predicate, list){\n  if (arguments.length === 1) return _list => all(predicate, _list)\n\n  for (let i = 0; i < list.length; i++){\n    if (!predicate(list[ i ], i)) return false\n  }\n\n  return true\n}",
    "rambdaSpecs": "import { all } from './all'\n\nconst numArr = [ 0, 1, 2, 3, 4 ]\n\ntest('when true', () => {\n  const fn = x => x > -1\n\n  expect(all(fn)(numArr)).toBeTrue()\n})\n\ntest('when false', () => {\n  const fn = x => x > 2\n\n  expect(all(fn, numArr)).toBeFalse()\n})\n\ntest('pass index as second argument', () => {\n  const indexes = []\n  const fn = (x, i) => {\n    indexes.push(i)\n\n    return x > 5\n  }\n  all(fn, [ 10, 12, 14 ])\n\n  expect(indexes).toEqual([ 0, 1, 2 ])\n})",
    "explanation": "It returns `true`, if all members of array `list` returns `true`, when applied as argument to `predicate` function.",
    "example": "const list = [ 0, 1, 2, 3, 4 ]\nconst predicate = x => x > -1\n\nconst result = R.all(predicate, arr)\n// => true",
    "typescriptDefinitionTest": "import {all} from 'rambda'\n\ndescribe('all', () => {\n  it('happy', () => {\n    const x = all<number>(y => {\n      y // $ExpectType number\n      return y > 0\n    })([1, 2, 3])\n    x // $ExpectType boolean\n\n    const q = all(y => y > 0, [1, 2, 3]) // $ExpectType boolean\n\n    q // $ExpectType boolean\n  })\n})"
  },
  "allPass": {
    "typing": "allPass<T>(predicates: ((x: T) => boolean)[]): (input: T) => boolean",
    "allTypings": "allPass<T>(predicates: ((x: T) => boolean)[]): (input: T) => boolean;",
    "rambdaSource": "export function allPass(predicates){\n  return input => {\n    let counter = 0\n    while (counter < predicates.length){\n      if (!predicates[ counter ](input)){\n        return false\n      }\n      counter++\n    }\n\n    return true\n  }\n}",
    "rambdaSpecs": "import { allPass } from './allPass'\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'number', x => x > 10, x => x * 7 < 100 ]\n\n  expect(allPass(rules)(11)).toBeTrue()\n\n  expect(allPass(rules)(undefined)).toBeFalse()\n})\n\ntest('when returns true', () => {\n  const conditionArr = [ val => val.a === 1, val => val.b === 2 ]\n\n  expect(allPass(conditionArr)({\n    a : 1,\n    b : 2,\n  })).toBeTrue()\n})\n\ntest('when returns false', () => {\n  const conditionArr = [ val => val.a === 1, val => val.b === 3 ]\n\n  expect(allPass(conditionArr)({\n    a : 1,\n    b : 2,\n  })).toBeFalse()\n})",
    "explanation": "It returns `true`, if all functions of `predicates` return `true`, when `input` is their argument.",
    "example": "const input = {\n  a : 1,\n  b : 2,\n}\nconst predicates = [\n  x => x.a === 1,\n  x => x.b === 2,\n]\nconst result = R.allPass(predicates)(input) // => true",
    "typescriptDefinitionTest": "import {allPass} from 'rambda'\n\ndescribe('allPass', () => {\n  it('happy', () => {\n    const x = allPass<number>([\n      y => {\n        y // $ExpectType number\n        return typeof y === 'number'\n      },\n      y => {\n        return y > 0\n      },\n    ])(11)\n\n    x // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('allPass', function() {\n  var odd = function(n) { return n % 2 !== 0; };\n  var lt20 = function(n) { return n < 20; };\n  var gt5 = function(n) { return n > 5; };\n  var plusEq = function(w, x, y, z) { return w + x === y + z; };\n  it('returns a curried function whose arity matches that of the highest-arity predicate', function() {\n    eq(R.allPass([odd, gt5, plusEq]).length, 4);\n    eq(R.allPass([odd, gt5, plusEq])(9, 9, 9, 9), true);\n    eq(R.allPass([odd, gt5, plusEq])(9)(9)(9)(9), true);\n  });\n});",
    "failedSpecsReasons": "ramda returns a curried function whose arity matches that of the highest-arity predicate",
    "failedSpecsCount": 1
  },
  "always": {
    "typing": "always<T>(x: T): () => T",
    "allTypings": "always<T>(x: T): () => T;",
    "rambdaSource": "export function always(x){\n  return () => x\n}",
    "rambdaSpecs": "import { always } from './always'\n\ntest('happy', () => {\n  const fn = always(7)\n\n  expect(fn()).toEqual(7)\n  expect(fn()).toEqual(7)\n})",
    "explanation": "It returns function that always returns `x`.",
    "example": "const fn = R.always(7)\n\nconsole.log(fn())// => 7"
  },
  "and": {
    "typing": "and<T extends { and?: ((...a: readonly any[]) => any)",
    "allTypings": "and<T extends { and?: ((...a: readonly any[]) => any); } | number | boolean | string | null>(fn1: T, val2: any): boolean;\nand<T extends { and?: ((...a: readonly any[]) => any); } | number | boolean | string | null>(fn1: T): (val2: any) => boolean;",
    "rambdaSource": "export function and(a, b){\n  if (arguments.length === 1) return _b => and(a, _b)\n\n  return a && b\n}",
    "rambdaSpecs": "import { and } from './and'\n\ntest('happy', () => {\n  expect(and(true, true)).toBe(true)\n  expect(and(true, false)).toBe(false)\n  expect(and(false, true)).toBe(false)\n  expect(and(false, false)).toBe(false)\n})",
    "explanation": "Returns `true` if both arguments are `true`. Otherwise, it returns `false`.",
    "example": "R.and(true, true); // => true\nR.and(false, true); // => false"
  },
  "any": {
    "typing": "any<T>(predicate: (x: T, i: number) => boolean, list: ReadonlyArray<T>): boolean",
    "allTypings": "any<T>(predicate: (x: T, i: number) => boolean, list: ReadonlyArray<T>): boolean;\nany<T>(predicate: (x: T) => boolean, list: ReadonlyArray<T>): boolean;\nany<T>(predicate: (x: T, i: number) => boolean): (list: ReadonlyArray<T>) => boolean;\nany<T>(predicate: (x: T) => boolean): (list: ReadonlyArray<T>) => boolean;",
    "rambdaSource": "export function any(predicate, list){\n  if (arguments.length === 1) return _list => any(predicate, _list)\n\n  let counter = 0\n  while (counter < list.length){\n    if (predicate(list[ counter ], counter)){\n      return true\n    }\n    counter++\n  }\n\n  return false\n}",
    "rambdaSpecs": "import { any } from './any'\n\nconst arr = [ 1, 2 ]\n\ntest('no curry', () => {\n  expect(any(val => val < 0, arr)).toBeFalse()\n})\n\ntest('with curry', () => {\n  expect(any(val => val < 2)(arr)).toBeTrue()\n})\n\ntest('passes index to predicate', () => {\n  any((x, i) => {\n    expect(typeof x).toBe('string')\n    expect(typeof i).toBe('number')\n  })([ 'foo', 'bar' ])\n})",
    "explanation": "It returns `true`, if at least one member of `list` returns true, when passed to `predicate` function.",
    "example": "const list = [1, 2, 3]\nconst predicate = x => x * x > 8\nR.any(fn, list)\n// => true",
    "typescriptDefinitionTest": "import {any} from 'rambda'\n\ndescribe('any', () => {\n  it('1', () => {\n    const x = any<number>(\n      (y, i) => {\n        y // $ExpectType number\n        i // $ExpectType number\n        return y > 2\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType boolean\n  })\n  it('2', () => {\n    const x = any<number>(\n      y => {\n        y // $ExpectType number\n        return y > 2\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType boolean\n  })\n\n  it('1 curry', () => {\n    const x = any<number>((y, i) => {\n      y // $ExpectType number\n      i // $ExpectType number\n      return y > 2\n    })([1, 2, 3])\n    x // $ExpectType boolean\n  })\n  it('2 curry', () => {\n    const x = any<number>(y => {\n      y // $ExpectType number\n      return y > 2\n    })([1, 2, 3])\n    x // $ExpectType boolean\n  })\n})"
  },
  "anyPass": {
    "typing": "anyPass<T>(predicates: ReadonlyArray<SafePred<T>>): SafePred<T>",
    "allTypings": "anyPass<T>(predicates: ReadonlyArray<SafePred<T>>): SafePred<T>;",
    "rambdaSource": "export function anyPass(predicates){\n  return input => {\n    let counter = 0\n    while (counter < predicates.length){\n      if (predicates[ counter ](input)){\n        return true\n      }\n      counter++\n    }\n\n    return false\n  }\n}",
    "rambdaSpecs": "import { anyPass } from './anyPass'\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'string', x => x > 10 ]\n  const predicate = anyPass(rules)\n  expect(predicate('foo')).toBeTrue()\n  expect(predicate(6)).toBeFalse()\n})\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'string', x => x > 10 ]\n\n  expect(anyPass(rules)(11)).toBeTrue()\n\n  expect(anyPass(rules)(undefined)).toBeFalse()\n})\n\nconst obj = {\n  a : 1,\n  b : 2,\n}\n\ntest('when returns true', () => {\n  const conditionArr = [ val => val.a === 1, val => val.a === 2 ]\n\n  expect(anyPass(conditionArr)(obj)).toBeTrue()\n})\n\ntest('when returns false + curry', () => {\n  const conditionArr = [ val => val.a === 2, val => val.b === 3 ]\n\n  expect(anyPass(conditionArr)(obj)).toBeFalse()\n})\n\ntest('happy', () => {\n  expect(anyPass([])(3)).toEqual(false)\n})",
    "explanation": "It accepts list of `predicates` and returns a function. This function with its `input` will return `true`, if any of `predicates` returns `true` for this `input`.",
    "example": "const isBig = x => x > 20\nconst isOdd = x => x % 2 === 1\nconst input = 11\n\nconst fn = R.anyPass(\n  [isBig, isOdd]\n)\n\nconst result = fn(input) \n// => true",
    "typescriptDefinitionTest": "import {anyPass} from 'rambda'\n\ndescribe('anyPass', () => {\n  it('happy', () => {\n    const x = anyPass<number>([\n      y => {\n        y // $ExpectType number\n        return typeof y === 'number'\n      },\n      y => {\n        return y > 0\n      },\n    ])(11)\n\n    x // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('anyPass', function() {\n  var odd = function(n) { return n % 2 !== 0; };\n  var gt20 = function(n) { return n > 20; };\n  var lt5 = function(n) { return n < 5; };\n  var plusEq = function(w, x, y, z) { return w + x === y + z; };\n  it('returns a curried function whose arity matches that of the highest-arity predicate', function() {\n    eq(R.anyPass([odd, lt5, plusEq]).length, 4);\n    eq(R.anyPass([odd, lt5, plusEq])(6, 7, 8, 9), false);\n    eq(R.anyPass([odd, lt5, plusEq])(6)(7)(8)(9), false);\n  });\n});",
    "failedSpecsReasons": "ramda returns a curried function whose arity matches that of the highest-arity predicate",
    "failedSpecsCount": 1
  },
  "append": {
    "typing": "append<T>(x: T, listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "append<T>(x: T, listOrString: ReadonlyArray<T>): T[];\nappend<T>(x: T): <T>(listOrString: ReadonlyArray<T>) => T[];",
    "rambdaSource": "export function append(x, listOrString){\n  if (arguments.length === 1)\n    return _listOrString => append(x, _listOrString)\n\n  if (typeof listOrString === 'string') return `${ listOrString }${ x }`\n\n  const clone = listOrString.slice()\n  clone.push(x)\n\n  return clone\n}",
    "rambdaSpecs": "import { append } from './append'\nimport { compose } from './compose'\nimport { flatten } from './flatten'\nimport { map } from './map'\n\ntest('with strings', () => {\n  expect(append('o', 'fo')).toEqual('foo')\n})\n\ntest('with arrays', () => {\n  expect(append('tests', [ 'write', 'more' ])).toEqual([\n    'write',\n    'more',\n    'tests',\n  ])\n})\n\ntest('append to empty array', () => {\n  expect(append('tests', [])).toEqual([ 'tests' ])\n})\n\ntest('happy', () => {\n  const result = compose(flatten, map(append(0)))([ [ 1 ], [ 2 ], [ 3 ] ])\n  expect(result).toEqual([ 1, 0, 2, 0, 3, 0 ])\n})\n\ntest('should not modify arguments', () => {\n  const a = [ 1, 2, 3 ]\n  const b = append(4, a)\n\n  expect(a).toEqual([ 1, 2, 3 ])\n  expect(b).toEqual([ 1, 2, 3, 4 ])\n})",
    "explanation": "It adds element `x` at the end of `listOrString`.",
    "example": "const x = 'foo'\n\nconst result = [\n  R.append(x, 'cherry_'),\n  R.append(x, ['bar', 'baz'])\n]\n// => ['cherry_foo', ['bar', 'baz', 'foo']]"
  },
  "applySpec": {
    "typing": "applySpec<Spec extends Record<string, (...args: readonly any[]) => any>>(\n  spec: Spec\n): (\n  ...args: Parameters<ValueOfRecord<Spec>>\n) => { [Key in keyof Spec]: ReturnType<Spec[Key]> }",
    "allTypings": "applySpec<Spec extends Record<string, (...args: readonly any[]) => any>>(\n  spec: Spec\n): (\n  ...args: Parameters<ValueOfRecord<Spec>>\n) => { [Key in keyof Spec]: ReturnType<Spec[Key]> };\napplySpec<T>(spec: any): (...args: readonly any[]) => T;",
    "notes": "The currying in this function works best with functions with 4 arguments or less. (arity of 4)",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\n// recursively traverse the given spec object to find the highest arity function\nfunction __findHighestArity(spec, max = 0){\n  for (const key in spec){\n    if (spec.hasOwnProperty(key) === false || key === 'constructor') continue\n\n    if (typeof spec[ key ] === 'object'){\n      max = Math.max(max, __findHighestArity(spec[ key ]))\n    }\n\n    if (typeof spec[ key ] === 'function'){\n      max = Math.max(max, spec[ key ].length)\n    }\n  }\n\n  return max\n}\n\nfunction __filterUndefined(){\n  const defined = []\n  let i = 0\n  const l = arguments.length\n  while (i < l){\n    if (typeof arguments[ i ] === 'undefined') break\n    defined[ i ] = arguments[ i ]\n    i++\n  }\n\n  return defined\n}\n\nfunction __applySpecWithArity(\n  spec, arity, cache\n){\n  const remaining = arity - cache.length\n\n  if (remaining === 1)\n    return x =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(...cache, x)\n      )\n  if (remaining === 2)\n    return (x, y) =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(\n          ...cache, x, y\n        )\n      )\n  if (remaining === 3)\n    return (\n      x, y, z\n    ) =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(\n          ...cache, x, y, z\n        )\n      )\n  if (remaining === 4)\n    return (\n      x, y, z, a\n    ) =>\n      __applySpecWithArity(\n        spec,\n        arity,\n        __filterUndefined(\n          ...cache, x, y, z, a\n        )\n      )\n  if (remaining > 4)\n    return (...args) =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(...cache, ...args)\n      )\n\n  // handle spec as Array\n  if (_isArray(spec)){\n    const ret = []\n    let i = 0\n    const l = spec.length\n    for (; i < l; i++){\n      // handle recursive spec inside array\n      if (typeof spec[ i ] === 'object' || _isArray(spec[ i ])){\n        ret[ i ] = __applySpecWithArity(\n          spec[ i ], arity, cache\n        )\n      }\n      // apply spec to the key\n      if (typeof spec[ i ] === 'function'){\n        ret[ i ] = spec[ i ](...cache)\n      }\n    }\n\n    return ret\n  }\n\n  // handle spec as Object\n  const ret = {}\n  // apply callbacks to each property in the spec object\n  for (const key in spec){\n    if (spec.hasOwnProperty(key) === false || key === 'constructor') continue\n\n    // apply the spec recursively\n    if (typeof spec[ key ] === 'object'){\n      ret[ key ] = __applySpecWithArity(\n        spec[ key ], arity, cache\n      )\n      continue\n    }\n\n    // apply spec to the key\n    if (typeof spec[ key ] === 'function'){\n      ret[ key ] = spec[ key ](...cache)\n    }\n  }\n\n  return ret\n}\n\nexport function applySpec(spec, ...args){\n  // get the highest arity spec function, cache the result and pass to __applySpecWithArity\n  const arity = __findHighestArity(spec)\n\n  if (arity === 0){\n    return () => ({})\n  }\n  const toReturn = __applySpecWithArity(\n    spec, arity, args\n  )\n\n  return toReturn\n}",
    "rambdaSpecs": "import { applySpec as applySpecRamda, nAry } from 'ramda'\n\nimport { add, always, compose, dec, inc, map, path, prop, T } from '../rambda'\nimport { applySpec } from './applySpec'\n\ntest('different than Ramda when bad spec', () => {\n  const result = applySpec({ sum : { a : 1 } })(1, 2)\n  const ramdaResult = applySpecRamda({ sum : { a : 1 } })(1, 2)\n  expect(result).toEqual({})\n  expect(ramdaResult).toEqual({ sum : { a : {} } })\n})\n\ntest('works with empty spec', () => {\n  expect(applySpec({})()).toEqual({})\n  expect(applySpec([])(1, 2)).toEqual({})\n  expect(applySpec(null)(1, 2)).toEqual({})\n})\n\ntest('works with unary functions', () => {\n  const result = applySpec({\n    v : inc,\n    u : dec,\n  })(1)\n  const expected = {\n    v : 2,\n    u : 0,\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('works with binary functions', () => {\n  const result = applySpec({ sum : add })(1, 2)\n  expect(result).toEqual({ sum : 3 })\n})\n\ntest('works with nested specs', () => {\n  const result = applySpec({\n    unnested : always(0),\n    nested   : { sum : add },\n  })(1, 2)\n  const expected = {\n    unnested : 0,\n    nested   : { sum : 3 },\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('works with arrays of nested specs', () => {\n  const result = applySpec({\n    unnested : always(0),\n    nested   : [ { sum : add } ],\n  })(1, 2)\n\n  expect(result).toEqual({\n    unnested : 0,\n    nested   : [ { sum : 3 } ],\n  })\n})\n\ntest('works with arrays of spec objects', () => {\n  const result = applySpec([ { sum : add } ])(1, 2)\n\n  expect(result).toEqual([ { sum : 3 } ])\n})\n\ntest('works with arrays of functions', () => {\n  const result = applySpec([ map(prop('a')), map(prop('b')) ])([\n    {\n      a : 'a1',\n      b : 'b1',\n    },\n    {\n      a : 'a2',\n      b : 'b2',\n    },\n  ])\n  const expected = [\n    [ 'a1', 'a2' ],\n    [ 'b1', 'b2' ],\n  ]\n  expect(result).toEqual(expected)\n})\n\ntest('works with a spec defining a map key', () => {\n  expect(applySpec({ map : prop('a') })({ a : 1 })).toEqual({ map : 1 })\n})\n\ntest.skip('retains the highest arity', () => {\n  const f = applySpec({\n    f1 : nAry(2, T),\n    f2 : nAry(5, T),\n  })\n  expect(f.length).toBe(5)\n})\n\ntest('returns a curried function', () => {\n  expect(applySpec({ sum : add })(1)(2)).toEqual({ sum : 3 })\n})\n\n// Additional tests\n// ============================================\ntest('arity', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n  }\n  expect(applySpec(\n    spec, 1, 2, 3\n  )).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n  })\n})\n\ntest('arity over 5 arguments', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n    four : (\n      x1, x2, x3, x4\n    ) => x1 + x2 + x3 + x4,\n    five : (\n      x1, x2, x3, x4, x5\n    ) => x1 + x2 + x3 + x4 + x5,\n  }\n  expect(applySpec(\n    spec, 1, 2, 3, 4, 5\n  )).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n    four  : 10,\n    five  : 15,\n  })\n})\n\ntest('curried', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n  }\n  expect(applySpec(spec)(1)(2)(3)).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n  })\n})\n\ntest('curried over 5 arguments', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n    four : (\n      x1, x2, x3, x4\n    ) => x1 + x2 + x3 + x4,\n    five : (\n      x1, x2, x3, x4, x5\n    ) => x1 + x2 + x3 + x4 + x5,\n  }\n  expect(applySpec(spec)(1)(2)(3)(4)(5)).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n    four  : 10,\n    five  : 15,\n  })\n})\n\ntest('undefined property', () => {\n  const spec = { prop : path([ 'property', 'doesnt', 'exist' ]) }\n  expect(applySpec(spec, {})).toEqual({ prop : undefined })\n})\n\ntest('restructure json object', () => {\n  const spec = {\n    id          : path('user.id'),\n    name        : path('user.firstname'),\n    profile     : path('user.profile'),\n    doesntExist : path('user.profile.doesntExist'),\n    info        : { views : compose(inc, prop('views')) },\n    type        : always('playa'),\n  }\n\n  const data = {\n    user : {\n      id        : 1337,\n      firstname : 'john',\n      lastname  : 'shaft',\n      profile   : 'shaft69',\n    },\n    views : 42,\n  }\n\n  expect(applySpec(spec, data)).toEqual({\n    id          : 1337,\n    name        : 'john',\n    profile     : 'shaft69',\n    doesntExist : undefined,\n    info        : { views : 43 },\n    type        : 'playa',\n  })\n})",
    "explanation": "It returns a curried function with the same arity as the longest function in the spec object.\nArguments will be applied to the spec methods recursively.",
    "example": "const spec = {\n  name: R.path('deeply.nested.firstname')\n}\nconst json = {\n  deeply: {\n   nested: {\n      firstname: 'barry'\n    }\n  }\n}\nconst result = R.applySpec(spec, json) // => { name: 'barry' }\n\n// Second example\nconst getMetrics = R.applySpec({\n  sum: R.add,\n  nested: { mul: R.multiply }\n});\ngetMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }",
    "typescriptDefinitionTest": "import {multiply, applySpec, inc, dec, add} from 'rambda'\n\ndescribe('applySpec', () => {\n  it('ramda 1', () => {\n    const result = applySpec({\n      v: inc,\n      u: dec,\n    })(1)\n    result // $ExpectType { v: number; u: number; }\n  })\n  it('ramda 1', () => {\n    interface Output {\n      sum: number,\n      multiplied: number,\n    }\n    const result = applySpec<Output>({\n      sum: add,\n      multiplied: multiply,\n    })(1, 2)\n\n    result // $ExpectType Output\n  })\n})"
  },
  "assoc": {
    "typing": "assoc<T, U, K extends string>(prop: K, newValue: T, obj: U): Record<K, T> & U",
    "allTypings": "assoc<T, U, K extends string>(prop: K, newValue: T, obj: U): Record<K, T> & U;\nassoc<T, K extends string>(prop: K, newValue: T): <U>(obj: U) => Record<K, T> & U;\nassoc<K extends string>(prop: K): <T, U>(newValue: T, obj: U) => Record<K, T> & U;",
    "notes": "This copies and flattens prototype properties\nonto the new object as well. All non-primitive properties are copied by\nreference.",
    "rambdaSource": "import { curry } from './curry'\n\nfunction assocFn(\n  prop, newValue, obj\n){\n  return Object.assign(\n    {}, obj, { [ prop ] : newValue }\n  )\n}\n\nexport const assoc = curry(assocFn)",
    "rambdaSpecs": "import { assoc } from './assoc'\n\ntest('adds a key to an empty object', () => {\n  expect(assoc(\n    'a', 1, {}\n  )).toEqual({ a : 1 })\n})\n\ntest('adds a key to a non-empty object', () => {\n  expect(assoc(\n    'b', 2, { a : 1 }\n  )).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 1', () => {\n  expect(assoc('b', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 2', () => {\n  expect(assoc('b')(2, { a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 3', () => {\n  const result = assoc('b')(2)({ a : 1 })\n\n  expect(result).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('changes an existing key', () => {\n  expect(assoc(\n    'a', 2, { a : 1 }\n  )).toEqual({ a : 2 })\n})\n\ntest('undefined is considered an empty object', () => {\n  expect(assoc(\n    'a', 1, undefined\n  )).toEqual({ a : 1 })\n})\n\ntest('null is considered an empty object', () => {\n  expect(assoc(\n    'a', 1, null\n  )).toEqual({ a : 1 })\n})\n\ntest('value can be null', () => {\n  expect(assoc(\n    'a', null, null\n  )).toEqual({ a : null })\n})\n\ntest('value can be undefined', () => {\n  expect(assoc(\n    'a', undefined, null\n  )).toEqual({ a : undefined })\n})\n\ntest('assignment is shallow', () => {\n  expect(assoc(\n    'a', { b : 2 }, { a : { c : 3 } }\n  )).toEqual({ a : { b : 2 } })\n})",
    "explanation": "It makes a shallow clone of `obj` with setting or overriding the property `prop` with `newValue`.",
    "example": "R.assoc('c', 3, {a: 1, b: 2})\n//=> {a: 1, b: 2, c: 3}"
  },
  "assocPath": {
    "typing": "assocPath<T, U>(path: Path, newValue: T, obj: U): U",
    "allTypings": "assocPath<T, U>(path: Path, newValue: T, obj: U): U;\nassocPath<T, U>(path: Path, newValue: T): (obj: U) => U;\nassocPath<T, U>(path: Path): FunctionToolbelt.Curry<(a: T, b: U) => U>;",
    "notes": "Object",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { _isInteger } from './_internals/_isInteger'\nimport { assoc } from './assoc'\nimport { curry } from './curry'\n\nfunction assocPathFn(\n  list, newValue, input\n){\n  const pathArrValue = typeof list === 'string' ? list.split('.') : list\n  if (pathArrValue.length === 0){\n    return newValue\n  }\n\n  const index = pathArrValue[ 0 ]\n  if (pathArrValue.length > 1){\n    const condition =\n      typeof input !== 'object' ||\n      input === null ||\n      !input.hasOwnProperty(index)\n\n    const nextinput = condition ?\n      _isInteger(parseInt(pathArrValue[ 1 ], 10)) ?\n        [] :\n        {} :\n      input[ index ]\n    newValue = assocPathFn(\n      Array.prototype.slice.call(pathArrValue, 1),\n      newValue,\n      nextinput\n    )\n  }\n\n  if (_isInteger(parseInt(index, 10)) && _isArray(input)){\n    const arr = input.slice()\n    arr[ index ] = newValue\n\n    return arr\n  }\n\n  return assoc(\n    index, newValue, input\n  )\n}\n\nexport const assocPath = curry(assocPathFn)",
    "rambdaSpecs": "import { assocPath } from './assocPath'\n\ntest('adds a key to an empty object', () => {\n  expect(assocPath(\n    'a', 1, {}\n  )).toEqual({ a : 1 })\n})\n\ntest('adds a key to a non-empty object', () => {\n  expect(assocPath(\n    'b', 2, { a : 1 }\n  )).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a nested key to a non-empty object', () => {\n  expect(assocPath(\n    'b.c', 2, { a : 1 }\n  )).toEqual({\n    a : 1,\n    b : { c : 2 },\n  })\n})\n\ntest('adds a nested key to a nested non-empty object - curry case 1', () => {\n  expect(assocPath('b.d',\n    3)({\n    a : 1,\n    b : { c : 2 },\n  })).toEqual({\n    a : 1,\n    b : {\n      c : 2,\n      d : 3,\n    },\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 1', () => {\n  expect(assocPath('b', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a nested key to a non-empty object - curry case 1', () => {\n  expect(assocPath('b.c', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : { c : 2 },\n  })\n})\n\ntest('adds a nested array to a non-empty object - curry case 1', () => {\n  expect(assocPath('b.0', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : [ 2 ],\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 2', () => {\n  expect(assocPath('b')(2, { a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 3', () => {\n  const result = assocPath('b')(2)({ a : 1 })\n\n  expect(result).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('changes an existing key', () => {\n  expect(assocPath(\n    'a', 2, { a : 1 }\n  )).toEqual({ a : 2 })\n})\n\ntest('undefined is considered an empty object', () => {\n  expect(assocPath(\n    'a', 1, undefined\n  )).toEqual({ a : 1 })\n})\n\ntest('null is considered an empty object', () => {\n  expect(assocPath(\n    'a', 1, null\n  )).toEqual({ a : 1 })\n})\n\ntest('value can be null', () => {\n  expect(assocPath(\n    'a', null, null\n  )).toEqual({ a : null })\n})\n\ntest('value can be undefined', () => {\n  expect(assocPath(\n    'a', undefined, null\n  )).toEqual({ a : undefined })\n})\n\ntest('assignment is shallow', () => {\n  expect(assocPath(\n    'a', { b : 2 }, { a : { c : 3 } }\n  )).toEqual({ a : { b : 2 } })\n})\n\ntest('happy', () => {\n  const result = assocPath(\n    [], 3, {\n      a : 1,\n      b : 2,\n    }\n  )\n  expect(result).toEqual(3)\n})\n\ntest('happy', () => {\n  const expected = { foo : { bar : { baz : 42 } } }\n  const result = assocPath(\n    [ 'foo', 'bar', 'baz' ], 42, { foo : null }\n  )\n  expect(result).toEqual(expected)\n})",
    "explanation": "It makes a shallow clone of `obj` with setting or overriding with `newValue` the property found with `path`.",
    "example": "const path = 'b.c'\nconst newValue = 2\nconst obj = { a: 1 }\n\nR.assocPath(path, newValue, obj)\n// => { a : 1, b : { c : 2 }}"
  },
  "both": {
    "typing": "both(pred1: Pred, pred2: Pred): Pred",
    "allTypings": "both(pred1: Pred, pred2: Pred): Pred;\nboth<T>(pred1: Predicate<T>, pred2: Predicate<T>): Predicate<T>;\nboth<T>(pred1: Predicate<T>): (pred2: Predicate<T>) => Predicate<T>;\nboth(pred1: Pred): (pred2: Pred) => Pred;",
    "rambdaSource": "export function both(f, g){\n  if (arguments.length === 1) return _g => both(f, _g)\n\n  return (...input) => f(...input) && g(...input)\n}",
    "rambdaSpecs": "import { both } from './both'\n\nconst firstFn = val => val > 0\nconst secondFn = val => val < 10\n\ntest('with curry', () => {\n  expect(both(firstFn)(secondFn)(17)).toBeFalse()\n})\n\ntest('without curry', () => {\n  expect(both(firstFn, secondFn)(7)).toBeTrue()\n})\n\ntest('with multiple inputs', () => {\n  const between = function (\n    a, b, c\n  ){\n    return a < b && b < c\n  }\n  const total20 = function (\n    a, b, c\n  ){\n    return a + b + c === 20\n  }\n  const fn = both(between, total20)\n  expect(fn(\n    5, 7, 8\n  )).toBeTrue()\n})\n\ntest('skip evaluation of the second expression', () => {\n  let effect = 'not evaluated'\n  const F = function (){\n    return false\n  }\n  const Z = function (){\n    effect = 'Z got evaluated'\n  }\n  both(F, Z)()\n\n  expect(effect).toBe('not evaluated')\n})",
    "explanation": "It returns a function with `input` argument. \n\nThis function will return `true`, if both `firstCondition` and `secondCondition` return `true` when `input` is passed as their argument.",
    "example": "const firstCondition = x => x > 10\nconst secondCondition = x => x < 20\nconst fn = R.both(secondCondition)\n\nconst result = [fn(15), fn(30)]\n// => [true, false]",
    "typescriptDefinitionTest": "import {both} from 'rambda'\n\ndescribe('both', () => {\n  it('with passed type', () => {\n    const fn = both<number>( // $ExpectType Predicate<number>\n      x => {\n        return x > 1\n      },\n      x => {\n        return x % 2 === 0\n      }\n    )\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  })\n  it('no type passed', () => {\n    const fn = both(\n      x => {\n        x // $ExpectType any\n        return x > 1\n      },\n      x => {\n        return x % 2 === 0\n      }\n    )\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  })\n})\n\ndescribe('both + curry', () => {\n  it('with passed type', () => {\n    const fn = both<number>(x => {\n      return x > 1\n    })(x => {\n      return x % 2 === 0\n    })\n    fn // $ExpectType Predicate<number>\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  })\n  it('no type passed', () => {\n    const fn = both(x => {\n      x // $ExpectType unknown\n      return (x as number) > 1\n    })(x => {\n      return (x as number) % 2 === 0\n    })\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var S = require('sanctuary');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('both', function() {\n  it('accepts fantasy-land applicative functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.both(Just(true), Just(true)), Just(true));\n    eq(R.both(Just(true), Just(false)), Just(false));\n    eq(R.both(Just(true), Nothing()), Nothing());\n    eq(R.both(Nothing(), Just(false)), Nothing());\n    eq(R.both(Nothing(), Nothing()), Nothing());\n  });\n});",
    "failedSpecsReasons": "ramda supports fantasy-land",
    "failedSpecsCount": 1
  },
  "chain": {
    "typing": "chain<T, U>(fn: (n: T) => readonly U[], list: readonly T[]): U[]",
    "allTypings": "chain<T, U>(fn: (n: T) => readonly U[], list: readonly T[]): U[];\nchain<T, U>(fn: (n: T) => readonly U[]): (list: readonly T[]) => U[];\nchain<X0, X1, R>(fn: (x0: X0, x1: X1) => R, fn1: (x1: X1) => X0): (x1: X1) => R;",
    "rambdaSource": "export function chain(fn, list){\n  if (arguments.length === 1){\n    return _list => chain(fn, _list)\n  }\n\n  return [].concat(...list.map(fn))\n}",
    "rambdaSpecs": "import { chain } from './chain'\n\nconst duplicate = n => [ n, n ]\n\ntest('happy', () => {\n  const fn = x => [ x * 2 ]\n  const list = [ 1, 2, 3 ]\n\n  const result = chain(fn, list)\n\n  expect(result).toEqual([ 2, 4, 6 ])\n})\n\ntest('maps then flattens one level', () => {\n  expect(chain(duplicate, [ 1, 2, 3 ])).toEqual([ 1, 1, 2, 2, 3, 3 ])\n})\n\ntest('maps then flattens one level - curry', () => {\n  expect(chain(duplicate)([ 1, 2, 3 ])).toEqual([ 1, 1, 2, 2, 3, 3 ])\n})\n\ntest('flattens only one level', () => {\n  const nest = n => [ [ n ] ]\n  expect(chain(nest, [ 1, 2, 3 ])).toEqual([ [ 1 ], [ 2 ], [ 3 ] ])\n})",
    "explanation": "The method is also known as `flatMap`.",
    "example": "const duplicate = n => [ n, n ]\nconst list = [ 1, 2, 3 ]\n\nconst result = chain(duplicate, list)\n// => [ 1, 1, 2, 2, 3, 3 ]",
    "typescriptDefinitionTest": "import {chain} from 'rambda'\n\nconst list = [ 1, 2, 3 ]\nconst duplicate = (n: number) => [ n, n ]\n\ndescribe('chain', () => {\n  it('without passing type', () => {\n    const result = chain(duplicate, list)\n    result // $ExpectType number[]\n  })\n\n  it('passing types', () => {\n    const duplicateAndModify = (x: number) => [\n      `||${x}||`,\n      `||${x}||`\n    ]\n    const result = chain<number, string>(duplicateAndModify, list)\n    const resultCurried = chain<number, string>(duplicateAndModify)(list)\n    result // $ExpectType string[]\n    resultCurried // $ExpectType string[]\n  })\n})",
    "failedSpecsReasons": "ramda passes to `chain` if available | ramda supports fantasy-land",
    "failedSpecsCount": 5
  },
  "clamp": {
    "typing": "clamp(min: number, max: number, input: number): number",
    "allTypings": "clamp(min: number, max: number, input: number): number;\nclamp(min: number, max: number): (input: number) => number;",
    "rambdaSource": "import { curry } from './curry'\n\nfunction clampFn(\n  min, max, input\n){\n  if (input >= min && input <= max) return input\n\n  if (input > max) return max\n  if (input < min) return min\n}\n\nexport const clamp = curry(clampFn)",
    "rambdaSpecs": "import { clamp } from './clamp'\n\ntest('rambda specs', () => {\n  expect(clamp(\n    1, 10, 0\n  )).toEqual(1)\n  expect(clamp(\n    3, 12, 1\n  )).toEqual(3)\n  expect(clamp(\n    -15, 3, -100\n  )).toEqual(-15)\n  expect(clamp(\n    1, 10, 20\n  )).toEqual(10)\n  expect(clamp(\n    3, 12, 23\n  )).toEqual(12)\n  expect(clamp(\n    -15, 3, 16\n  )).toEqual(3)\n  expect(clamp(\n    1, 10, 4\n  )).toEqual(4)\n  expect(clamp(\n    3, 12, 6\n  )).toEqual(6)\n  expect(clamp(\n    -15, 3, 0\n  )).toEqual(0)\n})",
    "explanation": "Restrict a number `input` to be withing `min` and `max` limits.\n\nIf `input` is bigger than `max`, then the result is `max`.\n\nIf `input` is smaller than `min`, then the result is `min`.",
    "example": "R.clamp(0, 10, 5) //=> 5\nR.clamp(0, 10, -1) //=> 0\nR.clamp(0, 10, 11) //=> 10"
  },
  "clone": {
    "typing": "clone<T>(input: T): T",
    "allTypings": "clone<T>(input: T): T;\nclone<T>(input: ReadonlyArray<T>): T[];",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function clone(input){\n  const out = _isArray(input) ? Array(input.length) : {}\n  if (input && input.getTime) return new Date(input.getTime())\n\n  for (const key in input){\n    const v = input[ key ]\n    out[ key ] =\n      typeof v === 'object' && v !== null ?\n        v.getTime ?\n          new Date(v.getTime()) :\n          clone(v) :\n        v\n  }\n\n  return out\n}",
    "rambdaSpecs": "import assert from 'assert'\n\nimport { clone } from './clone'\nimport { equals } from './equals'\n\ntest('with array', () => {\n  const arr = [\n    {\n      b : 2,\n      c : 'foo',\n      d : [ 1, 2, 3 ],\n    },\n    1,\n    new Date(),\n    null,\n  ]\n  expect(clone(arr)).toEqual(arr)\n})\n\ntest('with object', () => {\n  const arr = {\n    a : 1,\n    b : 2,\n    c : 3,\n    d : [ 1, 2, 3 ],\n    e : new Date(),\n  }\n  expect(clone(arr)).toEqual(arr)\n})\n\ntest('with date', () => {\n  const date = new Date(\n    2014, 10, 14, 23, 59, 59, 999\n  )\n\n  const cloned = clone(date)\n  assert.notStrictEqual(date, cloned)\n  expect(cloned).toEqual(new Date(\n    2014, 10, 14, 23, 59, 59, 999\n  ))\n\n  expect(cloned.getDay()).toEqual(5)\n})\n\ntest('with R.equals', () => {\n  const objects = [ { a : 1 }, { b : 2 } ]\n\n  const objectsClone = clone(objects)\n\n  const result = [\n    equals(objects, objectsClone),\n    equals(objects[ 0 ], objectsClone[ 0 ]),\n  ]\n  expect(result).toEqual([ true, true ])\n})",
    "explanation": "It creates a deep copy of the `input`, which may contain (nested) Arrays and Objects, Numbers, Strings, Booleans and Dates.",
    "example": "const objects = [{a: 1}, {b: 2}];\nconst objectsClone = R.clone(objects);\n\nconst result = [\n  R.equals(objects, objectsClone),\n  R.equals(objects[0], objectsClone[0]),\n] // => [ true, true ]",
    "failedRamdaSpecs": "var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('deep clone integers, strings and booleans', function() {\n  it('clones integers', function() {\n    eq(R.clone(-4), -4);\n    eq(R.clone(9007199254740991), 9007199254740991);\n  });\n  it('clones floats', function() {\n    eq(R.clone(-4.5), -4.5);\n    eq(R.clone(0.0), 0.0);\n  });\n  it('clones strings', function() {\n    eq(R.clone('ramda'), 'ramda');\n  });\n  it('clones booleans', function() {\n    eq(R.clone(true), true);\n  });\n});\ndescribe('deep clone objects', function() {\n  it('clones objects with circular references', function() {\n    var x = {c: null};\n    var y = {a: x};\n    var z = {b: y};\n    x.c = z;\n    var clone = R.clone(x);\n    assert.notStrictEqual(x, clone);\n    assert.notStrictEqual(x.c, clone.c);\n    assert.notStrictEqual(x.c.b, clone.c.b);\n    assert.notStrictEqual(x.c.b.a, clone.c.b.a);\n    assert.notStrictEqual(x.c.b.a.c, clone.c.b.a.c);\n    eq(R.keys(clone), R.keys(x));\n    eq(R.keys(clone.c), R.keys(x.c));\n    eq(R.keys(clone.c.b), R.keys(x.c.b));\n    eq(R.keys(clone.c.b.a), R.keys(x.c.b.a));\n    eq(R.keys(clone.c.b.a.c), R.keys(x.c.b.a.c));\n    x.c.b = 1;\n    assert.notDeepEqual(clone.c.b, x.c.b);\n  });\n});\ndescribe('deep clone arrays', function() {\n});\ndescribe('deep clone functions', function() {\n});\ndescribe('built-in types', function() {\n  it('clones RegExp object', function() {\n    R.forEach(function(pattern) {\n      var clone = R.clone(pattern);\n      assert.notStrictEqual(clone, pattern);\n      eq(clone.constructor, RegExp);\n      eq(clone.source, pattern.source);\n      eq(clone.global, pattern.global);\n      eq(clone.ignoreCase, pattern.ignoreCase);\n      eq(clone.multiline, pattern.multiline);\n    }, [/x/, /x/g, /x/i, /x/m, /x/gi, /x/gm, /x/im, /x/gim]);\n  });\n});\ndescribe('deep clone deep nested mixed objects', function() {\n  it('clones array with mutual ref object', function() {\n    var obj = {a: 1};\n    var list = [{b: obj}, {b: obj}];\n    var clone = R.clone(list);\n    assert.strictEqual(list[0].b, list[1].b);\n    assert.strictEqual(clone[0].b, clone[1].b);\n    assert.notStrictEqual(clone[0].b, list[0].b);\n    assert.notStrictEqual(clone[1].b, list[1].b);\n    eq(clone[0].b, {a:1});\n    eq(clone[1].b, {a:1});\n    obj.a = 2;\n    eq(clone[0].b, {a:1});\n    eq(clone[1].b, {a:1});\n  });\n});\ndescribe('deep clone edge cases', function() {\n  it('nulls, undefineds and empty objects and arrays', function() {\n    eq(R.clone(null), null);\n    eq(R.clone(undefined), undefined);\n    assert.notStrictEqual(R.clone(undefined), null);\n    var obj = {};\n    assert.notStrictEqual(R.clone(obj), obj);\n    var list = [];\n    assert.notStrictEqual(R.clone(list), list);\n  });\n});\ndescribe('Let `R.clone` use an arbitrary user defined `clone` method', function() {\n  it('dispatches to `clone` method if present', function() {\n    function ArbitraryClone(x) { this.value = x; }\n    ArbitraryClone.prototype.clone = function() { return new ArbitraryClone(this.value); };\n    var obj = new ArbitraryClone(42);\n    var arbitraryClonedObj = R.clone(obj);\n    eq(arbitraryClonedObj, new ArbitraryClone(42));\n    eq(arbitraryClonedObj instanceof ArbitraryClone, true);\n  });\n});",
    "failedSpecsReasons": "rambda method work only with objects and arrays",
    "failedSpecsCount": 9
  },
  "complement": {
    "typing": "complement(pred: (...args: any[]) => boolean): (...args: any[]) => boolean",
    "allTypings": "complement(pred: (...args: any[]) => boolean): (...args: any[]) => boolean;",
    "rambdaSource": "export function complement(fn){\n  return (...input) => !fn(...input)\n}",
    "rambdaSpecs": "import { complement } from './complement'\n\ntest('happy', () => {\n  const fn = complement(x => x.length === 0)\n\n  expect(fn([ 1, 2, 3 ])).toBeTrue()\n})\n\ntest('with multiple parameters', () => {\n  const between = function (\n    a, b, c\n  ){\n    return a < b && b < c\n  }\n  const f = complement(between)\n  expect(f(\n    4, 5, 11\n  )).toEqual(false)\n  expect(f(\n    12, 2, 6\n  )).toEqual(true)\n})",
    "explanation": "It returns `inverted` version of `origin` function that accept `input` as argument.\n\nThe return value of `inverted` is the negative boolean value of `origin(input)`.",
    "example": "const origin = x => x > 5\nconst inverted = complement(origin)\n\nconst result = [\n  origin(7),\n  inverted(7)\n] => [ true, false ]",
    "failedRamdaSpecs": "var S = require('sanctuary');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('complement', function() {\n  it('accepts fantasy-land functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.complement(Just(true)), Just(false));\n    eq(R.complement(Just(false)), Just(true));\n    eq(R.complement(Nothing()), Nothing());\n  });\n});",
    "failedSpecsReasons": "ramda supports fantasy-land",
    "failedSpecsCount": 1
  },
  "compose": {
    "typing": "compose<T1>(fn0: () => T1): () => T1",
    "allTypings": "compose<T1>(fn0: () => T1): () => T1;\ncompose<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;\ncompose<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;\ncompose<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;",
    "rambdaSource": "export function compose(...fns){\n  if (fns.length === 0){\n    throw new Error('compose requires at least one argument')\n  }\n\n  return (...args) => {\n    const list = fns.slice()\n    if (list.length > 0){\n      const fn = list.pop()\n      let result = fn(...args)\n      while (list.length > 0){\n        result = list.pop()(result)\n      }\n\n      return result\n    }\n  }\n}",
    "rambdaSpecs": "import { add } from './add'\nimport { compose } from './compose'\nimport { filter } from './filter'\nimport { last } from './last'\nimport { map } from './map'\n\ntest('happy', () => {\n  const result = compose(\n    last, map(add(10)), map(add(1))\n  )([ 1, 2, 3 ])\n\n  expect(result).toEqual(14)\n})\n\ntest('accepts initially two arguments', () => {\n  const result = compose(map(x => x * 2),\n    (a, y) => filter(x => x > y, a))([ 1, 2, 3, 4 ], 2)\n\n  expect(result).toEqual([ 6, 8 ])\n})\n\ntest('when no arguments is passed', () => {\n  expect(() => compose()).toThrow('compose requires at least one argument')\n})\n\ntest('ramda spec', () => {\n  const f = function (\n    a, b, c\n  ){\n    return [ a, b, c ]\n  }\n  const g = compose(f)\n  expect(g(\n    1, 2, 3\n  )).toEqual([ 1, 2, 3 ])\n})",
    "explanation": "It performs right-to-left function composition.",
    "example": "const result = R.compose(\n  R.map(x => x * 2),\n  R.filter(x => x > 2)\n)([1, 2, 3, 4])\n\n// => [6, 8]",
    "failedRamdaSpecs": "var assert = require('assert');\nvar jsv = require('jsverify');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('compose', function() {\n  it('performs right-to-left function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.compose(R.map, R.multiply, parseInt);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.compose(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.compose(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });\n});\ndescribe('compose properties', function() {\n  jsv.property('composes two functions', jsv.fn(), jsv.fn(), jsv.nat, function(f, g, x) {\n    return R.equals(R.compose(f, g)(x), f(g(x)));\n  jsv.property('associative',  jsv.fn(), jsv.fn(), jsv.fn(), jsv.nat, function(f, g, h, x) {\n    var result = f(g(h(x)));\n    return R.all(R.equals(result), [\n      R.compose(f, g, h)(x),\n      R.compose(f, R.compose(g, h))(x),\n      R.compose(R.compose(f, g), h)(x)\n    ]);\n});",
    "failedSpecsReasons": "ramda passes context to functions | rambda composed functions have no length",
    "failedSpecsCount": 3
  },
  "concat": {
    "typing": "concat<T>(x: ReadonlyArray<T>, y: ReadonlyArray<T>): T[]",
    "allTypings": "concat<T>(x: ReadonlyArray<T>, y: ReadonlyArray<T>): T[];\nconcat<T>(x: ReadonlyArray<T>): (y: ReadonlyArray<T>) => T[];\nconcat(x: string, y: string): string;\nconcat(x: string): (y: string) => string;",
    "rambdaSource": "export function concat(x, y){\n  if (arguments.length === 1) return _y => concat(x, _y)\n\n  return typeof x === 'string' ? `${ x }${ y }` : [ ...x, ...y ]\n}",
    "rambdaSpecs": "import { concat } from './concat'\n\ntest('happy', () => {\n  const arr1 = [ 'a', 'b', 'c' ]\n  const arr2 = [ 'd', 'e', 'f' ]\n\n  const a = concat(arr1, arr2)\n  const b = concat(arr1)(arr2)\n  const expectedResult = [ 'a', 'b', 'c', 'd', 'e', 'f' ]\n\n  expect(a).toEqual(expectedResult)\n  expect(b).toEqual(expectedResult)\n})\n\ntest('with strings', () => {\n  expect(concat('ABC', 'DEF')).toEqual('ABCDEF')\n})",
    "explanation": "It returns a new string or array, which is the result of merging `x` and `y`.",
    "example": "R.concat([1, 2])([3, 4]) // => [1, 2, 3, 4]\nR.concat('foo', 'bar') // => 'foobar'",
    "failedRamdaSpecs": "var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('concat', function() {\n  var z1 = {\n    x: 'z1',\n    concat: function(that) { return this.x + ' ' + that.x; }\n  };\n  var z2 = {\n    x: 'z2'\n  };\n  it('delegates to non-String object with a concat method, as second param', function() {\n    eq(R.concat(z1, z2), 'z1 z2');\n  });\n});",
    "failedSpecsReasons": "ramda pass to concat method if present",
    "failedSpecsCount": 1
  },
  "cond": {
    "typing": "cond(conditions: [Pred, (...a: readonly any[]) => any][]): (...a: readonly any[]) => any",
    "allTypings": "cond(conditions: [Pred, (...a: readonly any[]) => any][]): (...a: readonly any[]) => any;\ncond<A, B>(conditions: [SafePred<A>, (...a: readonly A[]) => B][]): (...a: readonly A[]) => B;",
    "rambdaSource": "export function cond(conditions){\n  return input => {\n    let done = false\n    let toReturn\n    conditions.forEach(([ predicate, resultClosure ]) => {\n      if (!done && predicate(input)){\n        done = true\n        toReturn = resultClosure(input)\n      }\n    })\n\n    return toReturn\n  }\n}",
    "rambdaSpecs": "import { always } from './always'\nimport { cond } from './cond'\nimport { equals } from './equals'\nimport { T } from './T'\n\ntest('returns a function', () => {\n  expect(typeof cond([])).toEqual('function')\n})\n\ntest('returns a conditional function', () => {\n  const fn = cond([\n    [ equals(0), always('water freezes at 0C') ],\n    [ equals(100), always('water boils at 100C') ],\n    [\n      T,\n      function (temp){\n        return 'nothing special happens at ' + temp + 'C'\n      },\n    ],\n  ])\n  expect(fn(0)).toEqual('water freezes at 0C')\n  expect(fn(50)).toEqual('nothing special happens at 50C')\n  expect(fn(100)).toEqual('water boils at 100C')\n})\n\ntest('no winner', () => {\n  const fn = cond([\n    [ equals('foo'), always(1) ],\n    [ equals('bar'), always(2) ],\n  ])\n  expect(fn('quux')).toEqual(undefined)\n})\n\ntest('predicates are tested in order', () => {\n  const fn = cond([\n    [ T, always('foo') ],\n    [ T, always('bar') ],\n    [ T, always('baz') ],\n  ])\n  expect(fn()).toEqual('foo')\n})",
    "explanation": "It takes list with `conditions` and returns a new function `fn` that expects `input` as argument. \n\nThis function will start evaluating the `conditions` in order to find the first winner(order of conditions matter). \n\nThe winner is this condition, which left side returns `true` when `input` is its argument. Then the evaluation of the right side of the winner will be the final result.\n\nIf no winner is found, then `fn` returns `undefined`.",
    "example": "const fn = R.cond([\n  [ x => x > 25, R.always('more than 25') ],\n  [ x => x > 15, R.always('more than 15') ],\n  [ R.T, x => `${x} is nothing special` ],\n])\n\nconst result = [\n  fn(30),\n  fn(20),\n  fn(10),\n] \n// => ['more than 25', 'more than 15', '10 is nothing special']",
    "typescriptDefinitionTest": "import {cond, always, equals} from 'rambda'\n\ndescribe('cond', () => {\n  it('happy', () => {\n    const fn = cond<number, string>([\n      [equals(0), always('water freezes at 0C')],\n      [equals(100), always('water boils at 100C')],\n      [\n        () => true,\n        function(temp) {\n          return 'nothing special happens at ' + temp + 'C'\n        },\n      ],\n    ])\n\n    const a = fn(0)\n    a // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('cond', function() {\n  it('forwards all arguments to predicates and to transformers', function() {\n    var fn = R.cond([\n      [function(_, x) { return x === 42; }, function() { return arguments.length; }]\n    ]);\n    eq(fn(21, 42, 84), 3);\n  });\n  it('retains highest predicate arity', function() {\n    var fn = R.cond([\n      [R.nAry(2, R.T), R.T],\n      [R.nAry(3, R.T), R.T],\n      [R.nAry(1, R.T), R.T]\n    ]);\n    eq(fn.length, 3);\n  });\n});",
    "failedSpecsReasons": "pass to transformer is not applied in rambda",
    "failedSpecsCount": 2
  },
  "converge": {
    "typing": "converge(after: ((...a: readonly any[]) => any), fns: Array<((...a: readonly any[]) => any)>): (...a: readonly any[]) => any",
    "allTypings": "converge(after: ((...a: readonly any[]) => any), fns: Array<((...a: readonly any[]) => any)>): (...a: readonly any[]) => any;",
    "rambdaSource": "import { curryN } from './curryN'\nimport { map } from './map'\nimport { max } from './max'\nimport { reduce } from './reduce'\n\nexport function converge(fn, transformers){\n  if (arguments.length === 1)\n    return _transformers => converge(fn, _transformers)\n\n  const highestArity = reduce(\n    (a, b) => max(a, b.length), 0, transformers\n  )\n\n  return curryN(highestArity, function (){\n    return fn.apply(this,\n      map(g => g.apply(this, arguments), transformers))\n  })\n}",
    "rambdaSpecs": "import { add } from './add'\nimport { converge } from './converge'\n\nconst mult = function (a, b){\n  return a * b\n}\n\nconst f1 = converge(mult, [\n  function (a){\n    return a\n  },\n  function (a){\n    return a\n  },\n])\nconst f2 = converge(mult, [\n  function (a){\n    return a\n  },\n  function (a, b){\n    return b\n  },\n])\nconst f3 = converge(mult, [\n  function (a){\n    return a\n  },\n  function (\n    a, b, c\n  ){\n    return c\n  },\n])\n\ntest('passes the results of applying the arguments individually to two separate functions into a single one', () => {\n  expect(converge(mult, [ add(1), add(3) ])(2)).toEqual(15) // mult(add1(2), add3(2)) = mult(3, 5) = 3 * 15;\n})\n\ntest('returns a function with the length of the \"longest\" argument', () => {\n  expect(f1.length).toEqual(1)\n  expect(f2.length).toEqual(2)\n  expect(f3.length).toEqual(3)\n})\n\ntest('passes context to its functions', () => {\n  const a = function (x){\n    return this.f1(x)\n  }\n  const b = function (x){\n    return this.f2(x)\n  }\n  const c = function (x, y){\n    return this.f3(x, y)\n  }\n  const d = converge(c, [ a, b ])\n  const context = {\n    f1 : add(1),\n    f2 : add(2),\n    f3 : add,\n  }\n  expect(a.call(context, 1)).toEqual(2)\n  expect(b.call(context, 1)).toEqual(3)\n  expect(d.call(context, 1)).toEqual(5)\n})\n\ntest('returns a curried function', () => {\n  expect(f2(6)(7)).toEqual(42)\n  expect(f3().length).toEqual(3)\n})\n\ntest('works with empty functions list', () => {\n  const fn = converge(function (){\n    return arguments.length\n  }, [])\n  expect(fn.length).toEqual(0)\n  expect(fn()).toEqual(0)\n})"
  },
  "curry": {
    "typing": "curry<F extends (...args: any) => any>(f: F): FunctionToolbelt.Curry<F>",
    "allTypings": "curry<F extends (...args: any) => any>(f: F): FunctionToolbelt.Curry<F>;",
    "rambdaSource": "import { curryN } from './curryN'\n\nexport function curry(fn){\n  return curryN(fn.length, fn)\n}",
    "rambdaSpecs": "import { curry } from './curry'\n\ntest('happy', () => {\n  const addFourNumbers = (\n    a, b, c, d\n  ) => a + b + c + d\n  const curriedAddFourNumbers = curry(addFourNumbers)\n  const f = curriedAddFourNumbers(1, 2)\n  const g = f(3)\n\n  expect(g(4)).toEqual(10)\n})\n\ntest('when called with more arguments', () => {\n  const add = curry((n, n2) => n + n2)\n\n  expect(add(\n    1, 2, 3\n  )).toEqual(3)\n})\n\ntest('when called with zero arguments', () => {\n  const sub = curry((a, b) => a - b)\n  const s0 = sub()\n\n  expect(s0(5, 2)).toEqual(3)\n})\n\ntest('when called via multiple curry stages', () => {\n  const join = curry((\n    a, b, c, d\n  ) => [ a, b, c, d ].join('-'))\n\n  const stage1 = join('A')\n  const stage2 = stage1('B', 'C')\n\n  expect(stage2('D')).toEqual('A-B-C-D')\n})",
    "explanation": "It expects a function as input and returns its curried version.",
    "example": "const fn = (a, b, c) => a + b + c\nconst curried = R.curry(fn)\nconst sum = curried(1,2)\n\nconst result = sum(3) // => 6",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar jsv = require('jsverify');\nvar funcN = require('./shared/funcN');\n\ndescribe('curry', function() {\n  it('properly reports the length of the curried function', function() {\n    var f = R.curry(function(a, b, c, d) {return (a + b * c) / d;});\n    eq(f.length, 4);\n    var g = f(12);\n    eq(g.length, 3);\n    var h = g(3);\n    eq(h.length, 2);\n    eq(g(3, 6).length, 1);\n  });\n  it('preserves context', function() {\n    var ctx = {x: 10};\n    var f = function(a, b) { return a + b * this.x; };\n    var g = R.curry(f);\n    eq(g.call(ctx, 2, 4), 42);\n    eq(g.call(ctx, 2).call(ctx, 4), 42);\n  });\n  it('supports R.__ placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = R.__;\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n  it('supports @@functional/placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n});\ndescribe('curry properties', function() {\n  jsv.property('curries multiple values', funcN(4), jsv.json, jsv.json, jsv.json, jsv.json, function(f, a, b, c, d) {\n    var g = R.curry(f);\n    return R.all(R.equals(f(a, b, c, d)), [\n      g(a, b, c, d),\n      g(a)(b)(c)(d),\n      g(a)(b, c, d),\n      g(a, b)(c, d),\n      g(a, b, c)(d)\n    ]);\n  jsv.property('curries with placeholder', funcN(3), jsv.json, jsv.json, jsv.json, function(f, a, b, c) {\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    var g = R.curry(f);\n    return R.all(R.equals(f(a, b, c)), [\n      g(_, _, c)(a, b),\n      g(a, _, c)(b),\n      g(_, b, c)(a),\n      g(a, _, _)(_, c)(b),\n      g(a, b, _)(c)\n    ]);\n});",
    "failedSpecsReasons": "ramda support placeholder(R.__)",
    "failedSpecsCount": 3
  },
  "curryN": {
    "typing": "curryN(length: number, fn: (...args: readonly any[]) => any): (...a: readonly any[]) => any",
    "allTypings": "curryN(length: number, fn: (...args: readonly any[]) => any): (...a: readonly any[]) => any;",
    "notes": "Function",
    "rambdaSource": "function _curryN(\n  n, cache, fn\n){\n  return function (){\n    // concat cache and the arguments as fast as possible https://jsperf.com/concat-two-arrays-quickly\n    let ci = 0\n    let ai = 0\n    const cl = cache.length\n    const al = arguments.length\n    const args = new Array(cl + al)\n    while (ci < cl){\n      args[ ci ] = cache[ ci ]\n      ci++\n    }\n    while (ai < al){\n      args[ cl + ai ] = arguments[ ai ]\n      ai++\n    }\n    const remaining = n - args.length\n\n    return args.length >= n ?\n      fn.apply(this, args) :\n      _arity(remaining, _curryN(\n        n, args, fn\n      ))\n  }\n}\n\nfunction _arity(n, fn){\n  switch (n){\n  case 0:\n    return function (){\n      return fn.apply(this, arguments)\n    }\n  case 1:\n    return function (_1){\n      return fn.apply(this, arguments)\n    }\n  case 2:\n    return function (_1, _2){\n      return fn.apply(this, arguments)\n    }\n  case 3:\n    return function (\n      _1, _2, _3\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 4:\n    return function (\n      _1, _2, _3, _4\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 5:\n    return function (\n      _1, _2, _3, _4, _5\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 6:\n    return function (\n      _1, _2, _3, _4, _5, _6\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 7:\n    return function (\n      _1, _2, _3, _4, _5, _6, _7\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 8:\n    return function (\n      _1, _2, _3, _4, _5, _6, _7, _8\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 9:\n    return function (\n      _1, _2, _3, _4, _5, _6, _7, _8, _9\n    ){\n      return fn.apply(this, arguments)\n    }\n  case 10:\n    return function (\n      _1, _2, _3, _4, _5, _6, _7, _8, _9, _10\n    ){\n      return fn.apply(this, arguments)\n    }\n  default:\n    throw new Error('First argument to _arity must be a non-negative integer no greater than ten')\n  }\n}\n\nexport function curryN(n, fn){\n  if (arguments.length === 1) return _fn => curryN(n, _fn)\n\n  return _arity(n, _curryN(\n    n, [], fn\n  ))\n}",
    "rambdaSpecs": "import { curryN } from './curryN'\n\ndescribe('curryN', () => {\n  function source(\n    a, b, c, d\n  ){\n    void d\n\n    return a * b * c\n  }\n\n  it('accepts an arity', () => {\n    const curried = curryN(3, source)\n    expect(curried(1)(2)(3)).toEqual(6)\n    expect(curried(1, 2)(3)).toEqual(6)\n    expect(curried(1)(2, 3)).toEqual(6)\n    expect(curried(\n      1, 2, 3\n    )).toEqual(6)\n  })\n\n  it('can be partially applied', () => {\n    const curry3 = curryN(3)\n    const curried = curry3(source)\n    expect(curried.length).toEqual(3)\n    expect(curried(1)(2)(3)).toEqual(6)\n    expect(curried(1, 2)(3)).toEqual(6)\n    expect(curried(1)(2, 3)).toEqual(6)\n    expect(curried(\n      1, 2, 3\n    )).toEqual(6)\n  })\n\n  it('preserves context', () => {\n    const ctx = { x : 10 }\n    const f = function (a, b){\n      return a + b * this.x\n    }\n    const g = curryN(2, f)\n\n    expect(g.call(\n      ctx, 2, 4\n    )).toEqual(42)\n    expect(g.call(ctx, 2).call(ctx, 4)).toEqual(42)\n  })\n\n  it('forwards extra arguments', () => {\n    const f = function (){\n      return Array.prototype.slice.call(arguments)\n    }\n    const g = curryN(3, f)\n\n    expect(g(\n      1, 2, 3\n    )).toEqual([ 1, 2, 3 ])\n    expect(g(\n      1, 2, 3, 4\n    )).toEqual([ 1, 2, 3, 4 ])\n    expect(g(1, 2)(3, 4)).toEqual([ 1, 2, 3, 4 ])\n    expect(g(1)(\n      2, 3, 4\n    )).toEqual([ 1, 2, 3, 4 ])\n    expect(g(1)(2)(3, 4)).toEqual([ 1, 2, 3, 4 ])\n  })\n})",
    "explanation": "It returns a curried equivalent of the provided function, with the specified arity."
  },
  "dec": {
    "typing": "dec(x: number): number",
    "allTypings": "dec(x: number): number;",
    "rambdaSource": "export const dec = x => x - 1",
    "rambdaSpecs": "import { dec } from './dec'\n\ntest('happy', () => {\n  expect(dec(2)).toBe(1)\n})",
    "explanation": "It decrements a number."
  },
  "defaultTo": {
    "typing": "defaultTo<T>(defaultValue: T): (...inputArguments: (T | null | undefined)[]) => T",
    "allTypings": "defaultTo<T>(defaultValue: T): (...inputArguments: (T | null | undefined)[]) => T;\ndefaultTo<T>(defaultValue: T, ...inputArguments: (T | null | undefined)[]): T;\ndefaultTo<T, U>(defaultValue: T | U, ...inputArguments: (T | U | null | undefined)[]): T | U;",
    "notes": "Rambda's **defaultTo** accept indefinite number of arguments when non curried, i.e. `R.defaultTo(2, foo, bar, baz)`.",
    "rambdaSource": "function flagIs(inputArguments){\n  return (\n    inputArguments === undefined ||\n    inputArguments === null ||\n    Number.isNaN(inputArguments) === true\n  )\n}\n\nexport function defaultTo(defaultArgument, ...inputArguments){\n  if (arguments.length === 1){\n    return _inputArguments => defaultTo(defaultArgument, _inputArguments)\n  } else if (arguments.length === 2){\n    return flagIs(inputArguments[ 0 ]) ? defaultArgument : inputArguments[ 0 ]\n  }\n\n  const limit = inputArguments.length - 1\n  let len = limit + 1\n  let ready = false\n  let holder\n\n  while (!ready){\n    const instance = inputArguments[ limit - len + 1 ]\n\n    if (len === 0){\n      ready = true\n    } else if (flagIs(instance)){\n      len -= 1\n    } else {\n      holder = instance\n      ready = true\n    }\n  }\n\n  return holder === undefined ? defaultArgument : holder\n}",
    "rambdaSpecs": "import { defaultTo } from './defaultTo'\n\ntest('with undefined', () => {\n  expect(defaultTo('foo')(undefined)).toEqual('foo')\n})\n\ntest('with null', () => {\n  expect(defaultTo('foo')(null)).toEqual('foo')\n})\n\ntest('with NaN', () => {\n  expect(defaultTo('foo')(NaN)).toEqual('foo')\n})\n\ntest('with empty string', () => {\n  expect(defaultTo('foo', '')).toEqual('')\n})\n\ntest('with false', () => {\n  expect(defaultTo('foo', false)).toEqual(false)\n})\n\ntest('when inputArgument passes initial check', () => {\n  expect(defaultTo('foo', 'bar')).toEqual('bar')\n})\n\ntest('default extends to indefinite input arguments - case 1', () => {\n  const result = defaultTo(\n    'foo', null, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 2', () => {\n  const result = defaultTo(\n    'foo', null, NaN, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 3', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined\n  )\n  const expected = 'foo'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 4', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 5', () => {\n  const result = defaultTo(\n    'foo', null, NaN, 'bar', 'baz'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 6', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined, null, NaN\n  )\n  const expected = 'foo'\n\n  expect(result).toEqual(expected)\n})",
    "explanation": "It returns `defaultValue`, if all of `inputArguments` are `undefined`, `null` or `NaN`.\n\nElse, it returns the first truthy `inputArguments` instance(from left to right).",
    "example": "// With single input argument\nR.defaultTo('foo', 'bar') // => 'bar'\nR.defaultTo('foo', undefined) // => 'foo'\n\n// With multiple input arguments\nR.defaultTo('foo', undefined, null, NaN) // => 'foo'\nR.defaultTo('foo', undefined, 'bar', NaN, 'qux') // => 'bar'\nR.defaultTo('foo', undefined, null, NaN, 'quz') // => 'qux'",
    "typescriptDefinitionTest": "import {defaultTo} from 'rambda'\n\ndescribe('defaultTo with Ramda spec', () => {\n  it('happy', () => {\n    const x = defaultTo<string>('foo', undefined) // $ExpectType string\n    x // $ExpectType string\n  })\n  it('fallback', () => {\n    const x = defaultTo('foo', undefined) // $ExpectType \"foo\"\n    x // $ExpectType \"foo\"\n    const y = defaultTo('foo', 'bar') // $ExpectType \"foo\" | \"bar\"\n    y // $ExpectType \"foo\" | \"bar\"\n  })\n  it('with one type', () => {\n    const x = defaultTo<string>('foo', 'bar') // $ExpectType string\n    x // $ExpectType string\n  })\n  it('with two types', () => {\n    const x = defaultTo<string, number>('foo', 1) // $ExpectType string | number\n    x // $ExpectType string | number\n  })\n})\n\ndescribe('defaultTo with Rambda spec', () => {\n  it('happy', () => {\n    const x = defaultTo<string>('foo', undefined, 'bar') // $ExpectType string\n    x // $ExpectType string\n  })\n\n  it('happy with curry', () => {\n    const fn = defaultTo<string>('foo')\n    const x = fn(undefined, 'bar', null) // $ExpectType string\n    x // $ExpectType string\n    const y = fn(undefined) // $ExpectType string\n    y // $ExpectType string\n  })\n\n  it('with two types', () => {\n    const x = defaultTo<string, number>('foo', undefined, 1, null, 2, 'bar') // $ExpectType string | number\n    x // $ExpectType string | number\n  })\n})"
  },
  "difference": {
    "typing": "difference<T>(a: ReadonlyArray<T>, b: ReadonlyArray<T>): T[]",
    "allTypings": "difference<T>(a: ReadonlyArray<T>, b: ReadonlyArray<T>): T[];\ndifference<T>(a: ReadonlyArray<T>): (b: ReadonlyArray<T>) => T[];",
    "rambdaSource": "import { includes } from './includes'\nimport { uniq } from './uniq'\n\nexport function difference(a, b){\n  if (arguments.length === 1) return _b => difference(a, _b)\n\n  return uniq(a).filter(aInstance => !includes(aInstance, b))\n}",
    "rambdaSpecs": "import { difference } from './difference'\n\ntest('difference', () => {\n  const a = [ 1, 2, 3, 4 ]\n  const b = [ 3, 4, 5, 6 ]\n  expect(difference(a)(b)).toEqual([ 1, 2 ])\n\n  expect(difference([], [])).toEqual([])\n})\n\ntest('difference with objects', () => {\n  const a = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 4 } ]\n  const b = [ { id : 3 }, { id : 4 }, { id : 5 }, { id : 6 } ]\n  expect(difference(a, b)).toEqual([ { id : 1 }, { id : 2 } ])\n})\n\ntest('no duplicates in first list', () => {\n  const M2 = [ 1, 2, 3, 4, 1, 2, 3, 4 ]\n  const N2 = [ 3, 3, 4, 4, 5, 5, 6, 6 ]\n  expect(difference(M2, N2)).toEqual([ 1, 2 ])\n})\n\ntest('should use R.equals', () => {\n  expect(difference([ NaN ], [ NaN ]).length).toEqual(0)\n})",
    "explanation": "It returns the uniq set of all elements in the first list `a` not contained in the second list `b`.",
    "example": "const a = [ 1, 2, 3, 4 ]\nconst b = [ 3, 4, 5, 6 ]\n\nconst result = difference(a, b)\n// => [ 1, 2 ]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('difference', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  var Z = [3, 4, 5, 6, 10];\n  var Z2 = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8];\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.difference([0], [-0]).length, 1);\n    eq(R.difference([-0], [0]).length, 1);\n    eq(R.difference([NaN], [NaN]).length, 0);\n    eq(R.difference([new Just([42])], [new Just([42])]).length, 0);\n  });\n});",
    "failedSpecsReasons": "ramda supports negative zero",
    "failedSpecsCount": 1
  },
  "dissoc": {
    "typing": "dissoc<T>(prop: string, obj: any): T",
    "allTypings": "dissoc<T>(prop: string, obj: any): T;\ndissoc(prop: string): <U>(obj: any) => U;",
    "rambdaSource": "export function dissoc(prop, obj){\n  if (arguments.length === 1) return _obj => dissoc(prop, _obj)\n\n  if (obj === null || obj === undefined) return {}\n\n  const willReturn = {}\n  for (const p in obj){\n    willReturn[ p ] = obj[ p ]\n  }\n  delete willReturn[ prop ]\n\n  return willReturn\n}",
    "rambdaSpecs": "import { dissoc } from './dissoc'\n\ntest('input is null or undefined', () => {\n  expect(dissoc('b', null)).toEqual({})\n  expect(dissoc('b', undefined)).toEqual({})\n})\n\ntest('property exists curried', () => {\n  expect(dissoc('b')({\n    a : 1,\n    b : 2,\n  })).toEqual({ a : 1 })\n})\n\ntest('property doesn\\'t exists', () => {\n  expect(dissoc('c', {\n    a : 1,\n    b : 2,\n  })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('works with non-string property', () => {\n  expect(dissoc(42, {\n    a  : 1,\n    42 : 2,\n  })).toEqual({ a : 1 })\n\n  expect(dissoc(null, {\n    a    : 1,\n    null : 2,\n  })).toEqual({ a : 1 })\n\n  expect(dissoc(undefined, {\n    a         : 1,\n    undefined : 2,\n  })).toEqual({ a : 1 })\n})\n\ntest('includes prototype properties', () => {\n  function Rectangle(width, height){\n    this.width = width\n    this.height = height\n  }\n  const area = Rectangle.prototype.area = function (){\n    return this.width * this.height\n  }\n  const rect = new Rectangle(7, 6)\n\n  expect(dissoc('area', rect)).toEqual({\n    width  : 7,\n    height : 6,\n  })\n\n  expect(dissoc('width', rect)).toEqual({\n    height : 6,\n    area   : area,\n  })\n\n  expect(dissoc('depth', rect)).toEqual({\n    width  : 7,\n    height : 6,\n    area   : area,\n  })\n})",
    "explanation": "It returns a new object that does not contain property `prop`.",
    "example": "R.dissoc('b', {a: 1, b: 2, c: 3})\n//=> {a: 1, c: 3}"
  },
  "divide": {
    "typing": "divide(a: number, b: number): number",
    "allTypings": "divide(a: number, b: number): number;\ndivide(a: number): (b: number) => number;",
    "rambdaSource": "export function divide(a, b){\n  if (arguments.length === 1) return _b => divide(a, _b)\n\n  return a / b\n}",
    "rambdaSpecs": "import { divide } from './divide'\n\ntest('happy', () => {\n  expect(divide(71, 100)).toEqual(0.71)\n  expect(divide(71)(100)).toEqual(0.71)\n})",
    "example": "R.divide(71, 100) // => 0.71"
  },
  "drop": {
    "typing": "drop<T>(howManyToDrop: number, listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "drop<T>(howManyToDrop: number, listOrString: ReadonlyArray<T>): T[];\ndrop(howManyToDrop: number, listOrString: string): string;\ndrop<T>(howManyToDrop: number): {\n  (listOrString: string): string;\n  (listOrString: ReadonlyArray<T>): T[];\n};",
    "rambdaSource": "export function drop(howManyToDrop, listOrString){\n  if (arguments.length === 1) return _list => drop(howManyToDrop, _list)\n\n  return listOrString.slice(howManyToDrop > 0 ? howManyToDrop : 0)\n}",
    "rambdaSpecs": "import assert from 'assert'\n\nimport { drop } from './drop'\n\ntest('with array', () => {\n  expect(drop(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'baz' ])\n  expect(drop(3, [ 'foo', 'bar', 'baz' ])).toEqual([])\n  expect(drop(4, [ 'foo', 'bar', 'baz' ])).toEqual([])\n})\n\ntest('with string', () => {\n  expect(drop(3, 'rambda')).toEqual('bda')\n})\n\ntest('with non-positive count', () => {\n  expect(drop(0, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(drop(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(drop(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('should return copy', () => {\n  const xs = [ 1, 2, 3 ]\n\n  assert.notStrictEqual(drop(0, xs), xs)\n  assert.notStrictEqual(drop(-1, xs), xs)\n})",
    "explanation": "It returns `listOrString` with `howManyToDrop` items dropped from its beginning.",
    "example": "R.drop(2, ['foo', 'bar', 'baz']) // => ['baz']\nR.drop(2, 'foobar')  // => 'obar'",
    "typescriptDefinitionTest": "import {drop} from 'rambda'\n\ndescribe('drop', () => {\n  it('happy', () => {\n    const x = drop(2, 'foo') // $ExpectType string\n    x // $ExpectType string\n    const xx = drop(2)('foo') // $ExpectType string\n    xx // $ExpectType string\n    const y = drop(2, [1, 2, 3]) // $ExpectType number[]\n    y // $ExpectType number[]\n    const yy = drop<number>(2)([1, 2, 3]) // $ExpectType number[]\n    yy // $ExpectType number[]\n  })\n})"
  },
  "dropLast": {
    "typing": "dropLast<T>(howManyToDrop: number, listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "dropLast<T>(howManyToDrop: number, listOrString: ReadonlyArray<T>): T[];\ndropLast(howManyToDrop: number, listOrString: string): string;\ndropLast<T>(howManyToDrop: number): {\n  (listOrString: ReadonlyArray<T>): T[];\n  (listOrString: string): string;\n};",
    "rambdaSource": "export function dropLast(howManyToDrop, listOrString){\n  if (arguments.length === 1){\n    return _listOrString => dropLast(howManyToDrop, _listOrString)\n  }\n\n  return howManyToDrop > 0 ?\n    listOrString.slice(0, -howManyToDrop) :\n    listOrString.slice()\n}",
    "rambdaSpecs": "import assert from 'assert'\n\nimport { dropLast } from './dropLast'\n\ntest('with array', () => {\n  expect(dropLast(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'foo' ])\n  expect(dropLast(3, [ 'foo', 'bar', 'baz' ])).toEqual([])\n  expect(dropLast(4, [ 'foo', 'bar', 'baz' ])).toEqual([])\n})\n\ntest('with string', () => {\n  expect(dropLast(3, 'rambda')).toEqual('ram')\n})\n\ntest('with non-positive count', () => {\n  expect(dropLast(0, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(dropLast(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(dropLast(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('should return copy', () => {\n  const xs = [ 1, 2, 3 ]\n\n  assert.notStrictEqual(dropLast(0, xs), xs)\n  assert.notStrictEqual(dropLast(-1, xs), xs)\n})",
    "explanation": "It returns `listOrString` with `howManyToDrop` items dropped from its end.",
    "example": "R.dropLast(2, ['foo', 'bar', 'baz']) // => ['foo']\nR.dropLast(2, 'foobar')  // => 'foob'",
    "failedRamdaSpecs": "var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('dropLast', function() {\n  it('can act as a transducer', function() {\n    var dropLast2 = R.dropLast(2);\n    assert.deepEqual(R.into([], dropLast2, [1, 3, 5, 7, 9, 1, 2]), [1, 3, 5, 7, 9]);\n    assert.deepEqual(R.into([], dropLast2, [1]), []);\n  });\n});",
    "failedSpecsReasons": "ramda method can act as a transducer",
    "failedSpecsCount": 5
  },
  "either": {
    "typing": "either(firstPredicate: Pred, secondPredicate: Pred): Pred",
    "allTypings": "either(firstPredicate: Pred, secondPredicate: Pred): Pred;\neither(firstPredicate: Pred): (secondPredicate: Pred) => Pred;",
    "rambdaSource": "export function either(firstPredicate, secondPredicate){\n  if (arguments.length === 1){\n    return _secondPredicate => either(firstPredicate, _secondPredicate)\n  }\n\n  return (...input) =>\n    Boolean(firstPredicate(...input) || secondPredicate(...input))\n}",
    "rambdaSpecs": "import { either } from './either'\n\ntest('with multiple inputs', () => {\n  const between = function (\n    a, b, c\n  ){\n    return a < b && b < c\n  }\n  const total20 = function (\n    a, b, c\n  ){\n    return a + b + c === 20\n  }\n  const fn = either(between, total20)\n  expect(fn(\n    7, 8, 5\n  )).toBeTrue()\n})\n\ntest('skip evaluation of the second expression', () => {\n  let effect = 'not evaluated'\n  const F = function (){\n    return true\n  }\n  const Z = function (){\n    effect = 'Z got evaluated'\n  }\n  either(F, Z)()\n\n  expect(effect).toBe('not evaluated')\n})\n\ntest('case 1', () => {\n  const firstFn = val => val > 0\n  const secondFn = val => val * 5 > 10\n\n  expect(either(firstFn, secondFn)(1)).toBeTrue()\n})\n\ntest('case 2', () => {\n  const firstFn = val => val > 0\n  const secondFn = val => val === -10\n  const fn = either(firstFn)(secondFn)\n\n  expect(fn(-10)).toBeTrue()\n})",
    "explanation": "It returns a new `predicate` function from `firstPredicate` and `secondPredicate` inputs.\n\nThis `predicate` function will return `true`, if any of the two input predicates return `true`.",
    "example": "const firstPredicate = x => x > 10\nconst secondPredicate = x => x % 2 === 0\nconst predicate = R.either(firstPredicate, secondPredicate)\n\nconst result = [\n  predicate(15),\n  predicate(8),\n  predicate(7),\n]\n//=> [true, true, false]",
    "failedRamdaSpecs": "var S = require('sanctuary');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('either', function() {\n  it('accepts fantasy-land applicative functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.either(Just(true), Just(true)), Just(true));\n    eq(R.either(Just(true), Just(false)), Just(true));\n    eq(R.either(Just(false), Just(false)), Just(false));\n    eq(R.either(Just(true), Nothing()), Nothing());\n    eq(R.either(Nothing(), Just(false)), Nothing());\n    eq(R.either(Nothing(), Nothing()), Nothing());\n  });\n});",
    "failedSpecsReasons": "ramda supports fantasy-land",
    "failedSpecsCount": 1
  },
  "endsWith": {
    "typing": "endsWith(target: string, str: string): boolean",
    "allTypings": "endsWith(target: string, str: string): boolean;\nendsWith(target: string): (str: string) => boolean;",
    "notes": "It doesn't work with arrays unlike its corresponding **Ramda** method.",
    "rambdaSource": "export function endsWith(target, str){\n  if (arguments.length === 1) return _str => endsWith(target, _str)\n\n  return str.endsWith(target)\n}",
    "rambdaSpecs": "import { endsWith } from './endsWith'\n\ntest('happy', () => {\n  expect(endsWith('bar', 'foo-bar')).toBeTrue()\n  expect(endsWith('baz')('foo-bar')).toBeFalse()\n})\n\ntest('does not work with arrays', () => {\n  expect(() => endsWith([ 'c' ], [ 'a', 'b', 'c' ])).toThrow('str.endsWith is not a function')\n})",
    "explanation": "Curried version of `String.prototype.endsWith`",
    "example": "const str = 'foo-bar'\nconst target = '-bar'\n\nconst result = R.endsWith(target, str)\n// => true",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('startsWith', function() {\n  it('should return true when an array ends with the provided value', function() {\n    eq(R.endsWith(['c'], ['a', 'b', 'c']), true);\n  });\n  it('should return true when an array ends with the provided values', function() {\n    eq(R.endsWith(['b', 'c'], ['a', 'b', 'c']), true);\n  });\n  it('should return false when an array does not end with the provided value', function() {\n    eq(R.endsWith(['b'], ['a', 'b', 'c']), false);\n  });\n  it('should return false when an array does not end with the provided values', function() {\n    eq(R.endsWith(['a', 'b'], ['a', 'b', 'c']), false);\n  });\n});",
    "failedSpecsReasons": "rambda doesn't support arrays",
    "failedSpecsCount": 4
  },
  "equals": {
    "typing": "equals<T>(a: T, b: T): boolean",
    "allTypings": "equals<T>(a: T, b: T): boolean;\nequals<T>(a: T): (b: T) => boolean;",
    "notes": "It doesn't handle cyclical data structures.",
    "rambdaSource": "import { type } from './type'\n\nfunction parseError(maybeError){\n  const typeofError = maybeError.__proto__.toString()\n  if (![ 'Error', 'TypeError' ].includes(typeofError)) return []\n\n  return [ typeofError, maybeError.message ]\n}\n\nfunction parseDate(maybeDate){\n  if (!maybeDate.toDateString) return [ false ]\n\n  return [ true, maybeDate.getTime() ]\n}\n\nfunction parseRegex(maybeRegex){\n  if (maybeRegex.constructor !== RegExp) return [ false ]\n\n  return [ true, maybeRegex.toString() ]\n}\n\nexport function equals(a, b){\n  if (arguments.length === 1) return _b => equals(a, _b)\n\n  const aType = type(a)\n\n  if (aType !== type(b)) return false\n  if ([ 'NaN', 'Undefined', 'Null' ].includes(aType)) return true\n  if ([ 'Boolean', 'Number', 'String' ].includes(aType))\n    return a.toString() === b.toString()\n\n  if (aType === 'Array'){\n    const aClone = Array.from(a)\n    const bClone = Array.from(b)\n\n    if (aClone.toString() !== bClone.toString()){\n      return false\n    }\n\n    let loopArrayFlag = true\n    aClone.forEach((aCloneInstance, aCloneIndex) => {\n      if (loopArrayFlag){\n        if (\n          aCloneInstance !== bClone[ aCloneIndex ] &&\n          !equals(aCloneInstance, bClone[ aCloneIndex ])\n        ){\n          loopArrayFlag = false\n        }\n      }\n    })\n\n    return loopArrayFlag\n  }\n\n  const aRegex = parseRegex(a)\n  const bRegex = parseRegex(b)\n\n  if (aRegex[ 0 ]){\n    return bRegex[ 0 ] ? aRegex[ 1 ] === bRegex[ 1 ] : false\n  } else if (bRegex[ 0 ]) return false\n\n  const aDate = parseDate(a)\n  const bDate = parseDate(b)\n\n  if (aDate[ 0 ]){\n    return bDate[ 0 ] ? aDate[ 1 ] === bDate[ 1 ] : false\n  } else if (bDate[ 0 ]) return false\n\n  const aError = parseError(a)\n  const bError = parseError(b)\n\n  if (aError[ 0 ]){\n    return bError[ 0 ] ?\n      aError[ 0 ] === bError[ 0 ] && aError[ 1 ] === bError[ 1 ] :\n      false\n  }\n\n  if (aType === 'Object'){\n    const aKeys = Object.keys(a)\n\n    if (aKeys.length !== Object.keys(b).length){\n      return false\n    }\n\n    let loopObjectFlag = true\n    aKeys.forEach(aKeyInstance => {\n      if (loopObjectFlag){\n        const aValue = a[ aKeyInstance ]\n        const bValue = b[ aKeyInstance ]\n\n        if (aValue !== bValue && !equals(aValue, bValue)){\n          loopObjectFlag = false\n        }\n      }\n    })\n\n    return loopObjectFlag\n  }\n\n  return false\n}",
    "rambdaSpecs": "import { equals } from './equals'\n\ntest('happy', () => {\n  const result = equals([ 1, { a : 1 }, [ { b : 3 } ] ], [ 1, { a : 2 }, [ { b : 3 } ] ])\n\n  expect(result).toBeFalse()\n})\n\ntest('with regex', () => {\n  expect(equals(/s/, /s/)).toEqual(true)\n  expect(equals(/s/, /d/)).toEqual(false)\n  expect(equals(/a/gi, /a/gi)).toEqual(true)\n  expect(equals(/a/gim, /a/gim)).toEqual(true)\n  expect(equals(/a/gi, /a/i)).toEqual(false)\n})\n\ntest('not a number', () => {\n  expect(equals([ NaN ], [ NaN ])).toBe(true)\n})\n\ntest('new number', () => {\n  expect(equals(new Number(0), new Number(0))).toEqual(true)\n  expect(equals(new Number(0), new Number(1))).toEqual(false)\n  expect(equals(new Number(1), new Number(0))).toEqual(false)\n})\n\ntest('new string', () => {\n  expect(equals(new String(''), new String(''))).toEqual(true)\n  expect(equals(new String(''), new String('x'))).toEqual(false)\n  expect(equals(new String('x'), new String(''))).toEqual(false)\n  expect(equals(new String('foo'), new String('foo'))).toEqual(true)\n  expect(equals(new String('foo'), new String('bar'))).toEqual(false)\n  expect(equals(new String('bar'), new String('foo'))).toEqual(false)\n})\n\ntest('new Boolean', () => {\n  expect(equals(new Boolean(true), new Boolean(true))).toEqual(true)\n  expect(equals(new Boolean(false), new Boolean(false))).toEqual(true)\n  expect(equals(new Boolean(true), new Boolean(false))).toEqual(false)\n  expect(equals(new Boolean(false), new Boolean(true))).toEqual(false)\n})\n\ntest('new Error', () => {\n  expect(equals(new Error('XXX'), {})).toEqual(false)\n  expect(equals(new Error('XXX'), new TypeError('XXX'))).toEqual(false)\n  expect(equals(new Error('XXX'), new Error('YYY'))).toEqual(false)\n  expect(equals(new Error('XXX'), new Error('XXX'))).toEqual(true)\n  expect(equals(new Error('XXX'), new TypeError('YYY'))).toEqual(false)\n})\n\ntest('with dates', () => {\n  expect(equals(new Date(0), new Date(0))).toEqual(true)\n  expect(equals(new Date(1), new Date(1))).toEqual(true)\n  expect(equals(new Date(0), new Date(1))).toEqual(false)\n  expect(equals(new Date(1), new Date(0))).toEqual(false)\n  expect(equals(new Date(0), {})).toEqual(false)\n  expect(equals({}, new Date(0))).toEqual(false)\n})\n\ntest('ramda spec', () => {\n  expect(equals({}, {})).toEqual(true)\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    a : 1,\n    b : 2,\n  })).toEqual(true)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n  },\n  {\n    b : 3,\n    a : 2,\n  })).toEqual(true)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n  },\n  {\n    a : 3,\n    b : 3,\n  })).toEqual(false)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n    c : 1,\n  },\n  {\n    a : 2,\n    b : 3,\n  })).toEqual(false)\n})\n\ntest('works with boolean tuple', () => {\n  expect(equals([ true, false ], [ true, false ])).toBeTrue()\n  expect(equals([ true, false ], [ true, true ])).toBeFalse()\n})\n\ntest('works with equal objects within array', () => {\n  const objFirst = {\n    a : {\n      b : 1,\n      c : 2,\n      d : [ 1 ],\n    },\n  }\n  const objSecond = {\n    a : {\n      b : 1,\n      c : 2,\n      d : [ 1 ],\n    },\n  }\n\n  const x = [ 1, 2, objFirst, null, '', [] ]\n  const y = [ 1, 2, objSecond, null, '', [] ]\n  expect(equals(x, y)).toBeTrue()\n})\n\ntest('works with different objects within array', () => {\n  const objFirst = { a : { b : 1 } }\n  const objSecond = { a : { b : 2 } }\n\n  const x = [ 1, 2, objFirst, null, '', [] ]\n  const y = [ 1, 2, objSecond, null, '', [] ]\n  expect(equals(x, y)).toBeFalse()\n})\n\ntest('works with undefined as second argument', () => {\n  expect(equals(1, undefined)).toBeFalse()\n\n  expect(equals(undefined, undefined)).toBeTrue()\n})\n\ntest('various examples', () => {\n  expect(equals([ 1, 2, 3 ])([ 1, 2, 3 ])).toBeTrue()\n\n  expect(equals([ 1, 2, 3 ], [ 1, 2 ])).toBeFalse()\n\n  expect(equals(1, 1)).toBeTrue()\n\n  expect(equals(1, '1')).toBeFalse()\n\n  expect(equals({}, {})).toBeTrue()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 2,\n    a : 1,\n  })).toBeTrue()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    a : 1,\n    b : 1,\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : false,\n  },\n  {\n    a : 1,\n    b : 1,\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 2,\n    a : 1,\n    c : 3,\n  })).toBeFalse()\n\n  expect(equals({\n    x : {\n      a : 1,\n      b : 2,\n    },\n  },\n  {\n    x : {\n      b : 2,\n      a : 1,\n      c : 3,\n    },\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 3,\n    a : 1,\n  })).toBeFalse()\n\n  expect(equals({ a : { b : { c : 1 } } }, { a : { b : { c : 1 } } })).toBeTrue()\n\n  expect(equals({ a : { b : { c : 1 } } }, { a : { b : { c : 2 } } })).toBeFalse()\n\n  expect(equals({ a : {} }, { a : {} })).toBeTrue()\n\n  expect(equals('', '')).toBeTrue()\n\n  expect(equals('foo', 'foo')).toBeTrue()\n\n  expect(equals('foo', 'bar')).toBeFalse()\n\n  expect(equals(0, false)).toBeFalse()\n\n  expect(equals(/\\s/g, null)).toBeFalse()\n\n  expect(equals(null, null)).toBeTrue()\n\n  expect(equals(false)(null)).toBeFalse()\n})",
    "explanation": "It deeply compares `a` and `b` and returns `true` if they are equal.",
    "example": "R.equals(\n  [1, {a:2}, [{b: 3}]],\n  [1, {a:2}, [{b: 3}]]\n) // => true",
    "failedRamdaSpecs": "/* global Map, Set, WeakMap, WeakSet */\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('equals', function() {\n  var a = [];\n  var b = a;\n  it('never considers Boolean primitive equal to Boolean object', function() {\n    eq(R.equals(true, new Boolean(true)), false);\n    eq(R.equals(new Boolean(true), true), false);\n    eq(R.equals(false, new Boolean(false)), false);\n    eq(R.equals(new Boolean(false), false), false);\n  });\n  it('never considers number primitive equal to Number object', function() {\n    eq(R.equals(0, new Number(0)), false);\n    eq(R.equals(new Number(0), 0), false);\n  });\n  it('never considers string primitive equal to String object', function() {\n    eq(R.equals('', new String('')), false);\n    eq(R.equals(new String(''), ''), false);\n    eq(R.equals('x', new String('x')), false);\n    eq(R.equals(new String('x'), 'x'), false);\n  });\n  var supportsSticky = false;\n  try { RegExp('', 'y'); supportsSticky = true; } catch (e) {}\n  var supportsUnicode = false;\n  try { RegExp('', 'u'); supportsUnicode = true; } catch (e) {}\n  var listA = [1, 2, 3];\n  var listB = [1, 3, 2];\n  var c = {}; c.v = c;\n  var d = {}; d.v = d;\n  var e = []; e.push(e);\n  var f = []; f.push(f);\n  var nestA = {a:[1, 2, {c:1}], b:1};\n  var nestB = {a:[1, 2, {c:1}], b:1};\n  var nestC = {a:[1, 2, {c:2}], b:1};\n  it('handles recursive data structures', function() {\n    eq(R.equals(c, d), true);\n    eq(R.equals(e, f), true);\n    eq(R.equals(nestA, nestB), true);\n    eq(R.equals(nestA, nestC), false);\n  });\n  it('requires that both objects have the same enumerable properties with the same values', function() {\n    var a1 = [];\n    var a2 = [];\n    a2.x = 0;\n    var b1 = new Boolean(false);\n    var b2 = new Boolean(false);\n    b2.x = 0;\n    var d1 = new Date(0);\n    var d2 = new Date(0);\n    d2.x = 0;\n    var n1 = new Number(0);\n    var n2 = new Number(0);\n    n2.x = 0;\n    var r1 = /(?:)/;\n    var r2 = /(?:)/;\n    r2.x = 0;\n    var s1 = new String('');\n    var s2 = new String('');\n    s2.x = 0;\n    eq(R.equals(a1, a2), false);\n    eq(R.equals(b1, b2), false);\n    eq(R.equals(d1, d2), false);\n    eq(R.equals(n1, n2), false);\n    eq(R.equals(r1, r2), false);\n    eq(R.equals(s1, s2), false);\n  });\n  if (typeof ArrayBuffer !== 'undefined' && typeof Int8Array !== 'undefined') {\n    var typArr1 = new ArrayBuffer(10);\n    typArr1[0] = 1;\n    var typArr2 = new ArrayBuffer(10);\n    typArr2[0] = 1;\n    var typArr3 = new ArrayBuffer(10);\n    var intTypArr = new Int8Array(typArr1);\n    typArr3[0] = 0;\n    it('handles typed arrays', function() {\n      eq(R.equals(typArr1, typArr2), true);\n      eq(R.equals(typArr1, typArr3), false);\n      eq(R.equals(typArr1, intTypArr), false);\n    });\n  }\n  if (typeof Promise !== 'undefined') {\n    it('compares Promise objects by identity', function() {\n      var p = Promise.resolve(42);\n      var q = Promise.resolve(42);\n      eq(R.equals(p, p), true);\n      eq(R.equals(p, q), false);\n    });\n  }\n  if (typeof Map !== 'undefined') {\n    it('compares Map objects by value', function() {\n      eq(R.equals(new Map([]), new Map([])), true);\n      eq(R.equals(new Map([]), new Map([[1, 'a']])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[1, 'a']])), true);\n      eq(R.equals(new Map([[1, 'a'], [2, 'b']]), new Map([[2, 'b'], [1, 'a']])), true);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[2, 'a']])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[1, 'b']])), false);\n      eq(R.equals(new Map([[1, 'a'], [2, new Map([[3, 'c']])]]), new Map([[1, 'a'], [2, new Map([[3, 'c']])]])), true);\n      eq(R.equals(new Map([[1, 'a'], [2, new Map([[3, 'c']])]]), new Map([[1, 'a'], [2, new Map([[3, 'd']])]])), false);\n      eq(R.equals(new Map([[[1, 2, 3], [4, 5, 6]]]), new Map([[[1, 2, 3], [4, 5, 6]]])), true);\n      eq(R.equals(new Map([[[1, 2, 3], [4, 5, 6]]]), new Map([[[1, 2, 3], [7, 8, 9]]])), false);\n    });\n    it('dispatches to `equals` method recursively in Set', function() {\n      var a = new Map();\n      var b = new Map();\n      a.set(a, a);\n      eq(R.equals(a, b), false);\n      a.set(b, b);\n      b.set(b, b);\n      b.set(a, a);\n      eq(R.equals(a, b), true);\n    });\n  }\n  if (typeof Set !== 'undefined') {\n    it('compares Set objects by value', function() {\n      eq(R.equals(new Set([]), new Set([])), true);\n      eq(R.equals(new Set([]), new Set([1])), false);\n      eq(R.equals(new Set([1]), new Set([])), false);\n      eq(R.equals(new Set([1, 2]), new Set([2, 1])), true);\n      eq(R.equals(new Set([1, new Set([2, new Set([3])])]), new Set([1, new Set([2, new Set([3])])])), true);\n      eq(R.equals(new Set([1, new Set([2, new Set([3])])]), new Set([1, new Set([2, new Set([4])])])), false);\n      eq(R.equals(new Set([[1, 2, 3], [4, 5, 6]]), new Set([[1, 2, 3], [4, 5, 6]])), true);\n      eq(R.equals(new Set([[1, 2, 3], [4, 5, 6]]), new Set([[1, 2, 3], [7, 8, 9]])), false);\n    });\n    it('dispatches to `equals` method recursively in Set', function() {\n      var a = new Set();\n      var b = new Set();\n      a.add(a);\n      eq(R.equals(a, b), false);\n      a.add(b);\n      b.add(b);\n      b.add(a);\n      eq(R.equals(a, b), true);\n    });\n  }\n  if (typeof WeakMap !== 'undefined') {\n    it('compares WeakMap objects by identity', function() {\n      var m = new WeakMap([]);\n      eq(R.equals(m, m), true);\n      eq(R.equals(m, new WeakMap([])), false);\n    });\n  }\n  if (typeof WeakSet !== 'undefined') {\n    it('compares WeakSet objects by identity', function() {\n      var s = new WeakSet([]);\n      eq(R.equals(s, s), true);\n      eq(R.equals(s, new WeakSet([])), false);\n    });\n  }\n  it('dispatches to `equals` method recursively', function() {\n    function Left(x) { this.value = x; }\n    Left.prototype.equals = function(x) {\n      return x instanceof Left && R.equals(x.value, this.value);\n    };\n    function Right(x) { this.value = x; }\n    Right.prototype.equals = function(x) {\n      return x instanceof Right && R.equals(x.value, this.value);\n    };\n    eq(R.equals(new Left([42]), new Left([42])), true);\n    eq(R.equals(new Left([42]), new Left([43])), false);\n    eq(R.equals(new Left(42), {value: 42}), false);\n    eq(R.equals({value: 42}, new Left(42)), false);\n    eq(R.equals(new Left(42), new Right(42)), false);\n    eq(R.equals(new Right(42), new Left(42)), false);\n    eq(R.equals([new Left(42)], [new Left(42)]), true);\n    eq(R.equals([new Left(42)], [new Right(42)]), false);\n    eq(R.equals([new Right(42)], [new Left(42)]), false);\n    eq(R.equals([new Right(42)], [new Right(42)]), true);\n  });\n});",
    "failedSpecsReasons": "rambda doesn't support recursive data structures, objects with same enumerable properties, map/weakmap type of variables | ramda dispatches to `equals` method recursively",
    "failedSpecsCount": 14
  },
  "F": {
    "typing": "F(): boolean",
    "allTypings": "F(): boolean;",
    "rambdaSource": "export function F(){\n  return false\n}",
    "example": "F() // => false"
  },
  "filter": {
    "typing": "filter<T>(predicate: FilterFunctionArray<T>): (x: T[]) => T[]",
    "allTypings": "filter<T>(predicate: FilterFunctionArray<T>): (x: T[]) => T[];\nfilter<T>(predicate: FilterFunctionArray<T>, x: T[]): T[];\nfilter<T, U>(predicate: FilterFunctionObject<T>): (x: Dictionary<T>) => Dictionary<T>;\nfilter<T>(predicate: FilterFunctionObject<T>, x: Dictionary<T>): Dictionary<T>;",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nfunction filterObject(fn, obj){\n  const willReturn = {}\n\n  for (const prop in obj){\n    if (fn(\n      obj[ prop ], prop, obj\n    )){\n      willReturn[ prop ] = obj[ prop ]\n    }\n  }\n\n  return willReturn\n}\n\nexport function filter(predicate, list){\n  if (arguments.length === 1) return _list => filter(predicate, _list)\n\n  if (!list) return []\n\n  if (!_isArray(list)){\n    return filterObject(predicate, list)\n  }\n\n  let index = 0\n  const len = list.length\n  const willReturn = []\n\n  while (index < len){\n    const value = list[ index ]\n\n    if (predicate(value, index)){\n      willReturn.push(value)\n    }\n\n    index++\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import Ramda from 'ramda'\n\nimport { F } from './F'\nimport { filter } from './filter'\nimport { T } from './T'\n\nconst sampleObject = {\n  a : 1,\n  b : 2,\n  c : 3,\n  d : 4,\n}\n\ntest('happy', () => {\n  const isEven = n => n % 2 === 0\n\n  expect(filter(isEven, [ 1, 2, 3, 4 ])).toEqual([ 2, 4 ])\n  expect(filter(isEven, {\n    a : 1,\n    b : 2,\n    d : 3,\n  })).toEqual({ b : 2 })\n})\n\ntest('bad inputs', () => {\n  expect(filter(T)(undefined)).toEqual([])\n  expect(filter(F, null)).toEqual([])\n  expect(() => Ramda.filter(T, null)).toThrow()\n  expect(() => Ramda.filter(T, undefined)).toThrow()\n})\n\ntest('predicate when input is object', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n  }\n  const predicate = (\n    val, prop, inputObject\n  ) => {\n    expect(inputObject).toEqual(obj)\n    expect(typeof prop).toEqual('string')\n\n    return val < 2\n  }\n  expect(filter(predicate, obj)).toEqual({ a : 1 })\n})\n\ntest('pass index as second argument', () => {\n  let counter = 0\n  filter((x, i) => {\n    expect(i).toBe(counter)\n    counter++\n  },\n  [ 10, 20, 30 ])\n})\n\ntest('with object', () => {\n  const isEven = n => n % 2 === 0\n  const result = filter(isEven, sampleObject)\n  const expectedResult = {\n    b : 2,\n    d : 4,\n  }\n\n  expect(result).toEqual(expectedResult)\n})",
    "explanation": "It filters list or object `input` with `predicate`.",
    "example": "const list = [3, 4, 3, 2]\nconst listPredicate = (x, index) => x - index > 2\n\nconst object = {abc: 'fo', xyz: 'bar', baz: 'foo'}\nconst objectPredicate = (x, prop) => x.length + prop.length > 5\n\nconst result = [\n  R.filter(listPredicate, list),\n  R.filter(objectPredicate, object)\n]\n// => [ [3, 4], { xyz: 'bar', baz: 'foo'} ]",
    "typescriptDefinitionTest": "import {filter} from 'rambda'\n\ndescribe('filter with array', () => {\n  it('1 curry', () => {\n    const x = filter<number>(a => {\n      a // $ExpectType number\n      return a > 1\n    })([1, 2, 3])\n    x // $ExpectType number[]\n  })\n  it('1', () => {\n    const x = filter<number>(\n      a => {\n        a // $ExpectType number\n        return a > 1\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType number[]\n  })\n  it('2', () => {\n    const x = filter<number>(\n      (a, b) => {\n        a // $ExpectType number\n        return a > 1\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType number[]\n  })\n})\n\ndescribe('filter with objects', () => {\n  it('curry', () => {\n    const x = filter<number, number>((a, b, c) => {\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n\n      return a > 1\n    })({a: 1, b: 2})\n    x // $ExpectType Dictionary<number>\n  })\n\n  it('object with three arguments predicate', () => {\n    const x = filter<number>(\n      (a, b, c) => {\n        b // $ExpectType string\n        c // $ExpectType Dictionary<number>\n\n        return a > 1\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<number>\n  })\n\n  it('object with two arguments predicate', () => {\n    const x = filter<number>(\n      (a, b) => {\n        b // $ExpectType string\n        return a > 1\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<number>\n  })\n  it('object with one argument predicate', () => {\n    const x = filter<number>(\n      a => {\n        a // $ExpectType number\n        return a > 1\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<number>\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar Maybe = require('./shared/Maybe');\n\ndescribe('filter', function() {\n  var even = function(x) {return x % 2 === 0;};\n  it('dispatches to passed-in non-Array object with a `filter` method', function() {\n    var f = {filter: function(f) { return f('called f.filter'); }};\n    eq(R.filter(function(s) { return s; }, f), 'called f.filter');\n  });\n  it('correctly uses fantasy-land implementations', function() {\n    var m1 = Maybe.Just(-1);\n    var m2 = R.filter(function(x) { return x > 0; } , m1);\n    eq(m2.isNothing, true);\n  });\n});",
    "failedSpecsReasons": "ramda dispatches to `filter` method of object",
    "failedSpecsCount": 1
  },
  "find": {
    "typing": "find<T>(predicate: (a: T) => boolean, arr: ReadonlyArray<T>): T | undefined",
    "allTypings": "find<T>(predicate: (a: T) => boolean, arr: ReadonlyArray<T>): T | undefined;\nfind<T>(predicate: (a: T) => boolean): (arr: ReadonlyArray<T>) => T | undefined;",
    "rambdaSource": "export function find(predicate, list){\n  if (arguments.length === 1) return _list => find(predicate, _list)\n  let index = 0\n  const len = list.length\n\n  while (index < len){\n    const value = list[ index ]\n    if (predicate(value, index)){\n      return value\n    }\n\n    index++\n  }\n}",
    "rambdaSpecs": "import { find } from './find'\nimport { propEq } from './propEq'\n\nconst list = [ { a : 1 }, { a : 2 }, { a : 3 } ]\n\ntest('happy', () => {\n  const fn = propEq('a', 2)\n  expect(find(fn, list)).toEqual({ a : 2 })\n})\n\ntest('with curry', () => {\n  const fn = propEq('a', 4)\n  expect(find(fn)(list)).toBeUndefined()\n})\n\ntest('with empty list', () => {\n  expect(find(() => true, [])).toBeUndefined()\n})",
    "explanation": "It returns the first element of `list` that satisfy the `predicate`.\n\nIf there is no such element, it returns `undefined`.",
    "example": "const predicate = x => R.type(x.foo) === 'Number'\nconst list = [{foo: 'bar'}, {foo: 1}]\n\nconst result = R.find(predicate, list)\n// => {foo: 1}"
  },
  "findIndex": {
    "typing": "findIndex<T>(findFn: (a: T) => boolean, arr: ReadonlyArray<T>): number",
    "allTypings": "findIndex<T>(findFn: (a: T) => boolean, arr: ReadonlyArray<T>): number;\nfindIndex<T>(findFn: (a: T) => boolean): (arr: ReadonlyArray<T>) => number;",
    "rambdaSource": "export function findIndex(predicate, list){\n  if (arguments.length === 1) return _list => findIndex(predicate, _list)\n\n  const len = list.length\n  let index = -1\n\n  while (++index < len){\n    if (predicate(list[ index ], index)){\n      return index\n    }\n  }\n\n  return -1\n}",
    "rambdaSpecs": "import { findIndex } from './findIndex'\nimport { propEq } from './propEq'\n\ntest('happy', () => {\n  expect(findIndex(propEq('a', 2))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(1)\n\n  expect(findIndex(propEq('a', 1))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(0)\n\n  expect(findIndex(propEq('a', 4))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(-1)\n})\n\ntest('pass index as second argument', () => {\n  findIndex((x, i) => {\n    expect(typeof x).toBe('number')\n    expect(typeof i).toBe('number')\n  })([ 10, 12, 15 ])\n})",
    "explanation": "It returns the index of the first element of `list` satisfying the `predicate` function.\n\nIf there is no such element, then `-1` is returned.",
    "example": "const predicate = x => R.type(x.foo) === 'Number'\nconst list = [{foo: 'bar'}, {foo: 1}]\n\nconst result = R.findIndex(predicate, list)\n// => 1"
  },
  "findLast": {
    "typing": "findLast<T>(fn: (a: T) => boolean, list: T[]): T | undefined",
    "allTypings": "findLast<T>(fn: (a: T) => boolean, list: T[]): T | undefined;\nfindLast<T>(fn: (a: T) => boolean): (list: T[]) => T | undefined;",
    "rambdaSource": "export function findLast(predicate, list){\n  if (arguments.length === 1) return _list => findLast(predicate, _list)\n\n  let index = list.length\n\n  while (--index >= 0){\n    if (predicate(list[ index ], index)){\n      return list[ index ]\n    }\n  }\n\n  return undefined\n}",
    "rambdaSpecs": "import { findLast } from './findLast'\n\ntest('happy', () => {\n  const result = findLast((x, i) => {\n    expect(typeof i).toBe('number')\n\n    return x > 1\n  },\n  [ 1, 1, 1, 2, 3, 4, 1 ])\n  expect(result).toEqual(4)\n\n  expect(findLast(x => x === 0, [ 0, 1, 1, 2, 3, 4, 1 ])).toEqual(0)\n})\n\ntest('with curry', () => {\n  expect(findLast(x => x > 1)([ 1, 1, 1, 2, 3, 4, 1 ])).toEqual(4)\n})\n\nconst obj1 = { x : 100 }\nconst obj2 = { x : 200 }\nconst a = [ 11, 10, 9, 'cow', obj1, 8, 7, 100, 200, 300, obj2, 4, 3, 2, 1, 0 ]\nconst even = function (x){\n  return x % 2 === 0\n}\nconst gt100 = function (x){\n  return x > 100\n}\nconst isStr = function (x){\n  return typeof x === 'string'\n}\nconst xGt100 = function (o){\n  return o && o.x > 100\n}\n\ntest('ramda 1', () => {\n  expect(findLast(even, a)).toEqual(0)\n  expect(findLast(gt100, a)).toEqual(300)\n  expect(findLast(isStr, a)).toEqual('cow')\n  expect(findLast(xGt100, a)).toEqual(obj2)\n})\n\ntest('ramda 2', () => {\n  expect(findLast(even, [ 'zing' ])).toEqual(undefined)\n})\n\ntest('ramda 3', () => {\n  expect(findLast(even, [ 2, 3, 5 ])).toEqual(2)\n})\n\ntest('ramda 4', () => {\n  expect(findLast(even, [])).toEqual(undefined)\n})",
    "explanation": "It returns the last element of `list` satisfying the `predicate` function.\n\nIf there is no such element, then `undefined` is returned.",
    "example": "const predicate = x => R.type(x.foo) === 'Number'\nconst list = [{foo: 0}, {foo: 1}]\n\nconst result = R.findLast(predicate, list)\n// => {foo: 1}"
  },
  "findLastIndex": {
    "typing": "findLastIndex<T>(fn: (a: T) => boolean, list: T[]): number",
    "allTypings": "findLastIndex<T>(fn: (a: T) => boolean, list: T[]): number;\nfindLastIndex<T>(fn: (a: T) => boolean): (list: T[]) => number;",
    "rambdaSource": "export function findLastIndex(fn, list){\n  if (arguments.length === 1) return _list => findLastIndex(fn, _list)\n\n  let index = list.length\n\n  while (--index >= 0){\n    if (fn(list[ index ], index)){\n      return index\n    }\n  }\n\n  return -1\n}",
    "rambdaSpecs": "import { findLastIndex } from './findLastIndex'\n\ntest('happy', () => {\n  const result = findLastIndex((x, i) => {\n    expect(typeof i).toBe('number')\n\n    return x > 1\n  },\n  [ 1, 1, 1, 2, 3, 4, 1 ])\n\n  expect(result).toEqual(5)\n\n  expect(findLastIndex(x => x === 0, [ 0, 1, 1, 2, 3, 4, 1 ])).toEqual(0)\n})\n\ntest('with curry', () => {\n  expect(findLastIndex(x => x > 1)([ 1, 1, 1, 2, 3, 4, 1 ])).toEqual(5)\n})\n\nconst obj1 = { x : 100 }\nconst obj2 = { x : 200 }\nconst a = [ 11, 10, 9, 'cow', obj1, 8, 7, 100, 200, 300, obj2, 4, 3, 2, 1, 0 ]\nconst even = function (x){\n  return x % 2 === 0\n}\nconst gt100 = function (x){\n  return x > 100\n}\nconst isStr = function (x){\n  return typeof x === 'string'\n}\nconst xGt100 = function (o){\n  return o && o.x > 100\n}\n\ntest('ramda 1', () => {\n  expect(findLastIndex(even, a)).toEqual(15)\n  expect(findLastIndex(gt100, a)).toEqual(9)\n  expect(findLastIndex(isStr, a)).toEqual(3)\n  expect(findLastIndex(xGt100, a)).toEqual(10)\n})\n\ntest('ramda 2', () => {\n  expect(findLastIndex(even, [ 'zing' ])).toEqual(-1)\n})\n\ntest('ramda 3', () => {\n  expect(findLastIndex(even, [ 2, 3, 5 ])).toEqual(0)\n})\n\ntest('ramda 4', () => {\n  expect(findLastIndex(even, [])).toEqual(-1)\n})",
    "explanation": "It returns the index of the last element of `list` satisfying the `predicate` function.\n\nIf there is no such element, then `-1` is returned.",
    "example": "const predicate = x => R.type(x.foo) === 'Number'\nconst list = [{foo: 0}, {foo: 1}]\n\nconst result = R.findLastIndex(predicate, list)\n// => 1"
  },
  "flatten": {
    "typing": "flatten<T>(x: ReadonlyArray<T> | ReadonlyArray<T[]> | ReadonlyArray<ReadonlyArray<T>>): T[]",
    "allTypings": "flatten<T>(x: ReadonlyArray<T> | ReadonlyArray<T[]> | ReadonlyArray<ReadonlyArray<T>>): T[];",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function flatten(list, input){\n  const willReturn = input === undefined ? [] : input\n\n  for (let i = 0; i < list.length; i++){\n    if (_isArray(list[ i ])){\n      flatten(list[ i ], willReturn)\n    } else {\n      willReturn.push(list[ i ])\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { flatten } from './flatten'\n\ntest('happy', () => {\n  expect(flatten([ 1, 2, 3, [ [ [ [ [ 4 ] ] ] ] ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, [ 2, [ [ 3 ] ] ], [ 4 ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, [ 2, [ [ [ 3 ] ] ] ], [ 4 ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, 2, [ 3, 4 ], 5, [ 6, [ 7, 8, [ 9, [ 10, 11 ], 12 ] ] ] ])).toEqual([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ])\n})\n\ntest('readme example', () => {\n  const result = flatten([ 1, 2, [ 3, 30, [ 300 ] ], [ 4 ] ])\n  expect(result).toEqual([ 1, 2, 3, 30, 300, 4 ])\n})",
    "explanation": "It deeply flattens an array.",
    "example": "const result = R.flatten([\n  1, \n  2, \n  [3, 30, [300]], \n  [4]\n])\n// => [ 1, 2, 3, 30, 300, 4 ]"
  },
  "flip": {
    "typing": "flip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult",
    "allTypings": "flip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult;\nflip<F extends (...args: any) => any, P extends FunctionToolbelt.Parameters<F>>(fn: F): FunctionToolbelt.Curry<(...args: TupleToolbelt.Merge<[P[1], P[0]], P>) => FunctionToolbelt.Return<F>>;",
    "notes": "Rambda's **flip** will throw if arity of the input function is greater than 4.",
    "rambdaSource": "import { curryN } from './curryN'\n\nfunction flipExport(fn){\n  const flipedFn = (...input) => {\n    const missing = fn.length - input.length\n\n    if (missing <= 0) return fn(\n      input[ 1 ], input[ 0 ], ...input.slice(2)\n    )\n\n    if (input.length === 0) return flipedFn\n\n    if (input.length === 1)\n      return curryN(missing, (...rest) => {\n        const args = [ rest[ 0 ], input[ 0 ], ...rest.slice(1) ]\n\n        return fn(...args)\n      })\n\n    // input.length >= 2\n    return curryN(missing, (...rest) => {\n      const args = [ input[ 1 ], input[ 0 ], ...input.slice(2), ...rest ]\n\n      return fn(...args)\n    })\n  }\n\n  return flipedFn\n}\n\nexport function flip(fn){\n  return flipExport(fn)\n}",
    "rambdaSpecs": "import { flip } from './flip'\nimport { subtract } from './subtract'\nimport { update } from './update'\n\ntest('function with arity of 2', () => {\n  const subtractFlipped = flip(subtract)\n\n  expect(subtractFlipped(1)(7)).toEqual(6)\n  expect(subtractFlipped(1, 7)).toEqual(6)\n  expect(subtractFlipped(\n    1, 7, 9\n  )).toEqual(6)\n})\n\ntest('function with arity of 3', () => {\n  const updateFlipped = flip(update)\n\n  const result = updateFlipped(\n    8, 0, [ 1, 2, 3 ]\n  )\n  const curriedResult = updateFlipped(8, 0)([ 1, 2, 3 ])\n  const tripleCurriedResult = updateFlipped(8)(0)([ 1, 2, 3 ])\n\n  expect(result).toEqual([ 8, 2, 3 ])\n  expect(curriedResult).toEqual([ 8, 2, 3 ])\n  expect(tripleCurriedResult).toEqual([ 8, 2, 3 ])\n})\n\ntest('function with arity of 4', () => {\n  const testFunction = (\n    a, b, c, d\n  ) => `${ a },${ b },${ c },${ d }`\n\n  const flippedFn = flip(testFunction)\n\n  const result1 = flippedFn(2)(1)(3)(4)\n  const result2 = flippedFn(2)(\n    1, 3, 4\n  )\n  const result3 = flippedFn(2, 1)(3, 4)\n  const result4 = flippedFn(\n    2, 1, 3\n  )(4)\n  const result5 = flippedFn(\n    2, 1, 3, 4\n  )\n\n  const expected = '1,2,3,4'\n\n  expect(result1).toEqual(expected)\n  expect(result2).toEqual(expected)\n  expect(result3).toEqual(expected)\n  expect(result4).toEqual(expected)\n  expect(result5).toEqual(expected)\n})",
    "explanation": "It returns function which calls `fn` with exchanged first and second argument.",
    "example": "const subtractFlip = R.flip(R.subtract)\n\nconst result = [\n  subtractFlip(1,7),\n  R.flip(1,6)\n]  \n// => [6, -6]",
    "typescriptDefinitionTest": "import * as R from 'ramda'\nimport {flip, subtract} from 'rambda'\n\ndescribe('R.flip', () => {\n  it('function with arity of 2', () => {\n    const subtractFlipped = flip(subtract)\n    const result = subtractFlipped(1, 7)\n    const curriedResult = subtractFlipped(1)(7)\n    curriedResult // $ExpectType number\n     \n    // This is wrong\n    // ============================================\n    result // $ExpectType (y: number) => number\n  })\n\n  it('function with arity of 3', () => {\n    function testFunction(a: number, b: string, c: number): string {\n      return `${b}==${(a+c)}`\n    }\n    const flippedTestFunction = flip(testFunction)\n\n    const result = flippedTestFunction(\n      'foo', 1, 2\n    )\n    result // $ExpectType string\n  })\n})\n\ndescribe('Ramda.flip', () => {\n  it('function with arity of 2', () => {\n    const subtractFlipped = R.flip(R.subtract)\n    const result = subtractFlipped(1, 7)\n    const curriedResult = subtractFlipped(1)(7)\n    curriedResult // $ExpectType number\n     \n    // This is wrong\n    // ============================================\n    result // $ExpectType (b: number) => number\n  })\n})",
    "failedRamdaSpecs": "var jsv = require('jsverify');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar funcN = require('./shared/funcN');\ndescribe('flip', function() {\n  it('returns a function which inverts the first two arguments to the supplied function', function() {\n    var f = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    var g = R.flip(f);\n    eq(f('a', 'b', 'c'), 'a b c');\n    eq(g('a', 'b', 'c'), 'b a c');\n  });\n  it('returns a curried function', function() {\n    var f = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    var g = R.flip(f)('a');\n    eq(g('b', 'c'), 'b a c');\n  });\n  it('returns a function with the correct arity', function() {\n    var f2 = function(a, b) {return a + ' ' + b;};\n    var f3 = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    eq(R.flip(f2).length, 2);\n    eq(R.flip(f3).length, 3);\n  });\n});\ndescribe('flip properties', function() {\n  jsv.property('inverts first two arguments', funcN(3), jsv.json, jsv.json, jsv.json, function(f, a, b, c) {\n    var g = R.flip(f);\n    return R.equals(f(a, b, c), g(b, a, c));\n  });\n});",
    "failedSpecsReasons": "rambda flip work only for functions with two arguments",
    "failedSpecsCount": 4
  },
  "forEach": {
    "typing": "forEach<T>(fn: (x: T) => void, list: T[]): T[]",
    "allTypings": "forEach<T>(fn: (x: T) => void, list: T[]): T[];\nforEach<T>(fn: (x: T) => void): (list: T[]) => T[];\nforEach<T>(fn: (x: T) => void, list: ReadonlyArray<T>): ReadonlyArray<T>;\nforEach<T>(fn: (x: T) => void): (list: ReadonlyArray<T>) => ReadonlyArray<T>;\nforEach<T>(fn: (value: T, key: string, obj: { [key: string]: T }) => void, obj: { [key: string]: T }): void;\nforEach<T>(fn: (value: T, key: string, obj: { [key: string]: T }) => void): (obj: { [key: string]: T }) => void;",
    "notes": "It works with objects, unlike `Ramda`.",
    "rambdaSource": "import { map } from './map'\n\nexport function forEach(predicate, list){\n  if (arguments.length === 1) return _list => forEach(predicate, _list)\n\n  map(predicate, list)\n\n  return list\n}",
    "rambdaSpecs": "import { forEach } from './forEach'\nimport { type } from './type'\n\ntest('iterate over object', () => {\n  const obj = {\n    a : 1,\n    b : [ 1, 2 ],\n    c : { d : 7 },\n    f : 'foo',\n  }\n  const result = {}\n  const returned = forEach((\n    val, prop, inputObj\n  ) => {\n    expect(type(inputObj)).toBe('Object')\n    result[ prop ] = `${ prop }-${ type(val) }`\n  })(obj)\n\n  const expected = {\n    a : 'a-Number',\n    b : 'b-Array',\n    c : 'c-Object',\n    f : 'f-String',\n  }\n\n  expect(result).toEqual(expected)\n  expect(returned).toEqual(obj)\n})\n\ntest('happy', () => {\n  const sideEffect = {}\n  forEach(x => sideEffect[ `foo${ x }` ] = x + 10)([ 1, 2 ])\n\n  expect(sideEffect).toEqual({\n    foo1 : 11,\n    foo2 : 12,\n  })\n})\n\ntest('happy 2', () => {\n  const list = [\n    {\n      x : 1,\n      y : 2,\n    },\n    {\n      x : 100,\n      y : 200,\n    },\n    {\n      x : 300,\n      y : 400,\n    },\n    {\n      x : 234,\n      y : 345,\n    },\n  ]\n  const sideEffect = {}\n  const result = forEach(elem => {\n    sideEffect[ elem.x ] = elem.y\n  }, list)\n  const expectedSideEffect = {\n    1   : 2,\n    100 : 200,\n    300 : 400,\n    234 : 345,\n  }\n\n  expect(sideEffect).toEqual(expectedSideEffect)\n  expect(result).toEqual(list)\n})\n\ntest('with empty list', () => {\n  const list = []\n  const result = forEach(x => x * x)(list)\n\n  expect(result).toEqual(list)\n})\n\ntest('returns the input', () => {\n  const list = [ 1, 2, 3 ]\n  const result = forEach(x => x * x)(list)\n\n  expect(result).toEqual(list)\n})\n\ntest('pass index as second argument', () => {\n  const list = [ 11, 21, 31 ]\n  const indexes = []\n  const result = forEach((x, i) => indexes.push(i))(list)\n\n  expect(indexes).toEqual([ 0, 1, 2 ])\n})",
    "explanation": "It applies `iterable` function over all members of `list` and returns `list`.",
    "example": "const sideEffect = {}\nconst result = R.forEach(\n  x => sideEffect[`foo${x}`] = x\n)([1, 2])\n\nsideEffect //=> {foo1: 1, foo2: 2}\nresult //=> [1, 2]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('forEach', function() {\n  var list = [{x: 1, y: 2}, {x: 100, y: 200}, {x: 300, y: 400}, {x: 234, y: 345}];\n  it('dispatches to `forEach` method', function() {\n    var dispatched = false;\n    var fn = function() {};\n    function DummyList() {}\n    DummyList.prototype.forEach = function(callback) {\n      dispatched = true;\n      eq(callback, fn);\n    };\n    R.forEach(fn, new DummyList());\n    eq(dispatched, true);\n  });\n});",
    "failedSpecsReasons": "ramda method dispatches to `forEach` method",
    "failedSpecsCount": 1
  },
  "fromPairs": {
    "typing": "fromPairs<V>(listOfPairs: KeyValuePair<string, V>[]): { [index: string]: V }",
    "allTypings": "fromPairs<V>(listOfPairs: KeyValuePair<string, V>[]): { [index: string]: V };\nfromPairs<V>(listOfPairs: KeyValuePair<number, V>[]): { [index: number]: V };",
    "rambdaSource": "export function fromPairs(listOfPairs){\n  const toReturn = {}\n  listOfPairs.forEach(([ prop, value ]) => toReturn[ prop ] = value)\n\n  return toReturn\n}",
    "rambdaSpecs": "import { fromPairs } from './fromPairs'\n\nconst list = [\n  [ 'a', 1 ],\n  [ 'b', 2 ],\n  [ 'c', [ 3, 4 ] ],\n]\nconst expected = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\n\ntest('happy', () => {\n  expect(fromPairs(list)).toEqual(expected)\n})",
    "explanation": "It transforms a `listOfPairs` to an object.",
    "example": "const listOfPairs = [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', [ 3, 4 ] ] ]\nconst expected = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\n\nconst result = R.fromPairs(listOfPairs)\n// => `result` is equal to `expected`"
  },
  "groupBy": {
    "typing": "groupBy<T>(groupFn: (a: T) => string, list: ReadonlyArray<T>): { [index: string]: T[] }",
    "allTypings": "groupBy<T>(groupFn: (a: T) => string, list: ReadonlyArray<T>): { [index: string]: T[] };\ngroupBy<T>(groupFn: (a: T) => string): (list: ReadonlyArray<T>) => { [index: string]: T[] };",
    "rambdaSource": "export function groupBy(groupFn, list){\n  if (arguments.length === 1) return _list => groupBy(groupFn, _list)\n\n  const result = {}\n  for (let i = 0; i < list.length; i++){\n    const item = list[ i ]\n    const key = groupFn(item)\n\n    if (!result[ key ]){\n      result[ key ] = []\n    }\n\n    result[ key ].push(item)\n  }\n\n  return result\n}",
    "rambdaSpecs": "import { groupBy } from './groupBy'\nimport { prop } from './prop'\n\ntest('groupBy', () => {\n  const list = [\n    {\n      age  : 12,\n      name : 'john',\n    },\n    {\n      age  : 12,\n      name : 'jack',\n    },\n    {\n      age  : 24,\n      name : 'mary',\n    },\n    {\n      age  : 24,\n      name : 'steve',\n    },\n  ]\n  const expectedResult = {\n    12 : [\n      {\n        age  : 12,\n        name : 'john',\n      },\n      {\n        age  : 12,\n        name : 'jack',\n      },\n    ],\n    24 : [\n      {\n        age  : 24,\n        name : 'mary',\n      },\n      {\n        age  : 24,\n        name : 'steve',\n      },\n    ],\n  }\n\n  expect(groupBy(prop('age'))(list)).toEqual(expectedResult)\n  expect(groupBy(prop('age'), list)).toEqual(expectedResult)\n})",
    "explanation": "It splits `list` according to a provided `groupFn` function and returns an object.",
    "example": "const list = [ 'a', 'b', 'aa', 'bb' ]\nconst groupFn = x => x.length\n\nconst result = R.groupBy(groupFn, list)\n// => { '1': ['a', 'b'], '2': ['aa', 'bb'] }",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar _isTransformer = require('rambda/internal/_isTransformer');\n\ndescribe('groupBy', function() {\n  it('dispatches on transformer objects in list position', function() {\n    var byType = R.prop('type');\n    var xf = {\n      '@@transducer/init': function() { return {}; },\n      '@@transducer/result': function(x) { return x; },\n      '@@transducer/step': R.mergeRight\n    };\n    eq(_isTransformer(R.groupBy(byType, xf)), true);\n  });\n});",
    "failedSpecsReasons": "ramda support transforms",
    "failedSpecsCount": 1
  },
  "groupWith": {
    "typing": "groupWith<T>(compareFn: (x: T, y: T) => boolean): (list: ReadonlyArray<T>) => T[][]",
    "allTypings": "groupWith<T>(compareFn: (x: T, y: T) => boolean): (list: ReadonlyArray<T>) => T[][];\ngroupWith<T>(compareFn: (x: T, y: T) => boolean, list: ReadonlyArray<T>): T[][];\ngroupWith<T>(compareFn: (x: T, y: T) => boolean, list: string): string[];",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function groupWith(compareFn, list){\n  if (!_isArray(list)) throw new TypeError('list.reduce is not a function')\n\n  const clone = list.slice()\n\n  if (list.length === 1) return [ clone ]\n\n  const toReturn = []\n  let holder = []\n\n  clone.reduce((\n    prev, current, i\n  ) => {\n    if (i === 0) return current\n\n    const okCompare = compareFn(prev, current)\n    const holderIsEmpty = holder.length === 0\n    const lastCall = i === list.length - 1\n\n    if (okCompare){\n      if (holderIsEmpty) holder.push(prev)\n      holder.push(current)\n      if (lastCall) toReturn.push(holder)\n\n      return current\n    }\n\n    if (holderIsEmpty){\n      toReturn.push([ prev ])\n      if (lastCall) toReturn.push([ current ])\n\n      return current\n    }\n\n    toReturn.push(holder)\n    if (lastCall) toReturn.push([ current ])\n    holder = []\n\n    return current\n  }, undefined)\n\n  return toReturn\n}",
    "rambdaSpecs": "import { equals } from './equals'\nimport { groupWith } from './groupWith'\n\ntest('issue is fixed', () => {\n  const result = groupWith(equals, [ 1, 2, 2, 3 ])\n  const expected = [ [ 1 ], [ 2, 2 ], [ 3 ] ]\n  expect(result).toEqual(expected)\n})\n\ntest('long list', () => {\n  const result = groupWith(equals, [\n    0,\n    1,\n    1,\n    2,\n    3,\n    5,\n    8,\n    13,\n    21,\n    21,\n    21,\n    1,\n    2,\n  ])\n\n  const expected = [\n    [ 0 ],\n    [ 1, 1 ],\n    [ 2 ],\n    [ 3 ],\n    [ 5 ],\n    [ 8 ],\n    [ 13 ],\n    [ 21, 21, 21 ],\n    [ 1 ],\n    [ 2 ],\n  ]\n  expect(result).toEqual(expected)\n})\n\ntest('readme example', () => {\n  const list = [ 4, 3, 6, 2, 2, 1 ]\n\n  const result = groupWith((a, b) => a - b === 1, list)\n  const expected = [ [ 4, 3 ], [ 6 ], [ 2 ], [ 2, 1 ] ]\n  expect(result).toEqual(expected)\n})\n\ntest('throw with string as input', () => {\n  expect(() => groupWith(equals, 'Mississippi')).toThrowWithMessage(TypeError,\n    'list.reduce is not a function')\n})\n\nconst isConsecutive = function (a, b){\n  return a + 1 === b\n}\n\ntest('fix coverage', () => {\n  expect(groupWith(isConsecutive, [ 1, 2, 3, 0 ])).toEqual([ [ 1, 2, 3 ], [ 0 ] ])\n})\n\ntest('from ramda 0', () => {\n  expect(groupWith(equals, [])).toEqual([])\n  expect(groupWith(isConsecutive, [])).toEqual([])\n})\n\ntest('from ramda 1', () => {\n  expect(groupWith(isConsecutive, [ 4, 3, 2, 1 ])).toEqual([\n    [ 4 ],\n    [ 3 ],\n    [ 2 ],\n    [ 1 ],\n  ])\n})\n\ntest('from ramda 2', () => {\n  expect(groupWith(isConsecutive, [ 1, 2, 3, 4 ])).toEqual([ [ 1, 2, 3, 4 ] ])\n})\n\ntest('from ramda 3', () => {\n  expect(groupWith(isConsecutive, [ 1, 2, 2, 3 ])).toEqual([\n    [ 1, 2 ],\n    [ 2, 3 ],\n  ])\n  expect(groupWith(isConsecutive, [ 1, 2, 9, 3, 4 ])).toEqual([\n    [ 1, 2 ],\n    [ 9 ],\n    [ 3, 4 ],\n  ])\n})\n\ntest('list with single item', () => {\n  const result = groupWith(equals, [ 0 ])\n\n  const expected = [ [ 0 ] ]\n  expect(result).toEqual(expected)\n})",
    "explanation": "It returns separated version of `list`, where separation is done with equality `compareFn` function.",
    "example": "const compareFn = (x, y) => x === y\nconst list = [1, 2, 2, 1, 1, 2]\n\nconst result = R.groupWith(isConsecutive, list)\n// => [[1], [2,2], [1,1], [2]]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('groupWith', function() {\n  it('can be turned into the original list through concatenation', function() {\n    var list = [1, 1, 2, 3, 4, 4, 5, 5];\n    eq(R.unnest(R.groupWith(R.equals, list)), list);\n    eq(R.unnest(R.groupWith(R.complement(R.equals), list)), list);\n    eq(R.unnest(R.groupWith(R.T, list)), list);\n    eq(R.unnest(R.groupWith(R.F, list)), list);\n  });\n  it('also works on strings', function() {\n    eq(R.groupWith(R.equals)('Mississippi'), ['M','i','ss','i','ss','i','pp','i']);\n  });\n});"
  },
  "has": {
    "typing": "has<T>(prop: string, obj: T): boolean",
    "allTypings": "has<T>(prop: string, obj: T): boolean;\nhas(prop: string): <T>(obj: T) => boolean;",
    "rambdaSource": "export function has(prop, obj){\n  if (arguments.length === 1) return _obj => has(prop, _obj)\n\n  if (!obj) return false\n\n  return obj[ prop ] !== undefined\n}",
    "rambdaSpecs": "import { has } from './has'\n\ntest('happy', () => {\n  expect(has('a')({ a : 1 })).toBeTrue()\n  expect(has('b', { a : 1 })).toBeFalse()\n})\n\ntest('with non-object', () => {\n  expect(has('a', undefined)).toEqual(false)\n  expect(has('a', null)).toEqual(false)\n  expect(has('a', true)).toEqual(false)\n  expect(has('a', '')).toEqual(false)\n  expect(has('a', /a/)).toEqual(false)\n})",
    "explanation": "It returns `true` if `obj` has property `prop`.",
    "example": "const obj = {a: 1}\n\nconst result = [\n  R.has('a', obj),\n  R.has('b', obj)\n]\n// => [true, false]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('has', function() {\n  var fred = {name: 'Fred', age: 23};\n  var anon = {age: 99};\n  it('does not check properties from the prototype chain', function() {\n    var Person = function() {};\n    Person.prototype.age = function() {};\n    var bob = new Person();\n    eq(R.has('age', bob), false);\n  });\n});",
    "failedSpecsReasons": "rambda does check properties from the prototype chain",
    "failedSpecsCount": 1
  },
  "hasPath": {
    "typing": "hasPath<T>(\n  path: string | string[],\n  input: object\n): boolean",
    "allTypings": "hasPath<T>(\n  path: string | string[],\n  input: object\n): boolean;\nhasPath<T>(\n  path: string | string[]\n): (input: object) => boolean;",
    "rambdaSource": "import { path } from './path'\n\nexport function hasPath(maybePath, obj){\n  if (arguments.length === 1){\n    return objHolder => hasPath(maybePath, objHolder)\n  }\n\n  return path(maybePath, obj) !== undefined\n}",
    "rambdaSpecs": "import { hasPath } from './hasPath'\n\ntest('when true', () => {\n  const path = 'a.b'\n  const obj = { a : { b : [] } }\n\n  const result = hasPath(path)(obj)\n  const expectedResult = true\n\n  expect(result).toEqual(expectedResult)\n})\n\ntest('when false', () => {\n  const path = 'a.b'\n  const obj = {}\n\n  const result = hasPath(path, obj)\n  const expectedResult = false\n\n  expect(result).toEqual(expectedResult)\n})",
    "explanation": "It will return true, if `input` object has truthy `path`(calculated with `R.path`).",
    "example": "const path = 'a.b'\nconst pathAsArray = ['a', 'b']\nconst obj = {a: {b: []}}\n\nconst result = [\n  R.hasPath(path, obj),\n  R.hasPath(pathAsArray, obj),\n  R.hasPath('a.c', obj),\n]\n// => [true, true, false]"
  },
  "head": {
    "typing": "head<T>(listOrString: T[]): T | undefined",
    "allTypings": "head<T>(listOrString: T[]): T | undefined;\nhead(listOrString: string): string;",
    "rambdaSource": "export function head(listOrString){\n  if (typeof listOrString === 'string') return listOrString[ 0 ] || ''\n\n  return listOrString[ 0 ]\n}",
    "rambdaSpecs": "import { head } from './head'\n\ntest('head', () => {\n  expect(head([ 'fi', 'fo', 'fum' ])).toEqual('fi')\n  expect(head([])).toEqual(undefined)\n  expect(head('foo')).toEqual('f')\n  expect(head('')).toEqual('')\n})",
    "explanation": "It returns the first element of `listOrString`.",
    "example": "const result = [\n  R.head([1, 2, 3]),\n  R.head('foo') \n]\n// => [1, 'f']"
  },
  "identical": {
    "typing": "identical<T>(a: T, b: T): boolean",
    "allTypings": "identical<T>(a: T, b: T): boolean;\nidentical<T>(a: T): (b: T) => boolean;",
    "notes": "Values are identical if they reference the same memory. `NaN` is identical to `NaN`; `0` and `-0` are not identical.",
    "rambdaSource": "import _objectIs from './_internals/_objectIs'\n\nexport function identical(a, b){\n  if (arguments.length === 1) return _b => identical(a, _b)\n\n  return _objectIs(a, b)\n}",
    "rambdaSpecs": "import { F, T } from '../rambda'\nimport { _isInteger } from './_internals/_isInteger'\nimport { _objectIs } from './_internals/_objectIs'\nimport { identical } from './identical'\n\ntest('with boolean', () => {\n  expect(F()).toBe(false)\n  expect(T()).toBe(true)\n})\n\ntest('internal isInteger', () => {\n  expect(_isInteger(1)).toBe(true)\n  expect(_isInteger(0.3)).toBe(false)\n})\n\ntest('internal objectIs', () => {\n  expect(_objectIs(1, 1)).toBe(true)\n  expect(_objectIs(NaN, NaN)).toBe(true)\n})\n\ntest('identical', () => {\n  const a = {}\n\n  expect(identical(100)(100)).toEqual(true)\n  expect(identical(100, '100')).toEqual(false)\n  expect(identical('string', 'string')).toEqual(true)\n  expect(identical([], [])).toEqual(false)\n  expect(identical(a, a)).toEqual(true)\n  expect(identical(undefined, undefined)).toEqual(true)\n  expect(identical(null, undefined)).toEqual(false)\n})",
    "explanation": "It returns `true` if its arguments `a` and `b` are identical.\n\nOtherwise, it returns `false`.",
    "example": "const obj = {a: 1};\nR.identical(obj, obj); //=> true\nR.identical(1, 1); //=> true\nR.identical(1, '1'); //=> false\nR.identical([], []); //=> false\nR.identical(0, -0); //=> false\nR.identical(NaN, NaN); //=> true"
  },
  "identity": {
    "typing": "identity<T>(input: T): T",
    "allTypings": "identity<T>(input: T): T;",
    "notes": "Logic",
    "rambdaSource": "export function identity(input){\n  return input\n}",
    "rambdaSpecs": "import { identity } from './identity'\n\ntest('happy', () => {\n  expect(identity(7)).toEqual(7)\n  expect(identity(true)).toEqual(true)\n  expect(identity({ a : 1 })).toEqual({ a : 1 })\n})",
    "explanation": "It just passes back the supplied `input` argument.",
    "example": "R.identity(7) // => 7"
  },
  "ifElse": {
    "typing": "ifElse(condition: Pred, onTrue: Arity1Fn, onFalse: Arity1Fn): Arity1Fn",
    "allTypings": "ifElse(condition: Pred, onTrue: Arity1Fn, onFalse: Arity1Fn): Arity1Fn;\nifElse(condition: Pred, onTrue: Arity2Fn, onFalse: Arity2Fn): Arity2Fn;",
    "rambdaSource": "import { curry } from './curry'\n\nfunction ifElseFn(\n  condition, onTrue, onFalse\n){\n  return (...input) => {\n    const conditionResult =\n      typeof condition === 'boolean' ? condition : condition(...input)\n\n    if (conditionResult === true){\n      return onTrue(...input)\n    }\n\n    return onFalse(...input)\n  }\n}\n\nexport const ifElse = curry(ifElseFn)",
    "rambdaSpecs": "import { always } from './always'\nimport { has } from './has'\nimport { identity } from './identity'\nimport { ifElse } from './ifElse'\nimport { prop } from './prop'\n\nconst condition = has('foo')\nconst v = function (a){\n  return typeof a === 'number'\n}\nconst t = function (a){\n  return a + 1\n}\nconst ifFn = x => prop('foo', x).length\nconst elseFn = () => false\n\ntest('happy', () => {\n  const fn = ifElse(condition, ifFn)(elseFn)\n\n  expect(fn({ foo : 'bar' })).toEqual(3)\n  expect(fn({ fo : 'bar' })).toEqual(false)\n})\n\ntest('ramda spec', () => {\n  const ifIsNumber = ifElse(v)\n  expect(ifIsNumber(t, identity)(15)).toEqual(16)\n  expect(ifIsNumber(t, identity)('hello')).toEqual('hello')\n})\n\ntest('pass all arguments', () => {\n  const identity = function (a){\n    return a\n  }\n  const v = function (){\n    return true\n  }\n  const onTrue = function (a, b){\n    expect(a).toEqual(123)\n    expect(b).toEqual('abc')\n  }\n  ifElse(\n    v, onTrue, identity\n  )(123, 'abc')\n})\n\ntest('accept constant as condition', () => {\n  const fn = ifElse(true)(always(true))(always(false))\n\n  expect(fn()).toEqual(true)\n})\n\ntest('accept constant as condition - case 2', () => {\n  const fn = ifElse(\n    false, always(true), always(false)\n  )\n\n  expect(fn()).toEqual(false)\n})\n\ntest('curry 1', () => {\n  const fn = ifElse(condition, ifFn)(elseFn)\n\n  expect(fn({ foo : 'bar' })).toEqual(3)\n  expect(fn({ fo : 'bar' })).toEqual(false)\n})\n\ntest('curry 2', () => {\n  const fn = ifElse(condition)(ifFn)(elseFn)\n\n  expect(fn({ foo : 'bar' })).toEqual(3)\n  expect(fn({ fo : 'bar' })).toEqual(false)\n})",
    "explanation": "It expects `condition`, `onTrue` and `onFalse` functions as inputs and it returns a new function with example name of `fn`. \n\nWhen `fn`` is called with `input` argument, it will return either `onTrue(input)` or `onFalse(input)` depending on `condition(input)` evaluation.",
    "example": "const fn = R.ifElse(\n x => x>10,\n x => x*2,\n x => x*10\n)\n\nconst result = [ fn(8), fn(18) ]\n// => [80, 36]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('ifElse', function() {\n  var t = function(a) { return a + 1; };\n  var identity = function(a) { return a; };\n  var isArray = function(a) { return Object.prototype.toString.call(a) === '[object Array]'; };\n  it('returns a function whose arity equals the max arity of the three arguments to `ifElse`', function() {\n    function a0() { return 0; }\n    function a1(x) { return x; }\n    function a2(x, y) { return x + y; }\n    eq(R.ifElse(a0, a1, a2).length, 2);\n    eq(R.ifElse(a0, a2, a1).length, 2);\n    eq(R.ifElse(a1, a0, a2).length, 2);\n    eq(R.ifElse(a1, a2, a0).length, 2);\n    eq(R.ifElse(a2, a0, a1).length, 2);\n    eq(R.ifElse(a2, a1, a0).length, 2);\n  });\n  it('returns a curried function', function() {\n    var v = function(a) { return typeof a === 'number'; };\n    var ifIsNumber = R.ifElse(v);\n    eq(ifIsNumber(t, identity)(15), 16);\n    eq(ifIsNumber(t, identity)('hello'), 'hello');\n    var fn = R.ifElse(R.gt, R.subtract, R.add);\n    eq(fn(2)(7), 9);\n    eq(fn(2, 7), 9);\n    eq(fn(7)(2), 5);\n    eq(fn(7, 2), 5);\n  });\n});",
    "failedSpecsReasons": "rambda doesn't return a curried function",
    "failedSpecsCount": 2
  },
  "inc": {
    "typing": "inc(x: number): number",
    "allTypings": "inc(x: number): number;",
    "rambdaSource": "export const inc = x => x + 1",
    "rambdaSpecs": "import { inc } from './inc'\n\ntest('happy', () => {\n  expect(inc(1)).toBe(2)\n})",
    "explanation": "It increments a number.",
    "example": "R.inc(1) // => 2"
  },
  "includes": {
    "typing": "includes(valueToFind: string, input: ReadonlyArray<string> | string): boolean",
    "allTypings": "includes(valueToFind: string, input: ReadonlyArray<string> | string): boolean;\nincludes(valueToFind: string): (input: ReadonlyArray<string> | string) => boolean;\nincludes<T>(valueToFind: T, input: ReadonlyArray<T>): boolean;\nincludes<T>(valueToFind: T): (input: ReadonlyArray<T>) => boolean;",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\nimport { equals } from './equals'\n\nexport function includes(valueToFind, input){\n  if (arguments.length === 1) return _input => includes(valueToFind, _input)\n\n  if (typeof input === 'string'){\n    return input.includes(valueToFind)\n  }\n  if (!_isArray(input)) return false\n\n  let index = -1\n\n  while (++index < input.length){\n    if (equals(input[ index ], valueToFind)){\n      return true\n    }\n  }\n\n  return false\n}",
    "rambdaSpecs": "import R from 'ramda'\n\nimport { includes } from './includes'\n\ntest('includes with string', () => {\n  const str = 'more is less'\n\n  expect(includes('less')(str)).toBeTrue()\n  expect(R.includes('less')(str)).toBeTrue()\n  expect(includes('never', str)).toBeFalse()\n  expect(R.includes('never', str)).toBeFalse()\n})\n\ntest('includes with array', () => {\n  const arr = [ 1, 2, 3 ]\n\n  expect(includes(2)(arr)).toBeTrue()\n  expect(R.includes(2)(arr)).toBeTrue()\n\n  expect(includes(4, arr)).toBeFalse()\n  expect(R.includes(4, arr)).toBeFalse()\n})\n\ntest('return false if input is falsy', () => {\n  expect(includes(2, null)).toBeFalse()\n  expect(() => R.includes(2, null)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'indexOf\\' of null')\n  expect(includes(4, undefined)).toBeFalse()\n  expect(() => R.includes(4, undefined)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'indexOf\\' of undefined')\n})",
    "explanation": "If `input` is string, then this method work as native `String.includes`.\n\nIf `input` is array, then `R.equals` is used to define if `valueToFind` belongs to the list.",
    "example": "const result = [\n  R.includes('oo', 'foo'),\n  R.includes({a: 1}, [{a: 1}])\n]\n// => [true, true ]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('includes', function() {\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.includes(0, [-0]), false);\n    eq(R.includes(-0, [0]), false);\n    eq(R.includes(NaN, [NaN]), true);\n    eq(R.includes(new Just([42]), [new Just([42])]), true);\n  });\n});",
    "failedSpecsReasons": "ramda method pass to `equals` method if available",
    "failedSpecsCount": 1
  },
  "indexBy": {
    "typing": "indexBy<T>(condition: (x: T) => string, list: ReadonlyArray<T>): { [key: string]: T }",
    "allTypings": "indexBy<T>(condition: (x: T) => string, list: ReadonlyArray<T>): { [key: string]: T };\nindexBy<T>(condition: string, list: ReadonlyArray<T>): { [key: string]: T };\nindexBy<T>(condition: (x: T) => string): (list: ReadonlyArray<T>) => { [key: string]: T };\nindexBy<T>(condition: string): (list: ReadonlyArray<T>) => { [key: string]: T };",
    "rambdaSource": "import { path } from './path'\n\nfunction indexByPath(pathInput, list){\n  const toReturn = {}\n  for (let i = 0; i < list.length; i++){\n    const item = list[ i ]\n    toReturn[ path(pathInput, item) ] = item\n  }\n\n  return toReturn\n}\n\nexport function indexBy(condition, list){\n  if (arguments.length === 1){\n    return _list => indexBy(condition, _list)\n  }\n\n  if (typeof condition === 'string'){\n    return indexByPath(condition, list)\n  }\n\n  const toReturn = {}\n  for (let i = 0; i < list.length; i++){\n    const item = list[ i ]\n    toReturn[ condition(item) ] = item\n  }\n\n  return toReturn\n}",
    "rambdaSpecs": "import { indexBy } from './indexBy'\nimport { prop } from './prop'\n\ntest('happy', () => {\n  const list = [\n    { id : 1 },\n    {\n      id : 1,\n      a  : 2,\n    },\n    { id : 2 },\n    { id : 10 },\n    { id : 'a' },\n  ]\n\n  expect(indexBy(prop('id'))(list)).toEqual({\n    1 : {\n      id : 1,\n      a  : 2,\n    },\n    2  : { id : 2 },\n    10 : { id : 10 },\n    a  : { id : 'a' },\n  })\n})\n\ntest('with string as condition', () => {\n  const list = [ { id : 1 }, { id : 2 }, { id : 10 }, { id : 'a' } ]\n  const standardResult = indexBy(obj => obj.id, list)\n  const suggestionResult = indexBy('id', list)\n\n  expect(standardResult).toEqual(suggestionResult)\n})\n\ntest('with string - bad path', () => {\n  const list = [\n    {\n      a : {\n        b : 1,\n        c : 2,\n      },\n    },\n    { a : { c : 4 } },\n    {},\n    {\n      a : {\n        b : 10,\n        c : 20,\n      },\n    },\n  ]\n\n  const result = indexBy('a.b', list)\n  const expected = {\n    1 : {\n      a : {\n        b : 1,\n        c : 2,\n      },\n    },\n    10 : {\n      a : {\n        b : 10,\n        c : 20,\n      },\n    },\n    undefined : {},\n  }\n\n  expect(result).toEqual(expected)\n})",
    "explanation": "It generates object with properties provided by `condition` and values provided by `list` array.\n\nIf `condition` is a function, then all list members are passed through it.\n\nIf `condition` is a string, then all list members are passed through `R.path(condition)`.",
    "example": "const list = [ {id: 10}, {id: 20} ]\n\nconst withFunction = R.indexBy(\n  x => x.id,\n  list\n)\nconst withString = R.indexBy(\n  'id',\n  list\n)\nconst result = [\n  withFunction, \n  R.equals(withFunction, withString)\n]\n// => [ { 10: {id: 10}, 20: {id: 20} }, true ]",
    "typescriptDefinitionTest": "import {indexBy} from 'rambda'\n\nconst list = [{a: {b: '1'}}, {a: {c: '2'}}, {a: {b: '3'}}]\n\ndescribe('indexBy', () => {\n  it('happy', () => {\n    const result = indexBy<any>(x => x.a.b, list)\n    const resultCurried = indexBy<any>(x => x.a.b)(list)\n    result // $ExpectType { [key: string]: any; }\n    resultCurried // $ExpectType { [key: string]: any; }\n  })\n\n  it('with string', () => {\n    const result = indexBy<any>('a.b', list)\n    const resultCurried = indexBy<any>('a.b')(list)\n    result // $ExpectType { [key: string]: any; }\n    resultCurried // $ExpectType { [key: string]: any; }\n  })\n\n  it('with interface', () => {\n    interface Foo {\n      a: string,\n    }\n    const interfaceList = [{a: 'foo'}, {a: 'bar'}]\n    const result = indexBy<Foo>(x => {\n      x.a // $ExpectType string\n      return x.a\n    }, interfaceList)\n    const resultCurried = indexBy<Foo>(x => {\n      x.a // $ExpectType string\n      return x.a\n    })(interfaceList)\n    result // $ExpectType { [key: string]: Foo; }\n    resultCurried // $ExpectType { [key: string]: Foo; }\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('indexBy', function() {\n  it('can act as a transducer', function() {\n    var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];\n    var transducer = R.compose(\n      R.indexBy(R.prop('id')),\n      R.map(R.pipe(\n        R.adjust(0, R.toUpper),\n        R.adjust(1, R.omit(['id']))\n      )));\n    var result = R.into({}, transducer, list);\n    eq(result, {ABC: {title: 'B'}, XYZ: {title: 'A'}});\n  });\n});",
    "failedSpecsReasons": "ramda method can act as a transducer",
    "failedSpecsCount": 1
  },
  "indexOf": {
    "typing": "indexOf<T>(valueToFind: T, list: ReadonlyArray<T>): number",
    "allTypings": "indexOf<T>(valueToFind: T, list: ReadonlyArray<T>): number;\nindexOf<T>(valueToFind: T): (list: ReadonlyArray<T>) => number;",
    "rambdaSource": "export function indexOf(valueToFind, list){\n  if (arguments.length === 1){\n    return _list => indexOf(valueToFind, _list)\n  }\n\n  let index = -1\n  const { length } = list\n\n  while (++index < length){\n    if (list[ index ] === valueToFind){\n      return index\n    }\n  }\n\n  return -1\n}",
    "rambdaSpecs": "import { indexOf } from './indexOf'\n\ntest('indexOf', () => {\n  expect(indexOf(3, [ 1, 2, 3, 4 ])).toEqual(2)\n\n  expect(indexOf(10)([ 1, 2, 3, 4 ])).toEqual(-1)\n})",
    "explanation": "It returns the index of the first element of `list` equals to `valueToFind`.\n\nIf there is no such element, it returns `-1`.",
    "example": "const list = [0, 1, 2, 3]\n\nconst result = [\n  R.indexOf(2, list),\n  R.indexOf(0, list)\n]\n// => [2, -1]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('indexOf', function() {\n  var input = [1, 2, 3, 4, 5];\n  var list = [1, 2, 3];\n  list[-2] = 4; // Throw a wrench in the gears by assigning a non-valid array index as object property.\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.indexOf(0, [-0]), -1);\n    eq(R.indexOf(-0, [0]), -1);\n    eq(R.indexOf(NaN, [NaN]), 0);\n    eq(R.indexOf(new Just([42]), [new Just([42])]), 0);\n  });\n  it('dispatches to `indexOf` method', function() {\n    function Empty() {}\n    Empty.prototype.indexOf = R.always(-1);\n    function List(head, tail) {\n      this.head = head;\n      this.tail = tail;\n    }\n    List.prototype.indexOf = function(x) {\n      var idx = this.tail.indexOf(x);\n      return this.head === x ? 0 : idx >= 0 ? 1 + idx : -1;\n    };\n    var list = new List('b',\n      new List('a',\n        new List('n',\n          new List('a',\n            new List('n',\n              new List('a',\n                new Empty()\n              )\n            )\n          )\n        )\n      )\n    );\n    eq(R.indexOf('a', 'banana'), 1);\n    eq(R.indexOf('x', 'banana'), -1);\n    eq(R.indexOf('a', list), 1);\n    eq(R.indexOf('x', list), -1);\n  });\n});",
    "failedSpecsReasons": "ramda method dispatches to `indexOf` method",
    "failedSpecsCount": 2
  },
  "init": {
    "typing": "init<T>(listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "init<T>(listOrString: ReadonlyArray<T>): T[];\ninit(listOrString: string): string;",
    "rambdaSource": "import baseSlice from './_internals/baseSlice'\n\nexport function init(listOrString){\n  if (typeof listOrString === 'string') return listOrString.slice(0, -1)\n\n  return listOrString.length ? baseSlice(\n    listOrString, 0, -1\n  ) : []\n}",
    "rambdaSpecs": "import { init } from './init'\n\ntest('with array', () => {\n  expect(init([ 1, 2, 3 ])).toEqual([ 1, 2 ])\n  expect(init([ 1, 2 ])).toEqual([ 1 ])\n  expect(init([ 1 ])).toEqual([])\n  expect(init([])).toEqual([])\n  expect(init([])).toEqual([])\n  expect(init([ 1 ])).toEqual([])\n})\n\ntest('with string', () => {\n  expect(init('foo')).toEqual('fo')\n  expect(init('f')).toEqual('')\n  expect(init('')).toEqual('')\n})",
    "explanation": "It returns all but the last element of `listOrString`.",
    "example": "const result = [\n  R.init([1, 2, 3]) , \n  R.init('foo')  // => 'fo'\n]\n// => [[1, 2], 'fo']"
  },
  "intersection": {
    "typing": "intersection<T>(listA: ReadonlyArray<T>, listB: ReadonlyArray<T>): T[]",
    "allTypings": "intersection<T>(listA: ReadonlyArray<T>, listB: ReadonlyArray<T>): T[];\nintersection<T>(listA: ReadonlyArray<T>): (listB: ReadonlyArray<T>) => T[];",
    "rambdaSource": "import { filter } from './filter'\nimport { includes } from './includes'\n\nexport function intersection(listA, listB){\n  if (arguments.length === 1) return _list => intersection(listA, _list)\n\n  return filter(value => includes(value, listB), listA)\n}",
    "rambdaSpecs": "import { intersection } from './intersection'\n\ntest('intersection', () => {\n  const list1 = [ 1, 2, 3, 4 ]\n  const list2 = [ 3, 4, 5, 6 ]\n  expect(intersection(list1)(list2)).toEqual([ 3, 4 ])\n\n  expect(intersection([], [])).toEqual([])\n})\n\ntest('intersection with objects', () => {\n  const list1 = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 4 } ]\n  const list2 = [ { id : 3 }, { id : 4 }, { id : 5 }, { id : 6 } ]\n  expect(intersection(list1)(list2)).toEqual([ { id : 3 }, { id : 4 } ])\n})",
    "explanation": "It loops throw `listA` and `listB` and returns the intersection of the two according to `R.equals`.",
    "example": "const listA = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 4 } ]\nconst listB = [ { id : 3 }, { id : 4 }, { id : 5 }, { id : 6 } ]\n\nconst result = intersection(listA, listB)\n// => [{ id : 3 }, { id : 4 }]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('intersection', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  it('does not allow duplicates in the output even if the input lists had duplicates', function() {\n    eq(R.intersection(M2, N2), [3, 4]);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.intersection([0], [-0]).length, 0);\n    eq(R.intersection([-0], [0]).length, 0);\n    eq(R.intersection([NaN], [NaN]).length, 1);\n    eq(R.intersection([new Just([42])], [new Just([42])]).length, 1);\n  });\n});"
  },
  "intersperse": {
    "typing": "intersperse<T>(separator: T, list: ReadonlyArray<T>): T[]",
    "allTypings": "intersperse<T>(separator: T, list: ReadonlyArray<T>): T[];\nintersperse<T>(separator: T): (list: ReadonlyArray<T>) => T[];",
    "rambdaSource": "export function intersperse(separator, list){\n  if (arguments.length === 1) return _list => intersperse(separator, _list)\n\n  let index = -1\n  const len = list.length\n  const willReturn = []\n\n  while (++index < len){\n    if (index === len - 1){\n      willReturn.push(list[ index ])\n    } else {\n      willReturn.push(list[ index ], separator)\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { intersperse } from './intersperse'\n\ntest('intersperse', () => {\n  const list = [ { id : 1 }, { id : 2 }, { id : 10 }, { id : 'a' } ]\n  expect(intersperse('!', list)).toEqual([\n    { id : 1 },\n    '!',\n    { id : 2 },\n    '!',\n    { id : 10 },\n    '!',\n    { id : 'a' },\n  ])\n\n  expect(intersperse('!')([])).toEqual([])\n})",
    "explanation": "It adds a `separator` between members of `list`.",
    "example": "const list = [ 0, 1, 2, 3 ]\nconst separator = '|'\nconst result = intersperse(separator, list)\n// => [0, '|', 1, '|', 2, '|', 3]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('intersperse', function() {\n  it('dispatches', function() {\n    var obj = {intersperse: function(x) { return 'override ' + x; }};\n    eq(R.intersperse('x', obj), 'override x');\n  });\n});"
  },
  "is": {
    "typing": "is(targetPrototype: any, x: any): boolean",
    "allTypings": "is(targetPrototype: any, x: any): boolean;\nis(targetPrototype: any): (x: any) => boolean;",
    "rambdaSource": "export function is(targetPrototype, x){\n  if (arguments.length === 1) return _x => is(targetPrototype, _x)\n\n  return (\n    x != null && x.constructor === targetPrototype ||\n    x instanceof targetPrototype\n  )\n}",
    "rambdaSpecs": "import { is } from './is'\n\ntest('works with built-in types', () => {\n  expect(is(Array, undefined)).toBeFalse()\n  expect(is(Array)([])).toBeTrue()\n  expect(is(Boolean, new Boolean(false))).toBeTrue()\n  expect(is(Date, new Date())).toBeTrue()\n  expect(is(Function, () => {})).toBeTrue()\n  expect(is(Number, new Number(0))).toBeTrue()\n  expect(is(Object, {})).toBeTrue()\n  expect(is(RegExp, /(?:)/)).toBeTrue()\n  expect(is(String, new String(''))).toBeTrue()\n})\n\ntest('works with user-defined types', () => {\n  function Foo(){}\n  function Bar(){}\n  Bar.prototype = new Foo()\n\n  const foo = new Foo()\n  const bar = new Bar()\n\n  expect(is(Foo, foo)).toBeTrue()\n  expect(is(Bar, bar)).toBeTrue()\n  expect(is(Foo, bar)).toBeTrue()\n  expect(is(Bar, foo)).toBeFalse()\n})\n\ntest('does not coerce', () => {\n  expect(is(Boolean, 1)).toBeFalse()\n  expect(is(Number, '1')).toBeFalse()\n  expect(is(Number, false)).toBeFalse()\n})\n\ntest('recognizes primitives as their object equivalents', () => {\n  expect(is(Boolean, false)).toBeTrue()\n  expect(is(Number, 0)).toBeTrue()\n  expect(is(String, '')).toBeTrue()\n})\n\ntest('does not consider primitives to be instances of Object', () => {\n  expect(is(Object, false)).toBeFalse()\n  expect(is(Object, 0)).toBeFalse()\n  expect(is(Object, '')).toBeFalse()\n})",
    "explanation": "It returns `true` is `x` is instance of `targetPrototype`.",
    "example": "const result = [\n  R.is(String, 'foo'),  \n  R.is(Array, 1)\n]\n// => [true, false]"
  },
  "isEmpty": {
    "typing": "isEmpty<T>(x: T): boolean",
    "allTypings": "isEmpty<T>(x: T): boolean;",
    "rambdaSource": "import { type } from './type'\n\nexport function isEmpty(input){\n  const inputType = type(input)\n  if ([ 'Undefined', 'NaN', 'Number', 'Null' ].includes(inputType))\n    return false\n  if (!input) return true\n\n  if (inputType === 'Object'){\n    return Object.keys(input).length === 0\n  }\n\n  if (inputType === 'Array'){\n    return input.length === 0\n  }\n\n  return false\n}",
    "rambdaSpecs": "import { isEmpty } from './isEmpty'\n\ntest('happy', () => {\n  expect(isEmpty(undefined)).toEqual(false)\n  expect(isEmpty('')).toEqual(true)\n  expect(isEmpty(null)).toEqual(false)\n  expect(isEmpty(' ')).toEqual(false)\n  expect(isEmpty(new RegExp(''))).toEqual(false)\n  expect(isEmpty([])).toEqual(true)\n  expect(isEmpty([ [] ])).toEqual(false)\n  expect(isEmpty({})).toEqual(true)\n  expect(isEmpty({ x : 0 })).toEqual(false)\n  expect(isEmpty(0)).toEqual(false)\n  expect(isEmpty(NaN)).toEqual(false)\n  expect(isEmpty([ '' ])).toEqual(false)\n})",
    "explanation": "It returns `true` is `x` is `empty`.",
    "example": "const result = [\n  R.isEmpty(''),\n  R.isEmpty({ x : 0 })\n]\n// => [true, false]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('isEmpty', function() {\n  it('returns true for empty typed array', function() {\n    eq(R.isEmpty(Uint8Array.from('')), true);\n    eq(R.isEmpty(Float32Array.from('')), true);\n    eq(R.isEmpty(new Float32Array([])), true);\n    eq(R.isEmpty(Uint8Array.from('1')), false);\n    eq(R.isEmpty(Float32Array.from('1')), false);\n    eq(R.isEmpty(new Float32Array([1])), false);\n  });\n});",
    "failedSpecsReasons": "ramda supports typed arrays",
    "failedSpecsCount": 1
  },
  "isNil": {
    "typing": "isNil(x: any): x is null | undefined",
    "allTypings": "isNil(x: any): x is null | undefined;",
    "rambdaSource": "export function isNil(x){\n  return x === undefined || x === null\n}",
    "rambdaSpecs": "import { isNil } from './isNil'\n\ntest('happy', () => {\n  expect(isNil(null)).toBeTrue()\n\n  expect(isNil(undefined)).toBeTrue()\n\n  expect(isNil([])).toBeFalse()\n})",
    "explanation": "It returns `true` is `x` is either `null` or `undefined`.",
    "example": "const result = [\n  R.isNil(null),\n  R.isNil(1),\n]\n// => [true, false]"
  },
  "join": {
    "typing": "join(x: string, xs: ReadonlyArray<any>): string",
    "allTypings": "join(x: string, xs: ReadonlyArray<any>): string;\njoin(x: string): (xs: ReadonlyArray<any>) => string;",
    "rambdaSource": "export function join(glue, list){\n  if (arguments.length === 1) return _list => join(glue, _list)\n\n  return list.join(glue)\n}",
    "rambdaSpecs": "import { join } from './join'\n\ntest('curry', () => {\n  expect(join('|')([ 'foo', 'bar', 'baz' ])).toEqual('foo|bar|baz')\n\n  expect(join('|', [ 1, 2, 3 ])).toEqual('1|2|3')\n\n  const spacer = join(' ')\n\n  expect(spacer([ 'a', 2, 3.4 ])).toEqual('a 2 3.4')\n})",
    "explanation": "It returns a string representing `list` instances joined with `glue`.",
    "example": "R.join('-', [1, 2, 3])  // => '1-2-3'"
  },
  "keys": {
    "typing": "keys<T extends object>(x: T): (keyof T)[]",
    "allTypings": "keys<T extends object>(x: T): (keyof T)[];\nkeys<T>(x: T): string[];",
    "rambdaSource": "export function keys(x){\n  return Object.keys(x)\n}",
    "rambdaSpecs": "import { keys } from './keys'\n\ntest('happy', () => {\n  expect(keys({ a : 1 })).toEqual([ 'a' ])\n})",
    "explanation": "It applies `Object.keys` over `x` and returns its keys.",
    "example": "R.keys({a:1, b:2})  // => ['a', 'b']",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('keys', function() {\n  var obj = {a: 100, b: [1, 2, 3], c: {x: 200, y: 300}, d: 'D', e: null, f: undefined};\n  function C() { this.a = 100; this.b = 200; }\n  C.prototype.x = function() { return 'x'; };\n  C.prototype.y = 'y';\n  var cobj = new C();\n  it('works for primitives', function() {\n    eq(R.keys(null), []);\n    eq(R.keys(undefined), []);\n    eq(R.keys(55), []);\n    eq(R.keys('foo'), []);\n    eq(R.keys(true), []);\n    eq(R.keys(false), []);\n    eq(R.keys(NaN), []);\n    eq(R.keys(Infinity), []);\n    eq(R.keys([]), []);\n  });\n});",
    "failedSpecsReasons": "ramda method works for primitives",
    "failedSpecsCount": 1
  },
  "last": {
    "typing": "last<T>(listOrString: T[]): T | undefined",
    "allTypings": "last<T>(listOrString: T[]): T | undefined;\nlast(listOrString: string): string;",
    "rambdaSource": "export function last(listOrString){\n  if (typeof listOrString === 'string'){\n    return listOrString[ listOrString.length - 1 ] || ''\n  }\n\n  return listOrString[ listOrString.length - 1 ]\n}",
    "rambdaSpecs": "import { last } from './last'\n\ntest('happy', () => {\n  expect(last([ 'foo', 'bar', 'baz' ])).toEqual('baz')\n  expect(last([])).toEqual(undefined)\n  expect(last('abc')).toEqual('c')\n  expect(last('')).toEqual('')\n})",
    "explanation": "It returns the last element of `listOrString`.",
    "example": "const result = [\n  R.last([1, 2, 3]),\n  R.last('foo'),\n]\n// => [3, 'o']"
  },
  "lastIndexOf": {
    "typing": "lastIndexOf<T>(target: T, list: ReadonlyArray<T>): number",
    "allTypings": "lastIndexOf<T>(target: T, list: ReadonlyArray<T>): number;\nlastIndexOf<T>(target: T): (list: ReadonlyArray<T>) => number;",
    "rambdaSource": "import { equals } from './equals'\n\nexport function lastIndexOf(target, list){\n  if (arguments.length === 1) return _list => lastIndexOf(target, _list)\n\n  let index = list.length\n\n  while (--index > 0){\n    if (equals(list[ index ], target)){\n      return index\n    }\n  }\n\n  return -1\n}",
    "rambdaSpecs": "import { lastIndexOf } from './lastIndexOf'\n\ntest('happy', () => {\n  const a = lastIndexOf(1, [ 1, 2, 3, 1, 2 ])\n  const b = lastIndexOf(1)([ 1, 2, 3, 1, 2 ])\n\n  expect(a).toEqual(3)\n  expect(b).toEqual(3)\n})\n\ntest('false', () => {\n  const a = lastIndexOf(10, [ 1, 2, 3, 1, 2 ])\n\n  expect(a).toEqual(-1)\n})",
    "explanation": "It returns the last index of `target` in `list` array.\n\n`R.equals` is used to determine equality between `target` and members of `list`.\n\nIf there is no such index, then `-1` is returned.",
    "example": "const list = [1, 2, 3, 1, 2, 3]\nconst result = [\n  R.lastIndexOf(2, list),\n  R.lastIndexOf(4, list),\n]\n// => [4, -1]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('lastIndexOf', function() {\n  var input = [1, 2, 3, 4, 5, 1];\n  var list = ['a', 1, 'a'];\n  list[-2] = 'a'; // Throw a wrench in the gears by assigning a non-valid array index as object property.\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.lastIndexOf(0, [-0]), -1);\n    eq(R.lastIndexOf(-0, [0]), -1);\n    eq(R.lastIndexOf(NaN, [NaN]), 0);\n    eq(R.lastIndexOf(new Just([42]), [new Just([42])]), 0);\n  });\n  it('dispatches to `lastIndexOf` method', function() {\n    function Empty() {}\n    Empty.prototype.lastIndexOf = R.always(-1);\n    function List(head, tail) {\n      this.head = head;\n      this.tail = tail;\n    }\n    List.prototype.lastIndexOf = function(x) {\n      var idx = this.tail.lastIndexOf(x);\n      return idx >= 0 ? 1 + idx : this.head === x ? 0 : -1;\n    };\n    var list = new List('b',\n      new List('a',\n        new List('n',\n          new List('a',\n            new List('n',\n              new List('a',\n                new Empty()\n              )\n            )\n          )\n        )\n      )\n    );\n    eq(R.lastIndexOf('a', 'banana'), 5);\n    eq(R.lastIndexOf('x', 'banana'), -1);\n    eq(R.lastIndexOf('a', list), 5);\n    eq(R.lastIndexOf('x', list), -1);\n  });\n  it('finds function, compared by identity', function() {\n    var f = function() {};\n    var g = function() {};\n    var list = [g, f, g, f];\n    eq(R.lastIndexOf(f, list), 3);\n  });\n});",
    "failedSpecsReasons": "ramda method dispatches to `lastIndexOf` method",
    "failedSpecsCount": 3
  },
  "length": {
    "typing": "length<T>(listOrString: ReadonlyArray<T>): number",
    "allTypings": "length<T>(listOrString: ReadonlyArray<T>): number;",
    "rambdaSource": "export function length(x){\n  if (!x || x.length === undefined){\n    return NaN\n  }\n\n  return x.length\n}",
    "rambdaSpecs": "import { length } from './length'\n\ntest('happy', () => {\n  expect(length('foo')).toEqual(3)\n  expect(length([ 1, 2, 3 ])).toEqual(3)\n  expect(length([])).toEqual(0)\n})\n\ntest('with bad input returns NaN', () => {\n  expect(length(0)).toBeNaN()\n  expect(length({})).toBeNaN()\n  expect(length(null)).toBeNaN()\n  expect(length(undefined)).toBeNaN()\n})",
    "explanation": "It returns the `length` property of `listOrString`.",
    "example": "const result = [\n  R.length([1, 2, 3, 4]),\n  R.length('foo'),\n]\n// => [4, 3]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('length', function() {\n  it('returns the length of a string', function() {\n    eq(R.length(''), 0);\n    eq(R.length('xyz'), 3);\n  });\n  it('returns NaN for length property of unexpected type', function() {\n    eq(R.identical(NaN, R.length({length: ''})), true);\n    eq(R.identical(NaN, R.length({length: '1.23'})), true);\n    eq(R.identical(NaN, R.length({length: null})), true);\n    eq(R.identical(NaN, R.length({length: undefined})), true);\n    eq(R.identical(NaN, R.length({})), true);\n  });\n});",
    "failedSpecsReasons": "ramda method supports object with `length` method",
    "failedSpecsCount": 1
  },
  "lens": {
    "typing": "lens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens",
    "allTypings": "lens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens;\nlens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens;",
    "rambdaSource": "export function lens(getter, setter){\n  if (arguments.length === 1) return _setter => lens(getter, _setter)\n\n  return function (functor){\n    return function (target){\n      return functor(getter(target)).map(focus => setter(focus, target))\n    }\n  }\n}",
    "explanation": "It returns a `lens` for the given `getter` and `setter` functions. \n\nThe `getter` **gets** the value of the focus; the `setter` **sets** the value of the focus. \n\nThe setter should not mutate the data structure.",
    "example": "const xLens = R.lens(R.prop('x'), R.assoc('x'));\n\nR.view(xLens, {x: 1, y: 2}) // => 1\nR.set(xLens, 4, {x: 1, y: 2}) // => {x: 4, y: 2}\nR.over(xLens, R.negate, {x: 1, y: 2}) // => {x: -1, y: 2}"
  },
  "lensIndex": {
    "typing": "lensIndex(index: number): Lens",
    "allTypings": "lensIndex(index: number): Lens;",
    "rambdaSource": "import { lens } from './lens'\nimport { nth } from './nth'\nimport { update } from './update'\n\nexport function lensIndex(index){\n  return lens(nth(index), update(index))\n}",
    "rambdaSpecs": "import { compose } from './compose'\nimport { keys } from './keys'\nimport { lensIndex } from './lensIndex'\nimport { over } from './over'\nimport { set } from './set'\nimport { view } from './view'\n\nconst testList = [ { a : 1 }, { b : 2 }, { c : 3 } ]\n\ntest('focuses list element at the specified index', () => {\n  expect(view(lensIndex(0), testList)).toEqual({ a : 1 })\n})\n\ntest('returns undefined if the specified index does not exist', () => {\n  expect(view(lensIndex(10), testList)).toEqual(undefined)\n})\n\ntest('sets the list value at the specified index', () => {\n  expect(set(\n    lensIndex(0), 0, testList\n  )).toEqual([ 0, { b : 2 }, { c : 3 } ])\n})\n\ntest('applies function to the value at the specified list index', () => {\n  expect(over(\n    lensIndex(2), keys, testList\n  )).toEqual([ { a : 1 }, { b : 2 }, [ 'c' ] ])\n})\n\ntest('can be composed', () => {\n  const nestedList = [ 0, [ 10, 11, 12 ], 1, 2 ]\n  const composedLens = compose(lensIndex(1), lensIndex(0))\n\n  expect(view(composedLens, nestedList)).toEqual(10)\n})\n\ntest('set s (get s) === s', () => {\n  expect(set(\n    lensIndex(0), view(lensIndex(0), testList), testList\n  )).toEqual(testList)\n})\n\ntest('get (set s v) === v', () => {\n  expect(view(lensIndex(0), set(\n    lensIndex(0), 0, testList\n  ))).toEqual(0)\n})\n\ntest('get (set(set s v1) v2) === v2', () => {\n  expect(view(lensIndex(0),\n    set(\n      lensIndex(0), 11, set(\n        lensIndex(0), 10, testList\n      )\n    ))).toEqual(11)\n})",
    "explanation": "It returns a lens that focuses on specified `index`.",
    "example": "const list = ['a', 'b', 'c']\nconst headLens = R.lensIndex(0)\n\nR.view(headLens, list) // => 'a'\nR.set(headLens, 'x', list) // => ['x', 'b', 'c']\nR.over(headLens, R.toUpper, list) // => ['A', 'b', 'c']"
  },
  "lensPath": {
    "typing": "lensPath(path: RamdaPath): Lens",
    "allTypings": "lensPath(path: RamdaPath): Lens;",
    "rambdaSource": "import { assocPath } from './assocPath'\nimport { lens } from './lens'\nimport { path } from './path'\n\nexport function lensPath(key){\n  return lens(path(key), assocPath(key))\n}",
    "rambdaSpecs": "import { compose } from './compose'\nimport { identity } from './identity'\nimport { inc } from './inc'\nimport { lensPath } from './lensPath'\nimport { lensProp } from './lensProp'\nimport { over } from './over'\nimport { set } from './set'\nimport { view } from './view'\n\nconst testObj = {\n  a : [ { b : 1 }, { b : 2 } ],\n  d : 3,\n}\n\ntest('view', () => {\n  expect(view(lensPath('d'), testObj)).toEqual(3)\n  expect(view(lensPath('a.0.b'), testObj)).toEqual(1)\n  // this is different to ramda, ramda will return a clone of the input object\n  expect(view(lensPath(''), testObj)).toEqual(undefined)\n})\n\ntest('set', () => {\n  expect(set(\n    lensProp('d'), 0, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 2 } ],\n    d : 0,\n  })\n  expect(set(\n    lensPath('a.0.b'), 0, testObj\n  )).toEqual({\n    a : [ { b : 0 }, { b : 2 } ],\n    d : 3,\n  })\n  expect(set(\n    lensPath('a.0.X'), 0, testObj\n  )).toEqual({\n    a : [\n      {\n        b : 1,\n        X : 0,\n      },\n      { b : 2 },\n    ],\n    d : 3,\n  })\n  expect(set(\n    lensPath([]), 0, testObj\n  )).toEqual(0)\n})\n\ntest('over', () => {\n  expect(over(\n    lensPath('d'), inc, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 2 } ],\n    d : 4,\n  })\n  expect(over(\n    lensPath('a.1.b'), inc, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 3 } ],\n    d : 3,\n  })\n  expect(over(\n    lensProp('X'), identity, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 2 } ],\n    d : 3,\n    X : undefined,\n  })\n  expect(over(\n    lensPath('a.0.X'), identity, testObj\n  )).toEqual({\n    a : [\n      {\n        b : 1,\n        X : undefined,\n      },\n      { b : 2 },\n    ],\n    d : 3,\n  })\n})\n\ntest('compose', () => {\n  const composedLens = compose(lensPath('a'), lensPath('1.b'))\n  expect(view(composedLens, testObj)).toEqual(2)\n})\n\ntest('set s (get s) === s', () => {\n  expect(set(\n    lensPath([ 'd' ]), view(lensPath([ 'd' ]), testObj), testObj\n  )).toEqual(testObj)\n  expect(set(\n    lensPath([ 'a', 0, 'b' ]),\n    view(lensPath([ 'a', 0, 'b' ]), testObj),\n    testObj\n  )).toEqual(testObj)\n})\n\ntest('get (set s v) === v', () => {\n  expect(view(lensPath([ 'd' ]), set(\n    lensPath([ 'd' ]), 0, testObj\n  ))).toEqual(0)\n  expect(view(lensPath([ 'a', 0, 'b' ]), set(\n    lensPath([ 'a', 0, 'b' ]), 0, testObj\n  ))).toEqual(0)\n})\n\ntest('get (set(set s v1) v2) === v2', () => {\n  const p = [ 'd' ]\n  const q = [ 'a', 0, 'b' ]\n  expect(view(lensPath(p), set(\n    lensPath(p), 11, set(\n      lensPath(p), 10, testObj\n    )\n  ))).toEqual(11)\n  expect(view(lensPath(q), set(\n    lensPath(q), 11, set(\n      lensPath(q), 10, testObj\n    )\n  ))).toEqual(11)\n})",
    "explanation": "It returns a lens that focuses on specified `path`.",
    "example": "const lensPath = R.lensPath(['x', 0, 'y'])\nconst input = {x: [{y: 2, z: 3}, {y: 4, z: 5}]}\n\nR.view(lensPath, input) //=> 2\n\nR.set(lensPath, 1, input) \n//=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}\n\nR.over(xHeadYLens, R.negate, input) \n//=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}"
  },
  "lensProp": {
    "typing": "lensProp(prop: string): {\n  <T, U>(obj: T): U",
    "allTypings": "lensProp(prop: string): {\n  <T, U>(obj: T): U;\n  set<T, U, V>(val: T, obj: U): V;\n};",
    "rambdaSource": "import { assoc } from './assoc'\nimport { lens } from './lens'\nimport { prop } from './prop'\n\nexport function lensProp(key){\n  return lens(prop(key), assoc(key))\n}",
    "rambdaSpecs": "import { compose } from './compose'\nimport { identity } from './identity'\nimport { inc } from './inc'\nimport { lensProp } from './lensProp'\nimport { over } from './over'\nimport { set } from './set'\nimport { view } from './view'\n\nconst testObj = {\n  a : 1,\n  b : 2,\n  c : 3,\n}\n\ntest('focuses object the specified object property', () => {\n  expect(view(lensProp('a'), testObj)).toEqual(1)\n})\n\ntest('returns undefined if the specified property does not exist', () => {\n  expect(view(lensProp('X'), testObj)).toEqual(undefined)\n})\n\ntest('sets the value of the object property specified', () => {\n  expect(set(\n    lensProp('a'), 0, testObj\n  )).toEqual({\n    a : 0,\n    b : 2,\n    c : 3,\n  })\n})\n\ntest('adds the property to the object if it doesn\\'t exist', () => {\n  expect(set(\n    lensProp('d'), 4, testObj\n  )).toEqual({\n    a : 1,\n    b : 2,\n    c : 3,\n    d : 4,\n  })\n})\n\ntest('applies function to the value of the specified object property', () => {\n  expect(over(\n    lensProp('a'), inc, testObj\n  )).toEqual({\n    a : 2,\n    b : 2,\n    c : 3,\n  })\n})\n\ntest('applies function to undefined and adds the property if it doesn\\'t exist', () => {\n  expect(over(\n    lensProp('X'), identity, testObj\n  )).toEqual({\n    a : 1,\n    b : 2,\n    c : 3,\n    X : undefined,\n  })\n})\n\ntest('can be composed', () => {\n  const nestedObj = {\n    a : { b : 1 },\n    c : 2,\n  }\n  const composedLens = compose(lensProp('a'), lensProp('b'))\n\n  expect(view(composedLens, nestedObj)).toEqual(1)\n})\n\ntest('set s (get s) === s', () => {\n  expect(set(\n    lensProp('a'), view(lensProp('a'), testObj), testObj\n  )).toEqual(testObj)\n})\n\ntest('get (set s v) === v', () => {\n  expect(view(lensProp('a'), set(\n    lensProp('a'), 0, testObj\n  ))).toEqual(0)\n})\n\ntest('get (set(set s v1) v2) === v2', () => {\n  expect(view(lensProp('a'),\n    set(\n      lensProp('a'), 11, set(\n        lensProp('a'), 10, testObj\n      )\n    ))).toEqual(11)\n})",
    "explanation": "It returns a lens that focuses on specified property `prop`.",
    "example": "const xLens = R.lensProp('x');\nconst input = {x: 1, y: 2}\n\nR.view(xLens, input) // => 1\n\nR.set(xLens, 4, input) \n// => {x: 4, y: 2}\n\nR.over(xLens, R.negate, input) \n// => {x: -1, y: 2}"
  },
  "over": {
    "typing": "over<T>(lens: Lens, fn: Arity1Fn, value: T): T",
    "allTypings": "over<T>(lens: Lens, fn: Arity1Fn, value: T): T;\nover<T>(lens: Lens, fn: Arity1Fn, value: readonly T[]): T[];\nover(lens: Lens, fn: Arity1Fn): <T>(value: T) => T;\nover(lens: Lens, fn: Arity1Fn): <T>(value: readonly T[]) => T[];\nover(lens: Lens): <T>(fn: Arity1Fn, value: T) => T;\nover(lens: Lens): <T>(fn: Arity1Fn, value: readonly T[]) => T[];",
    "rambdaSource": "const Identity = x => ({\n  x,\n  map : fn => Identity(fn(x)),\n})\n\nexport function over(\n  lens, fn, object\n){\n  if (arguments.length === 1)\n    return (_fn, _object) => over(\n      lens, _fn, _object\n    )\n  if (arguments.length === 2) return _object => over(\n    lens, fn, _object\n  )\n\n  return lens(x => Identity(fn(x)))(object).x\n}",
    "explanation": "It returns a copied **Object** or **Array** with modified value received by applying function `fn` to `lens` focus.",
    "example": "const headLens = R.lensIndex(0)\n \nR.over(headLens, R.toUpper, ['foo', 'bar', 'baz']) //=> ['FOO', 'bar', 'baz']"
  },
  "set": {
    "typing": "set<T, U>(lens: Lens, replacer: U, obj: T): T",
    "allTypings": "set<T, U>(lens: Lens, replacer: U, obj: T): T;\nset<U>(lens: Lens, replacer: U): <T>(obj: T) => T;\nset(lens: Lens): <T, U>(replacer: U, obj: T) => T;",
    "rambdaSource": "import { always } from './always'\nimport { over } from './over'\n\nexport function set(\n  lens, replacer, x\n){\n  if (arguments.length === 1) return (_v, _x) => set(\n    lens, _v, _x\n  )\n  if (arguments.length === 2) return _x => set(\n    lens, replacer, _x\n  )\n\n  return over(\n    lens, always(replacer), x\n  )\n}",
    "explanation": "It returns a copied **Object** or **Array** with modified `lens` focus set to `replacer` value.",
    "example": "const input = {x: 1, y: 2}\nconst xLens = R.lensProp('x')\n\nR.set(xLens, 4, input) //=> {x: 4, y: 2}\nR.set(xLens, 8, input) //=> {x: 8, y: 2}"
  },
  "view": {
    "typing": "view<T, U>(lens: Lens): (target: T) => U",
    "allTypings": "view<T, U>(lens: Lens): (target: T) => U;\nview<T, U>(lens: Lens, target: T): U;",
    "rambdaSource": "const Const = x => ({\n  x,\n  map : fn => Const(x),\n})\n\nexport function view(lens, target){\n  if (arguments.length === 1) return _target => view(lens, _target)\n\n  return lens(Const)(target).x\n}",
    "explanation": "It returns the value of `lens` focus over `target` object.",
    "example": "const lens = R.lensProp('x')\n\nR.view(lens, {x: 1, y: 2}) //=> 1\nR.view(lens, {x: 4, y: 2}) //=> 4"
  },
  "map": {
    "typing": "map<T, U>(fn: MapFunctionObject<T, U>, list: Dictionary<T>): Dictionary<U>",
    "allTypings": "map<T, U>(fn: MapFunctionObject<T, U>, list: Dictionary<T>): Dictionary<U>;\nmap<T, U>(fn: MapFunctionArray<T, U>, list: T[]): U[];\nmap<T, U>(fn: MapFunctionArray<T, U>): (list: T[]) => U[];\nmap<T, U, S>(fn: MapFunctionObject<T, U>): (list: Dictionary<T>) => Dictionary<U>;\nmap<T>(fn: MapFunctionArray<T, T>): (list: T[]) => T[];\nmap<T>(fn: MapFunctionArray<T, T>, list: ReadonlyArray<T>): T[];",
    "notes": "Unlike Ramda's `map`, here array keys are passed as second argument to `fn` when `list` is an array.",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nfunction mapObject(fn, obj){\n  const willReturn = {}\n\n  for (const prop in obj){\n    willReturn[ prop ] = fn(\n      obj[ prop ], prop, obj\n    )\n  }\n\n  return willReturn\n}\n\nexport function map(fn, list){\n  if (arguments.length === 1) return _list => map(fn, _list)\n\n  if (list === undefined){\n    return []\n  }\n  if (!_isArray(list)){\n    return mapObject(fn, list)\n  }\n\n  let index = -1\n  const len = list.length\n  const willReturn = Array(len)\n\n  while (++index < len){\n    willReturn[ index ] = fn(list[ index ], index)\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { map } from './map'\n\nconst double = x => x * 2\n\nconst sampleObject = {\n  a : 1,\n  b : 2,\n  c : 3,\n  d : 4,\n}\n\ntest('with array', () => {\n  expect(map(double, [ 1, 2, 3 ])).toEqual([ 2, 4, 6 ])\n})\n\ntest('pass index as second argument', () => {\n  map((x, i) => {\n    expect(i).toBeNumber()\n  },\n  [ 10, 20, 30 ])\n})\n\ntest('with object', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n  }\n\n  expect(map(double, obj)).toEqual({\n    a : 2,\n    b : 4,\n  })\n})\n\ntest('pass input object as third argument', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n  }\n  const iterator = (\n    val, prop, inputObject\n  ) => {\n    expect(inputObject).toEqual(obj)\n\n    return val * 2\n  }\n\n  expect(map(iterator, obj)).toEqual({\n    a : 2,\n    b : 4,\n  })\n})\n\ntest('with object passes property as second argument', () => {\n  map((_, prop) => {\n    expect(typeof prop).toEqual('string')\n  })(sampleObject)\n})\n\n/**\n * https://github.com/selfrefactor/rambda/issues/77\n */\ntest('when undefined instead of array', () => {\n  expect(map(double, undefined)).toEqual([])\n})",
    "explanation": "It returns the result of looping through `list` with `fn`.\n\nIt works with both array and object.",
    "example": "const fn = (x, i) => (x * 2) + i\nconst fnWhenObject = (val, prop)=>{\n  return `${prop}-${val}`\n}\n\nconst list = [1, 2]\nconst obj = {a: 1, b: 2}\n\nconst result = [ \n  R.map(fn, list),\n  R.map(fnWhenObject, obj)\n]\n// => [ [2, 5], {a: 'a-1', b: 'b-2'}]",
    "typescriptDefinitionTest": "import {map} from 'rambda'\n\ndescribe('map with arrays', () => {\n  it('only one type', () => {\n    const x = map<number>(\n      (a, b) => {\n        a // $ExpectType number\n        b // $ExpectType number\n        return a + 2\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType number[]\n  })\n  it('only one type + curry', () => {\n    const x = map<number>((a, b) => {\n      a // $ExpectType number\n      b // $ExpectType number\n      return a + 2\n    })([1, 2, 3])\n    x // $ExpectType number[]\n  })\n  it('2 types', () => {\n    const x = map<number, string>(\n      (a, b) => {\n        a // $ExpectType number\n        b // $ExpectType number\n        return `${a}`\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType string[]\n  })\n  it('2 types + curry', () => {\n    const x = map<number, string>((a, b) => {\n      a // $ExpectType number\n      b // $ExpectType number\n      return `${a}`\n    })([1, 2, 3])\n    x // $ExpectType string[]\n  })\n})\n\ndescribe('map with objects', () => {\n  it('curry', () => {\n    // It requires dummy third typing argument\n    // in order to distinguish compared to curry typings for arrays\n    // ============================================\n    const x = map<number, string, any>((a, b, c) => {\n      a // $ExpectType number\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n      return `${a}`\n    })({a: 1, b: 2})\n    x // $ExpectType Dictionary<string>\n  })\n  it('1', () => {\n    const x = map<number, string>(\n      (a, b, c) => {\n        a // $ExpectType number\n        b // $ExpectType string\n        c // $ExpectType Dictionary<number>\n        return `${a}`\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<string>\n  })\n  it('2', () => {\n    const x = map<number, string>(\n      (a, b) => {\n        a // $ExpectType number\n        b // $ExpectType string\n        return `${a}`\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<string>\n  })\n  it('3', () => {\n    const x = map<number, string>(\n      a => {\n        a // $ExpectType number\n        return `${a}`\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<string>\n  })\n})"
  },
  "match": {
    "typing": "match(regExpression: RegExp, str: string): any[]",
    "allTypings": "match(regExpression: RegExp, str: string): any[];\nmatch(regExpression: RegExp): (str: string) => any[];",
    "rambdaSource": "export function match(pattern, input){\n  if (arguments.length === 1) return _input => match(pattern, _input)\n\n  const willReturn = input.match(pattern)\n\n  return willReturn === null ? [] : willReturn\n}",
    "rambdaSpecs": "import { equals } from './equals'\nimport { match } from './match'\n\ntest('happy', () => {\n  expect(match(/a./g)('foo bar baz')).toEqual([ 'ar', 'az' ])\n})\n\ntest('fallback', () => {\n  expect(match(/a./g)('foo')).toEqual([])\n})\n\ntest('with string', () => {\n  expect(match('a', 'foo')).toEqual([])\n  expect(equals(match('o', 'foo'), [ 'o' ])).toBeTrue()\n})\n\ntest('throwing', () => {\n  expect(() => {\n    match(/a./g, null)\n  }).toThrowWithMessage(TypeError, 'Cannot read property \\'match\\' of null')\n})",
    "explanation": "Curried version of `String.prototype.match` which returns empty array, when there is no match.",
    "example": "const result = [\n  R.match('a', 'foo'),\n  R.match(/([a-z]a)/g, 'bananas')\n]\n// => [[], ['ba', 'na', 'na']]"
  },
  "mathMod": {
    "typing": "mathMod(x: number, y: number): number",
    "allTypings": "mathMod(x: number, y: number): number;\nmathMod(x: number): (y: number) => number;",
    "notes": "Explanation is taken from `Ramda` documentation site.",
    "rambdaSource": "import _isInteger from './_internals/_isInteger'\n\nexport function mathMod(x, y){\n  if (arguments.length === 1) return _y => mathMod(x, _y)\n  if (!_isInteger(x) || !_isInteger(y) || y < 1) return NaN\n\n  return (x % y + y) % y\n}",
    "rambdaSpecs": "import { mathMod } from './mathMod'\n\ntest('happy', () => {\n  expect(mathMod(-17)(5)).toEqual(3)\n  expect(mathMod(17, 5)).toEqual(2)\n  expect(mathMod(17, -5)).toBeNaN()\n  expect(mathMod(17, 0)).toBeNaN()\n  expect(mathMod('17', 5)).toBeNaN()\n  expect(mathMod({}, 2)).toBeNaN()\n  expect(mathMod([], 2)).toBeNaN()\n  expect(mathMod(Symbol(), 2)).toBeNaN()\n})",
    "explanation": "`R.mathMod` behaves like the modulo operator should mathematically, unlike the % operator (and by extension, `R.modulo`). So while `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`.",
    "example": "const result = [\n  R.mathMod(-17, 5),\n  R.mathMod(17, 5),\n  R.mathMod(17, -5),  \n  R.mathMod(17, 0)   \n]\n// => [3, 2, NaN, NaN]"
  },
  "max": {
    "typing": "max<T extends Ord>(x: T, y: T): T",
    "allTypings": "max<T extends Ord>(x: T, y: T): T;\nmax<T extends Ord>(x: T): (y: T) => T;",
    "rambdaSource": "export function max(x, y){\n  if (arguments.length === 1) return _y => max(x, _y)\n\n  return y > x ? y : x\n}",
    "rambdaSpecs": "import { max } from './max'\n\ntest('with number', () => {\n  expect(max(2, 1)).toBe(2)\n})\n\ntest('with string', () => {\n  expect(max('foo')('bar')).toBe('foo')\n  expect(max('bar')('baz')).toBe('baz')\n})",
    "explanation": "It returns the greater value between `x` and `y`.",
    "example": "const result = [\n  R.max(5, 7),  \n  R.max('bar', 'foo'),  \n]\n// => [7, 'foo']"
  },
  "maxBy": {
    "typing": "maxBy<T>(compareFn: (input: T) => Ord, x: T, y: T): T",
    "allTypings": "maxBy<T>(compareFn: (input: T) => Ord, x: T, y: T): T;\nmaxBy<T>(compareFn: (input: T) => Ord, x: T): (y: T) => T;\nmaxBy<T>(compareFn: (input: T) => Ord): FunctionToolbelt.Curry<(x: T, y: T) => T>;",
    "rambdaSource": "import { curry } from './curry'\n\nexport function maxByFn(\n  compareFn, x, y\n){\n  return compareFn(y) > compareFn(x) ? y : x\n}\n\nexport const maxBy = curry(maxByFn)",
    "rambdaSpecs": "import { maxBy } from './maxBy'\n\ntest('happy', () => {\n  expect(maxBy(\n    Math.abs, -5, 2\n  )).toEqual(-5)\n})\n\ntest('curried', () => {\n  expect(maxBy(Math.abs)(2, -5)).toEqual(-5)\n  expect(maxBy(Math.abs)(2)(-5)).toEqual(-5)\n})",
    "explanation": "It returns the greater value between `x` and `y` according to `compareFn` function.",
    "example": "const compareFn = Math.abs\n\nR.maxBy(compareFn, 5, -7) // => -7"
  },
  "mean": {
    "typing": "mean(list: ReadonlyArray<number>): number",
    "allTypings": "mean(list: ReadonlyArray<number>): number;",
    "rambdaSource": "import { sum } from './sum'\n\nexport function mean(list){\n  return sum(list) / list.length\n}",
    "rambdaSpecs": "import { mean } from './mean'\n\ntest('happy', () => {\n  expect(mean([ 2, 7 ])).toBe(4.5)\n})\n\ntest('with NaN', () => {\n  expect(mean([])).toBeNaN()\n})",
    "explanation": "It returns the mean value of `list` input.",
    "example": "R.mean([ 2, 7 ])\n// => 4.5",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('mean', function() {\n  it('handles array-like object', function() {\n    eq(R.mean((function() { return arguments; })(1, 2, 3)), 2);\n  });\n});"
  },
  "median": {
    "typing": "median(list: ReadonlyArray<number>): number",
    "allTypings": "median(list: ReadonlyArray<number>): number;",
    "rambdaSource": "import { mean } from './mean'\n\nexport function median(list){\n  const len = list.length\n  if (len === 0) return NaN\n  const width = 2 - len % 2\n  const idx = (len - width) / 2\n\n  return mean(Array.prototype.slice\n    .call(list, 0)\n    .sort((a, b) => {\n      if (a === b) return 0\n\n      return a < b ? -1 : 1\n    })\n    .slice(idx, idx + width))\n}",
    "rambdaSpecs": "import { identical } from './identical'\nimport { median } from './median'\n\ntest('median', () => {\n  expect(median([ 2 ])).toEqual(2)\n  expect(median([ 7, 2, 10, 9 ])).toEqual(8)\n  expect(identical(NaN, median([]))).toBeTrue()\n})",
    "explanation": "It returns the median value of `list` input.",
    "example": "R.median([ 7, 2, 10, 9 ]) // => 8"
  },
  "merge": {
    "typing": "merge<T1, T2>(target: T1, newProps: T2): Merge<T2, T1>",
    "allTypings": "merge<T1, T2>(target: T1, newProps: T2): Merge<T2, T1>;\nmerge<T1>(target: T1): <T2>(newProps: T2) => Merge<T2, T1>;",
    "rambdaSource": "export function merge(target, newProps){\n  if (arguments.length === 1) return _newProps => merge(target, _newProps)\n\n  return Object.assign(\n    {}, target || {}, newProps || {}\n  )\n}",
    "rambdaSpecs": "import { merge } from './merge'\n\nconst sample = {\n  foo : 'bar',\n  bar : 'bar',\n}\n\ntest('merge', () => {\n  expect(merge(sample)({ bar : 'baz' })).toEqual({\n    foo : 'bar',\n    bar : 'baz',\n  })\n})\n\n/**\n * https://github.com/selfrefactor/rambda/issues/77\n */\ntest('when undefined or null instead of object', () => {\n  expect(merge(null, undefined)).toEqual({})\n  expect(merge(sample, null)).toEqual(sample)\n  expect(merge(sample, undefined)).toEqual(sample)\n  expect(merge(undefined, sample)).toEqual(sample)\n})",
    "explanation": "It creates a copy of `target` object with overidden `newProps` properties.",
    "example": "const target = { 'foo': 0, 'bar': 1 }\nconst newProps = { 'foo': 7 }\n\nconst result = R.merge(target, newProps)\n// => { 'foo': 7, 'bar': 1 }"
  },
  "min": {
    "typing": "min<T extends Ord>(x: T, y: T): T",
    "allTypings": "min<T extends Ord>(x: T, y: T): T;\nmin<T extends Ord>(x: T): (y: T) => T;",
    "rambdaSource": "export function min(x, y){\n  if (arguments.length === 1) return _y => min(x, _y)\n\n  return y < x ? y : x\n}",
    "rambdaSpecs": "import { min } from './min'\n\ntest('happy', () => {\n  expect(min(2, 1)).toBe(1)\n  expect(min(2)(1)).toBe(1)\n})",
    "explanation": "It returns the lesser value between `x` and `y`.",
    "example": "const result = [\n  R.min(5, 7),  \n  R.min('bar', 'foo'),  \n]\n// => [5, 'bar']"
  },
  "minBy": {
    "typing": "minBy<T>(compareFn: (input: T) => Ord, x: T, y: T): T",
    "allTypings": "minBy<T>(compareFn: (input: T) => Ord, x: T, y: T): T;\nminBy<T>(compareFn: (input: T) => Ord, x: T): (y: T) => T;\nminBy<T>(compareFn: (input: T) => Ord): FunctionToolbelt.Curry<(x: T, y: T) => T>;",
    "rambdaSource": "import { curry } from './curry'\n\nexport function minByFn(\n  compareFn, x, y\n){\n  return compareFn(y) < compareFn(x) ? y : x\n}\n\nexport const minBy = curry(minByFn)",
    "rambdaSpecs": "import { minBy } from './minBy'\n\ntest('happy', () => {\n  expect(minBy(\n    Math.abs, -5, 2\n  )).toEqual(2)\n})\n\ntest('curried', () => {\n  expect(minBy(Math.abs)(2, -5)).toEqual(2)\n  expect(minBy(Math.abs)(2)(-5)).toEqual(2)\n})",
    "explanation": "It returns the lesser value between `x` and `y` according to `compareFn` function.",
    "example": "const compareFn = Math.abs\n\nR.minBy(compareFn, -5, 2) // => -5"
  },
  "modulo": {
    "typing": "modulo(x: number, y: number): number",
    "allTypings": "modulo(x: number, y: number): number;\nmodulo(x: number): (y: number) => number;",
    "rambdaSource": "export function modulo(x, y){\n  if (arguments.length === 1) return _y => modulo(x, _y)\n\n  return x % y\n}",
    "rambdaSpecs": "import { modulo } from './modulo'\n\ntest('happy', () => {\n  expect(modulo(17, 3)).toEqual(2)\n  expect(modulo(15)(6)).toEqual(3)\n})",
    "explanation": "Curried version of `x%y`.",
    "example": "R.modulo(17, 3) // => 2"
  },
  "multiply": {
    "typing": "multiply(x: number, y: number): number",
    "allTypings": "multiply(x: number, y: number): number;\nmultiply(x: number): (y: number) => number;",
    "rambdaSource": "export function multiply(x, y){\n  if (arguments.length === 1) return _y => multiply(x, _y)\n\n  return x * y\n}",
    "rambdaSpecs": "import { multiply } from './multiply'\n\ntest('happy', () => {\n  expect(multiply(2, 4)).toEqual(8)\n  expect(multiply(2)(4)).toEqual(8)\n})",
    "explanation": "Curried version of `x*y`.",
    "example": "R.multiply(2, 4) // => 8"
  },
  "negate": {
    "typing": "negate(x: number): number",
    "allTypings": "negate(x: number): number;",
    "rambdaSource": "export function negate(x){\n  return -x\n}",
    "rambdaSpecs": "import { negate } from './negate'\n\ntest('negate', () => {\n  expect(negate(420)).toEqual(-420)\n  expect(negate(-13)).toEqual(13)\n})",
    "example": "R.negate(420)// => -420"
  },
  "none": {
    "typing": "none<T>(predicate: (x: T) => boolean, list: ReadonlyArray<T>): boolean",
    "allTypings": "none<T>(predicate: (x: T) => boolean, list: ReadonlyArray<T>): boolean;\nnone<T>(predicate: (x: T) => boolean): (list: ReadonlyArray<T>) => boolean;",
    "rambdaSource": "export function none(predicate, list){\n  if (arguments.length === 1) return _list => none(predicate, _list)\n\n  return list.filter(predicate).length === 0\n}",
    "rambdaSpecs": "import { none } from './none'\n\nconst isEven = n => n % 2 === 0\nconst isOdd = n => n % 2 === 1\nconst arr = [ 1, 3, 5, 7, 9, 11 ]\n\ntest('when true', () => {\n  expect(none(isEven, arr)).toBeTrue()\n})\n\ntest('when false curried', () => {\n  expect(none(isOdd)(arr)).toBeFalse()\n})\n\ntest('passes index to predicate', () => {\n  none((x, i) => {\n    expect(typeof x).toBe('number')\n    expect(typeof i).toBe('number')\n  })([ 1, 2, 3 ])\n})",
    "explanation": "It returns `true`, if all members of array `list` returns `false`, when applied as argument to `predicate` function.",
    "example": "const list = [ 0, 1, 2, 3, 4 ]\nconst predicate = x => x > 6\n\nconst result = R.none(predicate, arr)\n// => true"
  },
  "not": {
    "typing": "not(input: any): boolean",
    "allTypings": "not(input: any): boolean;",
    "rambdaSource": "export function not(input){\n  return !input\n}",
    "rambdaSpecs": "import { not } from './not'\n\ntest('not', () => {\n  expect(not(false)).toEqual(true)\n  expect(not(true)).toEqual(false)\n  expect(not(0)).toEqual(true)\n  expect(not(1)).toEqual(false)\n})",
    "explanation": "It returns a boolean negated version of `input`.",
    "example": "R.not(false) // true"
  },
  "nth": {
    "typing": "nth<T>(index: number, list: ReadonlyArray<T>): T | undefined",
    "allTypings": "nth<T>(index: number, list: ReadonlyArray<T>): T | undefined;\nnth(index: number): <T>(list: ReadonlyArray<T>) => T | undefined;",
    "rambdaSource": "export function nth(index, list){\n  if (arguments.length === 1) return _list => nth(index, _list)\n\n  const idx = index < 0 ? list.length + index : index\n\n  return Object.prototype.toString.call(list) === '[object String]' ?\n    list.charAt(idx) :\n    list[ idx ]\n}",
    "rambdaSpecs": "import { nth } from './nth'\n\ntest('happy', () => {\n  expect(nth(2, [ 1, 2, 3, 4 ])).toEqual(3)\n})\n\ntest('with curry', () => {\n  expect(nth(2)([ 1, 2, 3, 4 ])).toEqual(3)\n})\n\ntest('with string', () => {\n  expect(nth(2)('foo')).toEqual('o')\n})\n\ntest('with negative index', () => {\n  expect(nth(-3)([ 1, 2, 3, 4 ])).toEqual(2)\n})",
    "explanation": "Curried version of `list[index]`.",
    "example": "const list = [1, 2, 3]\nconst str = 'foo'\n\nconst result = [\n  R.nth(2, list),\n  R.nth(6, list),\n  R.nth(0, str),\n]\n// => [3, undefined, 'f']"
  },
  "omit": {
    "typing": "omit<T, K extends string>(propsToOmit: readonly K[], obj: T): Omit<T, K>",
    "allTypings": "omit<T, K extends string>(propsToOmit: readonly K[], obj: T): Omit<T, K>;\nomit<K extends string>(propsToOmit: readonly K[]): <T>(obj: T) => Omit<T, K>;\nomit<T, U>(propsToOmit: string, obj: T): U;\nomit<T, U>(propsToOmit: string): (obj: T) => U;\nomit<T>(propsToOmit: string, obj: object): T;\nomit<T>(propsToOmit: string): (obj: object) => T;",
    "notes": "When using this method with `TypeScript`, it is much easier to pass `propsToOmit` as an array. If passing a string, you will need to explicitly declare the output type.",
    "rambdaSource": "export function omit(propsToOmit, obj){\n  if (arguments.length === 1) return _obj => omit(propsToOmit, _obj)\n\n  if (obj === null || obj === undefined){\n    return undefined\n  }\n\n  const propsToOmitValue =\n    typeof propsToOmit === 'string' ? propsToOmit.split(',') : propsToOmit\n\n  const willReturn = {}\n\n  for (const key in obj){\n    if (!propsToOmitValue.includes(key)){\n      willReturn[ key ] = obj[ key ]\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { omit } from './omit'\n\ntest('with string as condition', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n  const result = omit('a,c', obj)\n  const resultCurry = omit('a,c')(obj)\n  const expectedResult = { b : 2 }\n\n  expect(result).toEqual(expectedResult)\n  expect(resultCurry).toEqual(expectedResult)\n})\n\ntest('with null', () => {\n  expect(omit('a,b', null)).toEqual(undefined)\n})\n\ntest('doesn\\'t work with number as property', () => {\n  expect(omit([ 42 ], {\n    a  : 1,\n    42 : 2,\n  })).toEqual({\n    42 : 2,\n    a  : 1,\n  })\n})\n\ntest('happy', () => {\n  expect(omit([ 'a', 'c' ])({\n    a : 'foo',\n    b : 'bar',\n    c : 'baz',\n  })).toEqual({ b : 'bar' })\n})",
    "explanation": "It returns a partial copy of an `obj` without `propsToOmit` properties.",
    "example": "const obj = {a: 1, b: 2, c: 3}\nconst propsToOmit = 'a,c,d'\nconst propsToOmitList = ['a', 'c', 'd']\n\nconst result = [\n  R.omit(propsToOmit, obj), \n  R.omit(propsToOmitList, obj) \n]\n// => [{b: 2}, {b: 2}]",
    "typescriptDefinitionTest": "import {omit} from 'rambda'\n\ndescribe('R.omit with array as props input', () => {\n  it('allow Typescript to infer object type', () => {\n    const input = {a: 'foo', b: 2, c: 3, d: 4}\n    const result = omit(['b,c'], input)\n\n    result.a // $ExpectType string\n    result.d // $ExpectType number\n\n    const curriedResult = omit(['a,c'], input)\n\n    curriedResult.a // $ExpectType string\n    curriedResult.d // $ExpectType number\n  })\n\n  it('declare type of input object', () => {\n    type Input = {\n      a: string\n      b: number\n      c: number\n      d: number\n    }\n    const input: Input = {a: 'foo', b: 2, c: 3, d: 4}\n    const result = omit(['b,c'], input)\n    result // $ExpectType Pick<Input, \"a\" | \"b\" | \"c\" | \"d\">\n\n    result.a // $ExpectType string\n    result.d // $ExpectType number\n\n    const curriedResult = omit(['a,c'], input)\n\n    curriedResult.a // $ExpectType string\n    curriedResult.d // $ExpectType number\n  })\n})\n\ndescribe('R.omit with string as props input', () => {\n  type Output = {\n    b: number\n    d: number\n  }\n\n  it('explicitly declare output', () => {\n    const result = omit<Output>('a,c', {a: 1, b: 2, c: 3, d: 4})\n    result // $ExpectType Output\n    result.b // $ExpectType number\n\n    const curriedResult = omit<Output>('a,c')({a: 1, b: 2, c: 3, d: 4})\n\n    curriedResult.b // $ExpectType number\n  })\n\n  it('explicitly declare input and output', () => {\n    type Input = {\n      a: number\n      b: number\n      c: number\n      d: number\n    }\n    const result = omit<Input, Output>('a,c', {a: 1, b: 2, c: 3, d: 4})\n    result // $ExpectType Output\n    result.b // $ExpectType number\n\n    const curriedResult = omit<Input, Output>('a,c')({a: 1, b: 2, c: 3, d: 4})\n\n    curriedResult.b // $ExpectType number\n  })\n\n  it('without passing type', () => {\n    const result = omit('a,c', {a: 1, b: 2, c: 3, d: 4})\n    result // $ExpectType unknown\n  })\n})"
  },
  "partial": {
    "typing": "partial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, x0: V0): (x1: V1) => T",
    "allTypings": "partial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, x0: V0): (x1: V1) => T;\npartial<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, x0: V0, x1: V1): (x2: V2) => T;\npartial<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, x0: V0): (x1: V1, x2: V2) => T;\npartial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, x0: V0, x1: V1, x2: V2): (x2: V3) => T;\npartial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, x0: V0, x1: V1): (x2: V2, x3: V3) => T;\npartial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, x0: V0): (x1: V1, x2: V2, x3: V3) => T;\npartial<T>(fn: (...a: any[]) => T, ...args: any[]): (...a: any[]) => T;",
    "notes": "Rambda's **partial** doesn't need the input arguments to be wrapped as array.",
    "rambdaSource": "export function partial(fn, ...args){\n  const len = fn.length\n\n  return (...rest) => {\n    if (args.length + rest.length >= len){\n      return fn(...args, ...rest)\n    }\n\n    return partial(fn, ...[ ...args, ...rest ])\n  }\n}",
    "rambdaSpecs": "import { partial } from './partial'\nimport { type } from './type'\n\nconst greet = (\n  salutation, title, firstName, lastName\n) =>\n  salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!'\n\ntest('happy', () => {\n  const canPassAnyNumberOfArguments = partial(\n    greet, 'Hello', 'Ms.'\n  )\n  const fn = canPassAnyNumberOfArguments('foo')\n  const sayHello = partial(greet, [ 'Hello' ])\n  const sayHelloRamda = partial(sayHello, [ 'Ms.' ])\n\n  expect(type(fn)).toBe('Function')\n\n  expect(fn('bar')).toBe('Hello, Ms. foo bar!')\n  expect(sayHelloRamda('foo', 'bar')).toBe('Hello, Ms. foo bar!')\n})\n\ntest('extra arguments are ignored', () => {\n  const canPassAnyNumberOfArguments = partial(\n    greet, 'Hello', 'Ms.'\n  )\n  const fn = canPassAnyNumberOfArguments('foo')\n\n  expect(type(fn)).toBe('Function')\n\n  expect(fn(\n    'bar', 1, 2\n  )).toBe('Hello, Ms. foo bar!')\n})\n\ntest('when array is input', () => {\n  const fooFn = (\n    a, b, c, d\n  ) => ({\n    a,\n    b,\n    c,\n    d,\n  })\n  const barFn = partial(\n    fooFn, [ 1, 2 ], []\n  )\n\n  expect(barFn(1, 2)).toEqual({\n    a : [ 1, 2 ],\n    b : [],\n    c : 1,\n    d : 2,\n  })\n})\n\ntest('ramda spec', () => {\n  const sayHello = partial(greet, 'Hello')\n  const sayHelloToMs = partial(sayHello, 'Ms.')\n\n  expect(sayHelloToMs('Jane', 'Jones')).toBe('Hello, Ms. Jane Jones!')\n})",
    "explanation": "It is very similar to `R.curry`, but you can pass initial arguments when you create the curried function.\n\n`R.partial` will keep returning a function until all the arguments that the function `fn` expects are passed.\nThe name comes from the fact that you partially inject the inputs.",
    "example": "const fn = (title, firstName, lastName) => {\n  return title + ' ' + firstName + ' ' + lastName + '!'\n}\n\nconst canPassAnyNumberOfArguments = R.partial(fn, 'Hello')\nconst ramdaStyle = R.partial(fn, ['Hello'])\n\nconst finalFn = canPassAnyNumberOfArguments('Foo')\n\nfinalFn('Bar') // =>  'Hello, Foo Bar!'",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('partial', function() {\n  var disc = function(a, b, c) { // note disc(3, 7, 4) => 1\n    return b * b - 4 * a * c;\n  };\n  it('caches the initially supplied arguments', function() {\n    var f = R.partial(disc, [3]);\n    eq(f(7, 4), 1);\n    var g = R.partial(disc, [3, 7]);\n    eq(g(4), 1);\n  });\n  it('correctly reports the arity of the new function', function() {\n    var f = R.partial(disc, [3]);\n    eq(f.length, 2);\n    var g = R.partial(disc, [3, 7]);\n    eq(g.length, 1);\n  });\n});"
  },
  "path": {
    "typing": "path<Input, T>(pathToSearch: string | string[], obj: Input): T | undefined",
    "allTypings": "path<Input, T>(pathToSearch: string | string[], obj: Input): T | undefined;\npath<T>(pathToSearch: string | string[], obj: any): T | undefined;\npath<T>(pathToSearch: string | string[]): (obj: any) => T | undefined;\npath<Input, T>(pathToSearch: string | string[]): (obj: Input) => T | undefined;",
    "notes": "String anotation of `pathToSearch` is one of the differences between `Rambda` and `Ramda`.",
    "rambdaSource": "export function path(list, obj){\n  if (arguments.length === 1) return _obj => path(list, _obj)\n\n  if (obj === null || obj === undefined){\n    return undefined\n  }\n  let willReturn = obj\n  let counter = 0\n\n  const pathArrValue = typeof list === 'string' ? list.split('.') : list\n\n  while (counter < pathArrValue.length){\n    if (willReturn === null || willReturn === undefined){\n      return undefined\n    }\n    willReturn = willReturn[ pathArrValue[ counter ] ]\n    counter++\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { path } from './path'\n\ntest('with array inside object', () => {\n  const obj = { a : { b : [ 1, { c : 1 } ] } }\n\n  expect(path('a.b.1.c', obj)).toBe(1)\n})\n\ntest('works with undefined', () => {\n  const obj = { a : { b : { c : 1 } } }\n\n  expect(path('a.b.c.d.f', obj)).toBeUndefined()\n  expect(path('foo.babaz', undefined)).toBeUndefined()\n  expect(path('foo.babaz')(undefined)).toBeUndefined()\n})\n\ntest('works with string instead of array', () => {\n  expect(path('foo.bar.baz')({ foo : { bar : { baz : 'yes' } } })).toEqual('yes')\n})\n\ntest('path', () => {\n  expect(path([ 'foo', 'bar', 'baz' ])({ foo : { bar : { baz : 'yes' } } })).toEqual('yes')\n\n  expect(path([ 'foo', 'bar', 'baz' ])(null)).toBeUndefined()\n\n  expect(path([ 'foo', 'bar', 'baz' ])({ foo : { bar : 'baz' } })).toBeUndefined()\n})",
    "explanation": "If `pathToSearch` is `'a.b'` then it will return `1` if `obj` is `{a:{b:1}}`.\n\nIt will return `undefined`, if such path is not found.",
    "example": "const obj = {a: {b: 1}}\nconst pathToSearch = 'a.b'\nconst pathToSearchList = ['a', 'b']\n\nconst result = [\n  R.path(pathToSearch, obj),\n  R.path(pathToSearchList, obj),\n  R.path('a.b.c.d', obj)\n]\n// => [1, 1, undefined]",
    "typescriptDefinitionTest": "import {path} from 'rambda'\n\ninterface Input {\n  a: number,\n  b: {\n    c: boolean,\n  },\n}\n\ndescribe('path', () => {\n  it('without specified input type', () => {\n    const input = {a: 1, b: {c: true}}\n    const result = path<boolean>('a.b.c', input)\n    const resultCurried = path<boolean>('a.b.c')(input)\n    result // $ExpectType boolean | undefined\n    resultCurried // $ExpectType boolean | undefined\n  })\n\n  it('without specified output type', () => {\n    const input = {a: 1, b: {c: true}}\n    const result = path('a.b.c', input)\n    result // $ExpectType unknown\n  })\n\n  it('with string as path', () => {\n    const input: Input = {a: 1, b: {c: true}}\n    const resultA = path<boolean>('a.b.c', input)\n    const resultB = path<boolean>('a.b.c')(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  })\n  it('with array as path', () => {\n    const input: Input = {a: 1, b: {c: true}}\n    const resultA = path<boolean>(['a', 'b', 'c'], input)\n    const resultB = path<boolean>(['a', 'b', 'c'])(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  })\n})\n\ndescribe('path with specified input', () => {\n  it('with string as path', () => {\n    const input: Input = {a: 1, b: {c: true}}\n    // const wrongInput = { a: 1, b: true }\n    // const resultA = path<Input, boolean>('a.b.c', wrongInput)\n    const resultA = path<Input, boolean>('a.b.c', input)\n    const resultB = path<Input, boolean>('a.b.c')(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  })\n  it('with array as path', () => {\n    const input: Input = {a: 1, b: {c: true}}\n    const resultA = path<Input, boolean>(['a', 'b', 'c'], input)\n    const resultB = path<Input, boolean>(['a', 'b', 'c'])(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('path', function() {\n  var deepObject = {a: {b: {c: 'c'}}, falseVal: false, nullVal: null, undefinedVal: undefined, arrayVal: ['arr']};\n  it('takes a path that contains negative indices into arrays', function() {\n    eq(R.path(['x', -2], {x: ['a', 'b', 'c', 'd']}), 'c');\n    eq(R.path([-1, 'y'], [{x: 1, y: 99}, {x: 2, y: 98}, {x: 3, y: 97}]), 97);\n  });\n});",
    "failedSpecsReasons": "ramda method supports negative indices",
    "failedSpecsCount": 1
  },
  "paths": {
    "typing": "paths<Input, T>(pathsToSearch: Path[], obj: Input): (T | undefined)[]",
    "allTypings": "paths<Input, T>(pathsToSearch: Path[], obj: Input): (T | undefined)[];\npaths<Input, T>(pathsToSearch: Path[]): (obj: Input) => (T | undefined)[];\npaths<T>(pathsToSearch: Path[], obj: any): (T | undefined)[];\npaths<T>(pathsToSearch: Path[]): (obj: any) => (T | undefined)[];",
    "rambdaSource": "import { path } from './path'\n\nexport function paths(pathsToSearch, obj){\n  if (arguments.length === 1){\n    return _obj => paths(pathsToSearch, _obj)\n  }\n\n  return pathsToSearch.map(singlePath => path(singlePath, obj))\n}",
    "rambdaSpecs": "import { paths } from './paths'\n\nconst obj = {\n  a : {\n    b : {\n      c : 1,\n      d : 2,\n    },\n  },\n  p : [ { q : 3 }, 'Hi' ],\n  x : {\n    y : 'Alice',\n    z : [ [ {} ] ],\n  },\n}\n\ntest('with string path + curry', () => {\n  const pathsInput = [ 'a.b.d', 'p.q' ]\n  const expected = [ 2, undefined ]\n  const result = paths(pathsInput, obj)\n  const curriedResult = paths(pathsInput)(obj)\n\n  expect(result).toEqual(expected)\n  expect(curriedResult).toEqual(expected)\n})\n\ntest('with array path', () => {\n  const result = paths([\n    [ 'a', 'b', 'c' ],\n    [ 'x', 'y' ],\n  ],\n  obj)\n\n  expect(result).toEqual([ 1, 'Alice' ])\n})\n\ntest('takes a paths that contains indices into arrays', () => {\n  expect(paths([\n    [ 'p', 0, 'q' ],\n    [ 'x', 'z', 0, 0 ],\n  ],\n  obj)).toEqual([ 3, {} ])\n  expect(paths([\n    [ 'p', 0, 'q' ],\n    [ 'x', 'z', 2, 1 ],\n  ],\n  obj)).toEqual([ 3, undefined ])\n})\n\ntest('gets a deep property\\'s value from objects', () => {\n  expect(paths([ [ 'a', 'b' ] ], obj)).toEqual([ obj.a.b ])\n  expect(paths([ [ 'p', 0 ] ], obj)).toEqual([ obj.p[ 0 ] ])\n})\n\ntest('returns undefined for items not found', () => {\n  expect(paths([ [ 'a', 'x', 'y' ] ], obj)).toEqual([ undefined ])\n  expect(paths([ [ 'p', 2 ] ], obj)).toEqual([ undefined ])\n})",
    "explanation": "It loops over members of `pathsToSearch` as `singlePath` and returns the array produced by `R.path(singlePath, obj)`.\n\nBecause it calls `R.path`, then `singlePath` can be either string or a list.",
    "example": "const obj = {\n  a : {\n    b : {\n      c : 1,\n      d : 2\n    }\n  }\n}\n\nconst result = R.paths([\n  'a.b.c',\n  'a.b.c.d',\n  'a.b.c.d.e',\n], obj)\n// => [1, 2, undefined]",
    "typescriptDefinitionTest": "import {paths} from 'rambda'\n\ninterface Input {\n  a: number,\n  b: number,\n  c: number,\n}\n\nconst input: Input = {a: 1, b: 2, c: 3}\n\ndescribe('paths', () => {\n  it('with dot notation', () => {\n    const result = paths<number>(['a.b.c', 'foo.bar'], input)\n    result // $ExpectType (number | undefined)[]\n  })\n\n  it('without type', () => {\n    const result = paths(['a.b.c', 'foo.bar'], input)\n    result // $ExpectType unknown[]\n  })\n\n  it('with array as path', () => {\n    const result = paths<number>([['a', 'b', 'c'], ['foo.bar']], input)\n    result // $ExpectType (number | undefined)[]\n  })\n\n  it('with curry', () => {\n    const result = paths<number>([['a', 'b', 'c'], ['foo.bar']])(input)\n    result // $ExpectType (number | undefined)[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('paths', function() {\n  var obj = {\n    a: {\n      b: {\n        c: 1,\n        d: 2\n      }\n    },\n    p: [{q: 3}, 'Hi'],\n    x: {\n      y: 'Alice',\n      z: [[{}]]\n    }\n  };\n  it('takes a path that contains negative indices into arrays', function() {\n    eq(R.paths([['p', -2, 'q'], ['p', -1]], obj), [3, 'Hi']);\n    eq(R.paths([['p', -4, 'q'], ['x', 'z', -1, 0]], obj), [undefined, {}]);\n  });\n});",
    "failedSpecsReasons": "ramda method supports negative indices",
    "failedSpecsCount": 1
  },
  "pathOr": {
    "typing": "pathOr<T>(defaultValue: T, pathToSearch: Path, obj: any): T",
    "allTypings": "pathOr<T>(defaultValue: T, pathToSearch: Path, obj: any): T;\npathOr<T>(defaultValue: T, pathToSearch: Path): (obj: any) => T;\npathOr<T>(defaultValue: T): FunctionToolbelt.Curry<(a: Path, b: any) => T>;",
    "rambdaSource": "import { curry } from './curry'\nimport { defaultTo } from './defaultTo'\nimport { path } from './path'\n\nfunction pathOrFn(\n  defaultValue, list, obj\n){\n  return defaultTo(defaultValue, path(list, obj))\n}\n\nexport const pathOr = curry(pathOrFn)",
    "rambdaSpecs": "import { pathOr } from './pathOr'\n\ntest('with undefined', () => {\n  const result = pathOr(\n    'foo', 'x.y', { x : { y : 1 } }\n  )\n\n  expect(result).toEqual(1)\n})\n\ntest('with null', () => {\n  const result = pathOr(\n    'foo', 'x.y', null\n  )\n\n  expect(result).toEqual('foo')\n})\n\ntest('with NaN', () => {\n  const result = pathOr(\n    'foo', 'x.y', NaN\n  )\n\n  expect(result).toEqual('foo')\n})\n\ntest('curry case (x)(y)(z)', () => {\n  const result = pathOr('foo')('x.y.z')({ x : { y : { a : 1 } } })\n\n  expect(result).toEqual('foo')\n})\n\ntest('curry case (x)(y,z)', () => {\n  const result = pathOr('foo', 'x.y.z')({ x : { y : { a : 1 } } })\n\n  expect(result).toEqual('foo')\n})\n\ntest('curry case (x,y)(z)', () => {\n  const result = pathOr('foo')('x.y.z', { x : { y : { a : 1 } } })\n\n  expect(result).toEqual('foo')\n})",
    "explanation": "It reads `obj` input and returns either `R.path(pathToSearch, obj)` result or `defaultValue` input.",
    "example": "const defaultValue = 'DEFAULT_VALUE'\nconst pathToSearch = 'a.b'\nconst pathToSearchList = ['a', 'b']\n\nconst obj = {\n  a : {\n    b : 1\n  }\n}\n\nconst result = [\n  R.pathOr(DEFAULT_VALUE, pathToSearch, obj) \n  R.pathOr(DEFAULT_VALUE, pathToSearchList, obj) \n  R.pathOr(DEFAULT_VALUE, 'a.b.c', obj) \n]\n// => [1, 1, 'DEFAULT_VALUE']"
  },
  "pick": {
    "typing": "pick<T, K extends string | number | symbol>(propsToPick: readonly K[], input: T): Pick<T, Exclude<keyof T, Exclude<keyof T, K>>>",
    "allTypings": "pick<T, K extends string | number | symbol>(propsToPick: readonly K[], input: T): Pick<T, Exclude<keyof T, Exclude<keyof T, K>>>;\npick<K extends string | number | symbol>(propsToPick: readonly K[]): <T>(input: T) => Pick<T, Exclude<keyof T, Exclude<keyof T, K>>>;\npick<T, U>(propsToPick: string, input: T): U;\npick<T, U>(propsToPick: string): (input: T) => U;\npick<T>(propsToPick: string, input: object): T;\npick<T>(propsToPick: string): (input: object) => T;",
    "notes": "When using this method with `TypeScript`, it is much easier to pass `propsToOmit` as an array. If passing a string, you will need to explicitly declare the output type.",
    "rambdaSource": "export function pick(propsToPick, input){\n  if (arguments.length === 1) return _input => pick(propsToPick, _input)\n\n  if (input === null || input === undefined){\n    return undefined\n  }\n  const keys =\n    typeof propsToPick === 'string' ? propsToPick.split(',') : propsToPick\n\n  const willReturn = {}\n  let counter = 0\n\n  while (counter < keys.length){\n    if (keys[ counter ] in input){\n      willReturn[ keys[ counter ] ] = input[ keys[ counter ] ]\n    }\n    counter++\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { pick } from './pick'\n\ntest('props to pick is a string', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n  const result = pick('a,c', obj)\n  const resultCurry = pick('a,c')(obj)\n  const expectedResult = {\n    a : 1,\n    c : 3,\n  }\n\n  expect(result).toEqual(expectedResult)\n  expect(resultCurry).toEqual(expectedResult)\n})\n\ntest('props to pick is an array', () => {\n  expect(pick([ 'a', 'c' ])({\n    a : 'foo',\n    b : 'bar',\n    c : 'baz',\n  })).toEqual({\n    a : 'foo',\n    c : 'baz',\n  })\n\n  expect(pick([ 'a', 'd', 'e', 'f' ])({\n    a : 'foo',\n    b : 'bar',\n    c : 'baz',\n  })).toEqual({ a : 'foo' })\n\n  expect(pick('a,d,e,f')(null)).toEqual(undefined)\n})\n\ntest('works with list as input and number as props - props to pick is an array', () => {\n  const result = pick([ 1, 2 ], [ 'a', 'b', 'c', 'd' ])\n  expect(result).toEqual({\n    1 : 'b',\n    2 : 'c',\n  })\n})\n\ntest('works with list as input and number as props - props to pick is a string', () => {\n  const result = pick('1,2', [ 'a', 'b', 'c', 'd' ])\n  expect(result).toEqual({\n    1 : 'b',\n    2 : 'c',\n  })\n})\n\ntest('with symbol', () => {\n  const symbolProp = Symbol('s')\n  expect(pick([ symbolProp ], { [ symbolProp ] : 'a' })).toMatchInlineSnapshot(`\n    Object {\n      Symbol(s): \"a\",\n    }\n  `)\n})",
    "explanation": "It returns a partial copy of an `input` containing only `propsToPick` properties.\n\n`input` can be either an object or an array.\n\nString anotation of `propsToPick` is one of the differences between `Rambda` and `Ramda`.",
    "example": "const obj = {\n  a : 1,\n  b : false,\n  foo: 'cherry'\n}\nconst list = [1, 2, 3, 4]\nconst propsToPick = 'a,foo'\nconst propsToPickList = ['a', 'foo']\n\nconst result = [\n  R.pick(propsToPick, obj),\n  R.pick(propsToPickList, obj),\n  R.pick('a,bar', obj),\n  R.pick('bar', obj),\n  R.pick([0, 3], list),\n  R.pick('0,3', list),\n]\n\nconst expected = [\n  {a:1, foo: 'cherry'},\n  {a:1, foo: 'cherry'},\n  {a:1},\n  {},\n  [1,4],\n  [1,4]\n]\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {pick} from 'rambda'\n\ndescribe('pick with array as props input', () => {\n  type Input = {\n    a: string\n    b: number\n    c: number\n    d: number\n  }\n\n  it('need to declare the types of input and props to pick - string as prop', () => {\n    const input = {a: 'foo', b: 2, c: 3, d: 4}\n    const result = pick<Input, string>(['a,c'], input)\n    result // $ExpectType Pick<Input, \"a\" | \"b\" | \"c\" | \"d\">\n    result.a // $ExpectType string\n    result.b // $ExpectType number\n\n    const curriedResult = pick<Input, string>(['a,c'], input)\n    curriedResult // $ExpectType Pick<Input, \"a\" | \"b\" | \"c\" | \"d\">\n  })\n\n  it('need to declare the types of input and props to pick - number as prop', () => {\n    const result = pick<Array<string>, number>([1, 2], [\"a\", \"b\", \"c\", \"d\"]);\n    result[1] // $ExpectType string\n    result[2] // $ExpectType string\n    result[3] // should not be possible but it is\n  })\n\n  it('need to declare the types of input and props to pick - symbol as prop', () => {\n    const symbolProp = Symbol('s')\n    const result = pick([ symbolProp ], { [ symbolProp ] : 'a' })\n    \n    result // $ExpectType Pick<{ [symbolProp]: string; }, typeof symbolProp>\n  })\n})\n\ndescribe('R.pick with string as props input', () => {\n  type Output = {\n    a: number\n    c: number\n  }\n\n  it('explicitly declare output', () => {\n    const result = pick<Output>('a,c', {a: 1, b: 2, c: 3, d: 4})\n    result // $ExpectType Output\n    result.a // $ExpectType number\n\n    const curriedResult = pick<Output>('a,c')({a: 1, b: 2, c: 3, d: 4})\n\n    curriedResult.a // $ExpectType number\n  })\n\n  it('explicitly declare input and output', () => {\n    type Input = {\n      a: number\n      b: number\n      c: number\n      d: number\n    }\n    const result = pick<Input, Output>('a,c', {a: 1, b: 2, c: 3, d: 4})\n    result // $ExpectType Output\n    result.a // $ExpectType number\n\n    const curriedResult = pick<Input, Output>('a,c')({a: 1, b: 2, c: 3, d: 4})\n\n    curriedResult.a // $ExpectType number\n  })\n\n  it('without passing type', () => {\n    const result = pick('a,c', {a: 1, b: 2, c: 3, d: 4})\n    result // $ExpectType unknown\n  })\n})"
  },
  "pickAll": {
    "typing": "pickAll<T, U>(propsToPick: ReadonlyArray<string>, obj: T): U",
    "allTypings": "pickAll<T, U>(propsToPick: ReadonlyArray<string>, obj: T): U;\npickAll(propsToPick: ReadonlyArray<string>): <T, U>(obj: T) => U;",
    "rambdaSource": "export function pickAll(propsToPick, obj){\n  if (arguments.length === 1) return _obj => pickAll(propsToPick, _obj)\n\n  if (obj === null || obj === undefined){\n    return undefined\n  }\n  const keysValue =\n    typeof propsToPick === 'string' ? propsToPick.split(',') : propsToPick\n\n  const willReturn = {}\n  let counter = 0\n\n  while (counter < keysValue.length){\n    if (keysValue[ counter ] in obj){\n      willReturn[ keysValue[ counter ] ] = obj[ keysValue[ counter ] ]\n    } else {\n      willReturn[ keysValue[ counter ] ] = undefined\n    }\n    counter++\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { pickAll } from './pickAll'\n\ntest('when input is undefined or null', () => {\n  expect(pickAll('a', null)).toBe(undefined)\n  expect(pickAll('a', undefined)).toBe(undefined)\n})\n\ntest('with string as condition', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n  const result = pickAll('a,c', obj)\n  const resultCurry = pickAll('a,c')(obj)\n  const expectedResult = {\n    a : 1,\n    b : undefined,\n    c : 3,\n  }\n\n  expect(result).toEqual(expectedResult)\n  expect(resultCurry).toEqual(expectedResult)\n})\n\ntest('with array as condition', () => {\n  expect(pickAll([ 'a', 'b', 'c' ], {\n    a : 'foo',\n    c : 'baz',\n  })).toEqual({\n    a : 'foo',\n    b : undefined,\n    c : 'baz',\n  })\n})",
    "explanation": "Same as `R.pick` but it won't skip the missing props, i.e. it will assign them to `undefined`.",
    "example": "const obj = {\n  a : 1,\n  b : false,\n  foo: 'cherry'\n}\nconst propsToPick = 'a,foo,bar'\nconst propsToPickList = ['a', 'foo', 'bar']\n\nconst result = [\n  R.pickAll(propsToPick, obj),\n  R.pickAll(propsToPickList, obj),\n  R.pickAll('a,bar', obj),\n  R.pickAll('bar', obj),\n]\nconst expected = [\n  {a:1, foo: 'cherry', bar: undefined},\n  {a:1, foo: 'cherry', bar: undefined},\n  {a:1, bar: undefined},\n  {bar: undefined}\n]\n// => `result` is equal to `expected`"
  },
  "pipe": {
    "typing": "pipe<T1>(fn0: () => T1): () => T1",
    "allTypings": "pipe<T1>(fn0: () => T1): () => T1;\npipe<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;\npipe<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;\npipe<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;",
    "rambdaSource": "import { compose } from './compose'\n\nexport function pipe(...fns){\n  if (fns.length === 0)\n    throw new Error('pipe requires at least one argument')\n\n  return compose(...fns.reverse())\n}",
    "rambdaSpecs": "import { add, last, map } from '../rambda'\nimport { pipe } from './pipe'\n\ntest('happy', () => {\n  const list = [ 1, 2, 3 ]\n\n  const result = pipe(\n    map(add(1)), map(add(10)), last\n  )(list)\n\n  expect(result).toEqual(14)\n})\n\ntest('with bad input', () => {\n  expect(() => pipe()).toThrow('pipe requires at least one argument')\n})",
    "explanation": "It performs left-to-right function composition.",
    "example": "const result = R.pipe(\n  R.filter(val => val > 2),\n  R.map(a => a * 2)\n)([1, 2, 3, 4])\n\n// => [6, 8]",
    "failedRamdaSpecs": "var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('pipe', function() {\n  it('performs left-to-right function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.pipe(parseInt, R.multiply, R.map);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.pipe(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.pipe(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });\n});",
    "failedSpecsReasons": "ramda passes context to functions | rambda composed functions have no length",
    "failedSpecsCount": 3
  },
  "pluck": {
    "typing": "pluck<T>(property: number, list: ReadonlyArray<T>): T",
    "allTypings": "pluck<T>(property: number, list: ReadonlyArray<T>): T;\npluck<K extends keyof T, T>(property: K, list: ReadonlyArray<T>): T[K][];\npluck(property: number): <T>(list: ReadonlyArray<T>) => T;\npluck<P extends string>(property: P): <T>(list: ReadonlyArray<Record<P, T>>) => T[];",
    "rambdaSource": "import { map } from './map'\n\nexport function pluck(property, list){\n  if (arguments.length === 1) return _list => pluck(property, _list)\n\n  const willReturn = []\n\n  map(x => {\n    if (x[ property ] !== undefined){\n      willReturn.push(x[ property ])\n    }\n  }, list)\n\n  return willReturn\n}",
    "rambdaSpecs": "import { pluck } from './pluck'\n\ntest('happy', () => {\n  expect(pluck('a')([ { a : 1 }, { a : 2 }, { b : 1 } ])).toEqual([ 1, 2 ])\n})\n\ntest('with number', () => {\n  const input = [\n    [ 1, 2 ],\n    [ 3, 4 ],\n  ]\n\n  expect(pluck(0, input)).toEqual([ 1, 3 ])\n})",
    "explanation": "It returns list of the values of `property` taken from the all objects inside `list`.",
    "example": "const list = [{a: 1}, {a: 2}, {b: 3}]\nconst property = 'a'\n\nR.pluck(list, property) \n// => [1, 2]",
    "typescriptDefinitionTest": "import {pluck} from 'rambda'\n\ndescribe('pluck', () => {\n  it('with object', () => {\n    interface ListMember {\n      a: number,\n      b: string,\n    }\n    const input: ListMember[] = [\n      {a: 1, b: 'foo'},\n      {a: 2, b: 'bar'},\n    ]\n    const resultA = pluck('a', input)\n    const resultB = pluck('b')(input)\n    resultA // $ExpectType number[]\n    resultB // $ExpectType string[]\n  })\n\n  it('with array', () => {\n    const input = [\n      [1, 2],\n      [3, 4],\n      [5, 6],\n    ]\n    const result = pluck(0, input)\n    const resultCurry = pluck(0)(input)\n    result // $ExpectType number[]\n    resultCurry // $ExpectType number[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('pluck', function() {\n  var people = [\n    {name: 'Fred', age: 23},\n    {name: 'Wilma', age: 21},\n    {name: 'Pebbles', age: 2}\n  ];\n  it('behaves as a transducer when given a transducer in list position', function() {\n    var numbers = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];\n    var transducer = R.compose(R.pluck('a'), R.map(R.add(1)), R.take(2));\n    eq(R.transduce(transducer, R.flip(R.append), [], numbers), [2, 3]);\n  });\n});",
    "failedSpecsReasons": "ramda method behaves as a transducer",
    "failedSpecsCount": 1
  },
  "prepend": {
    "typing": "prepend<T>(x: T, listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "prepend<T>(x: T, listOrString: ReadonlyArray<T>): T[];\nprepend<T>(x: T): (listOrString: ReadonlyArray<T>) => T[];",
    "rambdaSource": "export function prepend(x, listOrString){\n  if (arguments.length === 1)\n    return _listOrString => prepend(x, _listOrString)\n\n  if (typeof listOrString === 'string') return `${ x }${ listOrString }`\n\n  return [ x ].concat(listOrString)\n}",
    "rambdaSpecs": "import { prepend } from './prepend'\n\ntest('happy', () => {\n  expect(prepend('f', 'oo')).toEqual('foo')\n})\n\ntest('prepend', () => {\n  expect(prepend('yes', [ 'foo', 'bar', 'baz' ])).toEqual([\n    'yes',\n    'foo',\n    'bar',\n    'baz',\n  ])\n\n  expect(prepend('foo')([])).toEqual([ 'foo' ])\n})",
    "explanation": "It adds element `x` at the beginning of `listOrString`.",
    "example": "const x = 'foo'\n\nconst result = [\n  R.prepend(x, '_cherry'),\n  R.prepend(x, ['bar', 'baz'])\n]\n// => ['foo_cherry', ['foo', 'bar', 'baz']]"
  },
  "product": {
    "typing": "product(list: ReadonlyArray<number>): number",
    "allTypings": "product(list: ReadonlyArray<number>): number;",
    "rambdaSource": "import { multiply } from './multiply'\nimport { reduce } from './reduce'\n\nexport const product = reduce(multiply, 1)",
    "rambdaSpecs": "import { product } from './product'\n\ntest('happy', () => {\n  expect(product([ 2, 3, 4 ])).toEqual(24)\n})\n\ntest('bad input', () => {\n  expect(product([ null ])).toEqual(0)\n  expect(product([])).toEqual(1)\n})",
    "example": "R.product([ 2, 3, 4 ])\n// => 24)"
  },
  "prop": {
    "typing": "prop<P extends keyof T, T>(propToFind: P, obj: T): T[P]",
    "allTypings": "prop<P extends keyof T, T>(propToFind: P, obj: T): T[P];\nprop<P extends string>(p: P): <T>(propToFind: Record<P, T>) => T;\nprop<P extends string, T>(p: P): (propToFind: Record<P, T>) => T;",
    "rambdaSource": "export function prop(propToFind, obj){\n  if (arguments.length === 1) return _obj => prop(propToFind, _obj)\n\n  if (!obj) return undefined\n\n  return obj[ propToFind ]\n}",
    "rambdaSpecs": "import { prop } from './prop'\n\ntest('prop', () => {\n  expect(prop('foo')({ foo : 'baz' })).toEqual('baz')\n\n  expect(prop('bar')({ foo : 'baz' })).toEqual(undefined)\n\n  expect(prop('bar')(null)).toEqual(undefined)\n})",
    "explanation": "It returns the value of property `propToFind` in `obj`.\n\nIf there is no such property, it returns `undefined`.",
    "example": "const result = [\n  R.prop('x', {x: 100}), \n  R.prop('x', {a: 1}) \n]\n// => [100, undefined]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('prop', function() {\n  var fred = {name: 'Fred', age: 23};\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.prop(0, deities), 'Cthulhu');\n    eq(R.prop(1, deities), 'Dagon');\n    eq(R.prop(2, deities), 'Yog-Sothoth');\n    eq(R.prop(-1, deities), 'Yog-Sothoth');\n  });\n});"
  },
  "propEq": {
    "typing": "propEq<T, K extends keyof T>(propToFind: K, valueToMatch: T[K], obj: T): boolean",
    "allTypings": "propEq<T, K extends keyof T>(propToFind: K, valueToMatch: T[K], obj: T): boolean;\npropEq<T, K extends keyof T>(propToFind: K, valueToMatch: T[K]): (obj: T) => boolean;\npropEq<T, K extends keyof T>(propToFind: K): {\n   (valueToMatch: T[K], obj: T): boolean;\n   (valueToMatch: T[K]): (obj: T) => boolean;\n};",
    "rambdaSource": "import { curry } from './curry'\n\nfunction propEqFn(\n  propToFind, valueToMatch, obj\n){\n  if (!obj) return false\n\n  return obj[ propToFind ] === valueToMatch\n}\n\nexport const propEq = curry(propEqFn)",
    "rambdaSpecs": "import { propEq } from './propEq'\n\ntest('happy', () => {\n  expect(propEq('foo', 'bar')({ foo : 'bar' })).toBeTrue()\n  expect(propEq('foo', 'bar')({ foo : 'baz' })).toBeFalse()\n  expect(propEq('foo')('bar')({ foo : 'baz' })).toBeFalse()\n  expect(propEq(\n    'foo', 'bar', null\n  )).toBeFalse()\n})",
    "explanation": "It returns true if `obj` has property `propToFind` and its value is equal to `valueToMatch`.",
    "example": "const obj = { foo: 'bar' }\nconst secondObj = { foo: 1 }\n\nconst propToFind = 'foo'\nconst valueToMatch = 'bar'\n\nconst result = [\n  R.propEq(propToFind, valueToMatch, obj),\n  R.propEq(propToFind, valueToMatch, secondObj)\n]\n// => [true, false]",
    "typescriptDefinitionTest": "import {propEq} from 'rambda'\n\nconst property = 'foo'\nconst numberProperty = 1\nconst value = 'bar'\nconst obj = { [property]: value }\nconst objWithNumberIndex = { [numberProperty]: value }\n\ndescribe('propEq', () => {\n  it('happy', () => {\n    const result = propEq(\n      property, value, obj\n    )\n    result // $ExpectType boolean\n  })\n  it('number is property', () => {\n    const result = propEq(\n      1, value, objWithNumberIndex\n    )\n    result // $ExpectType boolean\n  })\n  it('with optional property', () => {\n    interface MyType {\n        optional?: string | number;\n    }\n    \n    const myObject: MyType = {};\n    const valueToFind = '1111';\n    const optionalValueToFind: string | number | undefined = '1111';\n    const result = propEq('optional', valueToFind, myObject)\n    const result2 = propEq('optional', optionalValueToFind, myObject)\n    result // $ExpectType boolean\n    result2 // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('propEq', function() {\n  var obj1 = {name: 'Abby', age: 7, hair: 'blond'};\n  var obj2 = {name: 'Fred', age: 12, hair: 'brown'};\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propEq(0, 'Cthulhu', deities), true);\n    eq(R.propEq(1, 'Dagon', deities), true);\n    eq(R.propEq(2, 'Yog-Sothoth', deities), true);\n    eq(R.propEq(-1, 'Yog-Sothoth', deities), true);\n    eq(R.propEq(3, undefined, deities), true);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.propEq('value', 0, {value: -0}), false);\n    eq(R.propEq('value', -0, {value: 0}), false);\n    eq(R.propEq('value', NaN, {value: NaN}), true);\n    eq(R.propEq('value', new Just([42]), {value: new Just([42])}), true);\n  });\n});",
    "failedSpecsReasons": "ramda method pass to `equals` method if available",
    "failedSpecsCount": 1
  },
  "propIs": {
    "typing": "propIs(type: any, name: string, obj: any): boolean",
    "allTypings": "propIs(type: any, name: string, obj: any): boolean;\npropIs(type: any, name: string): (obj: any) => boolean;\npropIs(type: any): {\n    (name: string, obj: any): boolean;\n    (name: string): (obj: any) => boolean;\n};",
    "rambdaSource": "import { curry } from './curry'\nimport { is } from './is'\n\nfunction propIsFn(\n  targetPrototype, property, obj\n){\n  return is(targetPrototype, obj[ property ])\n}\n\nexport const propIs = curry(propIsFn)",
    "rambdaSpecs": "import { propIs } from './propIs'\n\nconst obj = { value : 1 }\nconst property = 'value'\n\ntest('when true', () => {\n  expect(propIs(\n    Number, property, obj\n  )).toBeTrue()\n})\n\ntest('when false', () => {\n  expect(propIs(\n    String, property, obj\n  )).toBeFalse()\n  expect(propIs(\n    String, property, {}\n  )).toBeFalse()\n})",
    "explanation": "It returns `true` if `property` of `obj` is from `target` type.",
    "example": "const obj = {a:1, b: 'foo'}\nconst property = 'foo'\n\nconst result = [\n  R.propIs(String, property, obj),\n  R.propIs(Number, property, obj)\n]\n// => [true, false]",
    "typescriptDefinitionTest": "import {propIs} from 'rambda'\n\nconst property = 'a'\nconst obj = {a: 1}\n\ndescribe('propIs', () => {\n  it('happy', () => {\n    const result = propIs(\n      Number, property, obj\n    )\n    result // $ExpectType boolean\n  })\n\n  it('curried', () => {\n    const result = propIs(Number, property)(obj)\n    result // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('propIs', function() {\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propIs(String, 0, deities), true);\n    eq(R.propIs(String, 1, deities), true);\n    eq(R.propIs(String, 2, deities), true);\n    eq(R.propIs(String, -1, deities), true);\n    eq(R.propIs(String, 3, deities), false);\n  });\n});"
  },
  "propOr": {
    "typing": "propOr<T, U, V>(defaultValue: T, property: string, obj: U): V",
    "allTypings": "propOr<T, U, V>(defaultValue: T, property: string, obj: U): V;\npropOr<T>(defaultValue: T, property: string): <U, V>(obj: U) => V;\npropOr<T>(defaultValue: T): <U, V>(property: string, obj: U) => V;",
    "rambdaSource": "import { curry } from './curry'\nimport { defaultTo } from './defaultTo'\n\nfunction propOrFn(\n  defaultValue, property, obj\n){\n  if (!obj) return defaultValue\n\n  return defaultTo(defaultValue, obj[ property ])\n}\n\nexport const propOr = curry(propOrFn)",
    "rambdaSpecs": "import { propOr } from './propOr'\n\ntest('propOr (result)', () => {\n  const obj = { a : 1 }\n  expect(propOr(\n    'default', 'a', obj\n  )).toEqual(1)\n  expect(propOr(\n    'default', 'notExist', obj\n  )).toEqual('default')\n  expect(propOr(\n    'default', 'notExist', null\n  )).toEqual('default')\n})\n\ntest('propOr (currying)', () => {\n  const obj = { a : 1 }\n  expect(propOr('default')('a', obj)).toEqual(1)\n  expect(propOr('default', 'a')(obj)).toEqual(1)\n  expect(propOr('default')('notExist', obj)).toEqual('default')\n  expect(propOr('default', 'notExist')(obj)).toEqual('default')\n})",
    "explanation": "It returns either `defaultValue` or the value of `property` in `obj`.",
    "example": "const obj = {a: 1}\nconst defaultValue = 'DEFAULT_VALUE'\nconst property = 'a'\n\nconst result = [\n  R.propOr(defaultValue, property, obj),\n  R.propOr(defaultValue, 'foo', obj)\n]\n// => [1, 'DEFAULT_VALUE']",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('propOr', function() {\n  var fred = {name: 'Fred', age: 23};\n  var anon = {age: 99};\n  var nm = R.propOr('Unknown', 'name');\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propOr('Unknown', 0, deities), 'Cthulhu');\n    eq(R.propOr('Unknown', 1, deities), 'Dagon');\n    eq(R.propOr('Unknown', 2, deities), 'Yog-Sothoth');\n    eq(R.propOr('Unknown', -1, deities), 'Yog-Sothoth');\n    eq(R.propOr('Unknown', 3, deities), 'Unknown');\n  });\n});"
  },
  "range": {
    "typing": "range(start: number, end: number): number[]",
    "allTypings": "range(start: number, end: number): number[];\nrange(start: number): (end: number) => number[];",
    "rambdaSource": "export function range(start, end){\n  if (arguments.length === 1) return _end => range(start, _end)\n\n  if (Number.isNaN(Number(start)) || Number.isNaN(Number(end))){\n    throw new TypeError('Both arguments to range must be numbers')\n  }\n\n  if (end < start) return []\n\n  const len = end - start\n  const willReturn = Array(len)\n\n  for (let i = 0; i < len; i++){\n    willReturn[ i ] = start + i\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { range } from './range'\n\ntest('happy', () => {\n  expect(range(0, 10)).toEqual([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ])\n})\n\ntest('end range is bigger than start range', () => {\n  expect(range(7, 3)).toEqual([])\n  expect(range(5, 5)).toEqual([])\n})\n\ntest('with bad input', () => {\n  const throwMessage = 'Both arguments to range must be numbers'\n  expect(() => range('a', 6)).toThrow(throwMessage)\n  expect(() => range(6, 'z')).toThrow(throwMessage)\n})\n\ntest('curry', () => {\n  expect(range(0)(10)).toEqual([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ])\n})",
    "explanation": "It returns list of numbers between `start`(inclusive) to `end`(exclusive) numbers.",
    "example": "R.range(0, 5)\n// => [0, 1, 2, 3, 4]"
  },
  "reduce": {
    "typing": "reduce<T, TResult>(reducer: (prev: TResult, current: T, i: number) => TResult, initialValue: TResult, list: ReadonlyArray<T>): TResult",
    "allTypings": "reduce<T, TResult>(reducer: (prev: TResult, current: T, i: number) => TResult, initialValue: TResult, list: ReadonlyArray<T>): TResult;\nreduce<T, TResult>(reducer: (prev: TResult, current: T) => TResult, initialValue: TResult, list: ReadonlyArray<T>): TResult;\nreduce<T, TResult>(reducer: (prev: TResult, current: T, i?: number) => TResult): (initialValue: TResult, list: ReadonlyArray<T>) => TResult;\nreduce<T, TResult>(reducer: (prev: TResult, current: T, i?: number) => TResult, initialValue: TResult): (list: ReadonlyArray<T>) => TResult;",
    "notes": "It passes index of the list as third argument to `reducer` function.",
    "rambdaSource": "import { curry } from './curry'\n\nfunction reduceFn(\n  reducer, acc, list\n){\n  const clone = list.slice()\n\n  return clone.reduce(reducer, acc)\n}\n\nexport const reduce = curry(reduceFn)",
    "rambdaSpecs": "import { reduce } from './reduce'\n\ntest('happy', () => {\n  const reducer = (\n    prev, current, i\n  ) => {\n    expect(i).toBeNumber()\n\n    return prev + current\n  }\n  const initialValue = 1\n  const list = [ 1, 2, 3 ]\n\n  expect(reduce(\n    reducer, initialValue, list\n  )).toEqual(7)\n})",
    "example": "const list = [1, 2, 3]\nconst initialValue = 10\nconst reducer = (prev, current) => prev * current\n\nconst result = R.reduce(reducer, initialValue, list)\n// => 60",
    "typescriptDefinitionTest": "import {reduce} from 'rambda'\n\ndescribe('reduce', () => {\n  it('happy', () => {\n    const result = reduce<number, number>(\n      (acc, elem) => {\n        acc // $ExpectType number\n        elem // $ExpectType number\n        return acc + elem\n      },\n      1,\n      [1, 2, 3]\n    )\n\n    result // $ExpectType number\n  })\n\n  it('with two types', () => {\n    const result = reduce<number, string>(\n      (acc, elem) => {\n        acc // $ExpectType string\n        elem // $ExpectType number\n\n        return `${acc}${elem}`\n      },\n      'foo',\n      [1, 2, 3]\n    )\n\n    result // $ExpectType string\n  })\n\n  it('with index', () => {\n    const result = reduce<number, number>(\n      (acc, elem, i) => {\n        acc // $ExpectType number\n        elem // $ExpectType number\n        i // $ExpectType number\n        return acc + elem\n      },\n      1,\n      [1, 2, 3]\n    )\n\n    result // $ExpectType number\n  })\n\n  it('fallback', () => {\n    const result = reduce(\n      (acc, val) => {\n        acc // $ExpectType number\n        return acc + val\n      },\n      1,\n      [1, 2, 3]\n    )\n\n    result // $ExpectType number\n  })\n\n  it('fallback with index', () => {\n    const result = reduce(\n      (acc, val, i) => {\n        acc // $ExpectType number\n        i // $ExpectType number\n        return acc + val\n      },\n      1,\n      [1, 2, 3]\n    )\n\n    result // $ExpectType number\n  })\n\n  it('fallback with two types', () => {\n    const result = reduce(\n      (acc, val) => {\n        acc // $ExpectType string\n        return acc + val\n      },\n      'foo',\n      [1, 2, 3]\n    )\n\n    result // $ExpectType string\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('reduce', function() {\n  var add = function(a, b) {return a + b;};\n  var mult = function(a, b) {return a * b;};\n  it('Prefers the use of the iterator of an object over reduce (and handles short-circuits)', function() {\n    var symIterator = (typeof Symbol !== 'undefined') ? Symbol.iterator : '@@iterator';\n    function Reducible(arr) {\n      this.arr = arr;\n    }\n    Reducible.prototype.reduce = function(f, init) {\n      var acc = init;\n      for (var i = 0; i < this.arr.length; i += 1) {\n        acc = f(acc, this.arr[i]);\n      }\n      return acc;\n    };\n    Reducible.prototype[symIterator] = function() {\n      var a = this.arr;\n      return {\n        _pos: 0,\n        next: function() {\n          if (this._pos < a.length) {\n            var v = a[this._pos];\n            this._pos += 1;\n            return {\n              value: v,\n              done: false\n            };\n          } else {\n            return {\n              done: true\n            };\n          }\n        }\n      };\n    };\n    var xf = R.take(2);\n    var apendingT = { };\n    apendingT['@@transducer/result'] = R.identity;\n    apendingT['@@transducer/step'] = R.flip(R.append);\n    var rfn = xf(apendingT);\n    var list = new Reducible([1, 2, 3, 4, 5, 6]);\n    eq(R.reduce(rfn, [], list), [1, 2]);\n  });\n  it('short circuits with reduced', function() {\n    var addWithMaxOf10 = function(acc, val) {return acc + val > 10 ? R.reduced(acc) : acc + val;};\n    eq(R.reduce(addWithMaxOf10, 0, [1, 2, 3, 4]), 10);\n    eq(R.reduce(addWithMaxOf10, 0, [2, 4, 6, 8]), 6);\n  });\n});",
    "failedSpecsReasons": "rambda doesn't have `R.reduced` method | ramda method pass to `reduce` method",
    "failedSpecsCount": 2
  },
  "reject": {
    "typing": "reject<T>(predicate: FilterFunctionArray<T>): (x: T[]) => T[]",
    "allTypings": "reject<T>(predicate: FilterFunctionArray<T>): (x: T[]) => T[];\nreject<T>(predicate: FilterFunctionArray<T>, x: T[]): T[];\nreject<T, U>(predicate: FilterFunctionObject<T>): (x: Dictionary<T>) => Dictionary<T>;\nreject<T>(predicate: FilterFunctionObject<T>, x: Dictionary<T>): Dictionary<T>;",
    "notes": "As it uses `R.filter`, this method works also with objects.",
    "rambdaSource": "import { filter } from './filter'\n\nexport function reject(predicate, list){\n  if (arguments.length === 1) return _list => reject(predicate, _list)\n\n  return filter((x, i) => !predicate(x, i), list)\n}",
    "rambdaSpecs": "import { reject } from './reject'\n\nconst isOdd = n => n % 2 === 1\n\ntest('with array', () => {\n  expect(reject(isOdd, [ 1, 2, 3, 4 ])).toEqual([ 2, 4 ])\n})\n\ntest('with object', () => {\n  expect(reject(isOdd, {\n    a : 1,\n    b : 2,\n    c : 3,\n    d : 4,\n  })).toEqual({\n    b : 2,\n    d : 4,\n  })\n})\n\ntest('pass index as second argument', () => {\n  reject((x, i) => {\n    expect(typeof x).toBe('number')\n    expect(typeof i).toBe('number')\n  },\n  [ 10, 12, 15 ])\n})",
    "explanation": "It has the opposite effect of `R.filter`.\n\nIt will return those members of `list` that return `false` when applied to `predicate` function.",
    "example": "const list = [1, 2, 3, 4]\nconst predicate = x => x > 2\n\nconst result = [\n  R.reject(predicate, list)\n]\n// => [1, 2]",
    "typescriptDefinitionTest": "import {reject} from 'rambda'\n\ndescribe('reject with array', () => {\n  it('1 curry', () => {\n    const x = reject<number>(a => {\n      a // $ExpectType number\n      return a > 1\n    })([1, 2, 3])\n    x // $ExpectType number[]\n  })\n  it('1', () => {\n    const x = reject<number>(\n      a => {\n        a // $ExpectType number\n        return a > 1\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType number[]\n  })\n  it('2', () => {\n    const x = reject<number>(\n      (a, b) => {\n        a // $ExpectType number\n        return a > 1\n      },\n      [1, 2, 3]\n    )\n    x // $ExpectType number[]\n  })\n})\n\ndescribe('reject with objects', () => {\n  it('curry', () => {\n    const x = reject<number, number>((a, b, c) => {\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n\n      return a > 1\n    })({a: 1, b: 2})\n    x // $ExpectType Dictionary<number>\n  })\n\n  it('object with three arguments predicate', () => {\n    const x = reject<number>(\n      (a, b, c) => {\n        b // $ExpectType string\n        c // $ExpectType Dictionary<number>\n\n        return a > 1\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<number>\n  })\n\n  it('object with two arguments predicate', () => {\n    const x = reject<number>(\n      (a, b) => {\n        b // $ExpectType string\n        return a > 1\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<number>\n  })\n  it('object with one argument predicate', () => {\n    const x = reject<number>(\n      a => {\n        a // $ExpectType number\n        return a > 1\n      },\n      {a: 1, b: 2}\n    )\n    x // $ExpectType Dictionary<number>\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('reject', function() {\n  var even = function(x) {return x % 2 === 0;};\n  it('dispatches to `filter` method', function() {\n    function Nothing() {}\n    Nothing.value = new Nothing();\n    Nothing.prototype.filter = function() {\n      return this;\n    };\n    function Just(x) { this.value = x; }\n    Just.prototype.filter = function(pred) {\n      return pred(this.value) ? this : Nothing.value;\n    };\n    var m = new Just(42);\n    eq(R.filter(R.T, m), m);\n    eq(R.filter(R.F, m), Nothing.value);\n    eq(R.reject(R.T, m), Nothing.value);\n    eq(R.reject(R.F, m), m);\n  });\n});",
    "failedSpecsReasons": "ramda method dispatches to `filter` method",
    "failedSpecsCount": 1
  },
  "repeat": {
    "typing": "repeat<T>(x: T, timesToRepeat: number): T[]",
    "allTypings": "repeat<T>(x: T, timesToRepeat: number): T[];\nrepeat<T>(x: T): (timesToRepeat: number) => T[];",
    "rambdaSource": "export function repeat(x, timesToRepeat){\n  if (arguments.length === 1){\n    return _timesToRepeat => repeat(x, _timesToRepeat)\n  }\n\n  return Array(timesToRepeat).fill(x)\n}",
    "rambdaSpecs": "import { repeat } from './repeat'\n\ntest('repeat', () => {\n  expect(repeat('')(3)).toEqual([ '', '', '' ])\n  expect(repeat('foo', 3)).toEqual([ 'foo', 'foo', 'foo' ])\n\n  const obj = {}\n  const arr = repeat(obj, 3)\n\n  expect(arr).toEqual([ {}, {}, {} ])\n\n  expect(arr[ 0 ] === arr[ 1 ]).toBeTrue()\n})",
    "explanation": "It returns a list of `x` input repeated `timesToRepeat` input.",
    "example": "R.repeat('foo', 3)\n// => ['foo', 'foo', 'foo']"
  },
  "replace": {
    "typing": "replace(strOrRegex: RegExp | string, replacer: string, str: string): string",
    "allTypings": "replace(strOrRegex: RegExp | string, replacer: string, str: string): string;\nreplace(strOrRegex: RegExp | string, replacer: string): (str: string) => string;\nreplace(strOrRegex: RegExp | string): (replacer: string) => (str: string) => string;",
    "rambdaSource": "export function replace(\n  pattern, replacer, str\n){\n  if (replacer === undefined){\n    return (_replacer, _str) => replace(\n      pattern, _replacer, _str\n    )\n  } else if (str === undefined){\n    return _str => replace(\n      pattern, replacer, _str\n    )\n  }\n\n  return str.replace(pattern, replacer)\n}",
    "rambdaSpecs": "import { replace } from './replace'\n\ntest('happy', () => {\n  expect(replace(\n    'foo', 'yes', 'foo bar baz'\n  )).toEqual('yes bar baz')\n})\n\ntest('1', () => {\n  expect(replace(/\\s/g)('|')('foo bar baz')).toEqual('foo|bar|baz')\n})\n\ntest('2', () => {\n  expect(replace(/\\s/g)('|', 'foo bar baz')).toEqual('foo|bar|baz')\n})\n\ntest('3', () => {\n  expect(replace(/\\s/g, '|')('foo bar baz')).toEqual('foo|bar|baz')\n})",
    "explanation": "It replaces `strOrRegex` found in `str` with `replacer`.",
    "example": "const strOrRegex = /o/g\n\nconst result = R.replace(strOrRegex, '|0|', 'foo')\n// => 'f|0||0|'"
  },
  "reverse": {
    "typing": "reverse<T>(listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "reverse<T>(listOrString: ReadonlyArray<T>): T[];\nreverse(listOrString: string): string;",
    "rambdaSource": "export function reverse(listOrString){\n  if (typeof listOrString === 'string'){\n    return listOrString.split('').reverse()\n      .join('')\n  }\n\n  const clone = listOrString.slice()\n\n  return clone.reverse()\n}",
    "rambdaSpecs": "import { reverse } from './reverse'\n\ntest('happy', () => {\n  expect(reverse([ 1, 2, 3 ])).toEqual([ 3, 2, 1 ])\n})\n\ntest('with string', () => {\n  expect(reverse('baz')).toEqual('zab')\n})\n\ntest('it doesn\\'t mutate', () => {\n  const arr = [ 1, 2, 3 ]\n\n  expect(reverse(arr)).toEqual([ 3, 2, 1 ])\n\n  expect(arr).toEqual([ 1, 2, 3 ])\n})",
    "explanation": "It returns a reversed copy of `listOrString` input.",
    "example": "const result = [\n  R.reverse('foo'),\n  R.reverse([1, 2, 3])\n]\n// => ['oof', [3, 2, 1]"
  },
  "slice": {
    "typing": "slice(from: number, to: number, list: string): string",
    "allTypings": "slice(from: number, to: number, list: string): string;\nslice<T>(from: number, to: number, list: T[]): T[];\nslice(from: number, to: number): {\n  (list: string): string;\n  <T>(list: T[]): T[];\n};\nslice(from: number): {\n  (to: number, list: string): string;\n  <T>(to: number, list: T[]): T[];\n};",
    "rambdaSource": "import { curry } from './curry'\n\nfunction sliceFn(\n  from, to, list\n){\n  return list.slice(from, to)\n}\n\nexport const slice = curry(sliceFn)",
    "rambdaSpecs": "import { slice } from './slice'\n\ntest('slice', () => {\n  expect(slice(\n    1, 3, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'b', 'c' ])\n  expect(slice(\n    1, Infinity, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'b', 'c', 'd' ])\n  expect(slice(\n    0, -1, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'a', 'b', 'c' ])\n  expect(slice(\n    -3, -1, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'b', 'c' ])\n  expect(slice(\n    0, 3, 'ramda'\n  )).toEqual('ram')\n})",
    "explanation": "It returns `listOrString` between `from` and `to` indexes.",
    "example": "const list = [0, 1, 2, 3, 4, 5]\nconst str = 'FOO_BAR'\nconst from = 1\nconst to = 4\n\nconst result = [\n  R.slice(str, to, list),\n  R.slice(from, to, list)\n]\n// => ['OO_', [1, 2, 3]]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('slice', function() {\n  it('handles array-like object', function() {\n    var args = (function() { return arguments; }(1, 2, 3, 4, 5));\n    eq(R.slice(1, 4, args), [2, 3, 4]);\n  });\n});"
  },
  "sort": {
    "typing": "sort<T>(sortFn: (a: T, b: T) => number, list: ReadonlyArray<T>): T[]",
    "allTypings": "sort<T>(sortFn: (a: T, b: T) => number, list: ReadonlyArray<T>): T[];\nsort<T>(sortFn: (a: T, b: T) => number): (list: ReadonlyArray<T>) => T[];",
    "notes": "`sortFn` function must return a number.",
    "rambdaSource": "export function sort(sortFn, list){\n  if (arguments.length === 1) return _list => sort(sortFn, _list)\n\n  const clone = list.slice()\n\n  return clone.sort(sortFn)\n}",
    "rambdaSpecs": "import { sort } from './sort'\n\nconst fn = (a, b) => a > b ? 1 : -1\n\ntest('sort', () => {\n  expect(sort((a, b) => a - b)([ 2, 3, 1 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('it doesn\\'t mutate', () => {\n  const list = [ 'foo', 'bar', 'baz' ]\n\n  expect(sort(fn, list)).toEqual([ 'bar', 'baz', 'foo' ])\n\n  expect(list[ 0 ]).toBe('foo')\n  expect(list[ 1 ]).toBe('bar')\n  expect(list[ 2 ]).toBe('baz')\n})",
    "explanation": "It returns copy of `list` sorted by `sortFn` function.",
    "example": "const list = [\n  {a: 2},\n  {a: 3},\n  {a: 1}\n]\nconst sortFn = (x, y) => {\n  return x.a > y.a ? 1 : -1\n}\n\nconst result = R.sort(list, sortFn)\nconst expected = [\n  {a: 1},\n  {a: 2},\n  {a: 3}\n]\n// => `result` is equal to `expected`"
  },
  "sortBy": {
    "typing": "sortBy<T>(sortFn: (a: T) => Ord, list: ReadonlyArray<T>): T[]",
    "allTypings": "sortBy<T>(sortFn: (a: T) => Ord, list: ReadonlyArray<T>): T[];\nsortBy(sortFn: (a: any) => Ord): <T>(list: ReadonlyArray<T>) => T[];",
    "notes": "`sortFn` function must return a value to compare.",
    "rambdaSource": "export function sortBy(sortFn, list){\n  if (arguments.length === 1) return _list => sortBy(sortFn, _list)\n\n  const clone = list.slice()\n\n  return clone.sort((a, b) => {\n    const aSortResult = sortFn(a)\n    const bSortResult = sortFn(b)\n\n    if (aSortResult === bSortResult) return 0\n\n    return aSortResult < bSortResult ? -1 : 1\n  })\n}",
    "rambdaSpecs": "import { compose } from './compose'\nimport { prop } from './prop'\nimport { sortBy } from './sortBy'\nimport { toLower } from './toLower'\n\ntest('happy', () => {\n  const input = [ { a : 2 }, { a : 1 }, { a : 1 }, { a : 3 } ]\n  const expected = [ { a : 1 }, { a : 1 }, { a : 2 }, { a : 3 } ]\n\n  const result = sortBy(x => x.a)(input)\n  expect(result).toEqual(expected)\n})\n\ntest('with compose', () => {\n  const alice = {\n    name : 'ALICE',\n    age  : 101,\n  }\n  const bob = {\n    name : 'Bob',\n    age  : -10,\n  }\n  const clara = {\n    name : 'clara',\n    age  : 314.159,\n  }\n  const people = [ clara, bob, alice ]\n  const sortByNameCaseInsensitive = sortBy(compose(toLower, prop('name')))\n\n  expect(sortByNameCaseInsensitive(people)).toEqual([ alice, bob, clara ])\n})",
    "explanation": "It returns copy of `list` sorted by `sortFn` function.",
    "example": "const list = [\n  {a: 2},\n  {a: 3},\n  {a: 1}\n]\nconst sortFn = x => x.a\n\nconst result = R.sortBy(list, sortFn)\nconst expected = [\n  {a: 1},\n  {a: 2},\n  {a: 3}\n]\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {sortBy} from 'rambda'\n\ndescribe('sortBy', () => {\n  it('happy', () => {\n    interface Input {\n      a: number,\n    }\n\n    function fn(x: Input): number {\n      return x.a\n    }\n\n    const input: Input[] = [{a: 2}, {a: 1}, {a: 0}]\n    const result = sortBy(fn, input)\n\n    result // $ExpectType Input[]\n    result[0].a // $ExpectType number\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\nvar albums = [\n  {title: 'Art of the Fugue', artist: 'Glenn Gould', genre: 'Baroque'},\n  {title: 'A Farewell to Kings', artist: 'Rush', genre: 'Rock'},\n  {title: 'Timeout', artist: 'Dave Brubeck Quartet', genre: 'Jazz'},\n  {title: 'Fly By Night', artist: 'Rush', genre: 'Rock'},\n  {title: 'Goldberg Variations', artist: 'Daniel Barenboim', genre: 'Baroque'},\n  {title: 'New World Symphony', artist: 'Leonard Bernstein', genre: 'Romantic'},\n  {title: 'Romance with the Unseen', artist: 'Don Byron', genre: 'Jazz'},\n  {title: 'Somewhere In Time', artist: 'Iron Maiden', genre: 'Metal'},\n  {title: 'In Times of Desparation', artist: 'Danny Holt', genre: 'Modern'},\n  {title: 'Evita', artist: 'Various', genre: 'Broadway'},\n  {title: 'Five Leaves Left', artist: 'Nick Drake', genre: 'Folk'},\n  {title: 'The Magic Flute', artist: 'John Eliot Gardiner', genre: 'Classical'}\n];\ndescribe('sortBy', function() {\n  it('sorts array-like object', function() {\n    var args = (function() { return arguments; }('c', 'a', 'b'));\n    var result = R.sortBy(R.identity, args);\n    eq(result[0], 'a');\n    eq(result[1], 'b');\n    eq(result[2], 'c');\n  });\n});",
    "failedSpecsReasons": "ramda works with array-like objects",
    "failedSpecsCount": 1
  },
  "split": {
    "typing": "split(separator: string | RegExp): (str: string) => string[]",
    "allTypings": "split(separator: string | RegExp): (str: string) => string[];\nsplit(separator: string | RegExp, str: string): string[];",
    "rambdaSource": "export function split(separator, str){\n  if (arguments.length === 1) return _str => split(separator, _str)\n\n  return str.split(separator)\n}",
    "rambdaSpecs": "import { split } from './split'\n\ntest('split', () => {\n  expect(split('|')('foo|bar|baz')).toEqual([ 'foo', 'bar', 'baz' ])\n\n  expect(split('.', 'a.b.c.xyz.d')).toEqual([ 'a', 'b', 'c', 'xyz', 'd' ])\n})",
    "explanation": "Curried version of `String.prototype.split`",
    "example": "const str = 'foo|bar|baz'\nconst separator = |'\nconst result = R.split(separator, str))\n// => [ 'foo', 'bar', 'baz' ]"
  },
  "splitEvery": {
    "typing": "splitEvery<T>(sliceLength: number, listOrString: ReadonlyArray<T>): T[][]",
    "allTypings": "splitEvery<T>(sliceLength: number, listOrString: ReadonlyArray<T>): T[][];\nsplitEvery(sliceLength: number, listOrString: string): string[];\nsplitEvery(sliceLength: number): {\n  (listOrString: string): string[];\n  <T>(listOrString: ReadonlyArray<T>): T[][];\n};",
    "rambdaSource": "export function splitEvery(sliceLength, listOrString){\n  if (arguments.length === 1){\n    return _listOrString => splitEvery(sliceLength, _listOrString)\n  }\n\n  if (sliceLength < 1){\n    throw new Error('First argument to splitEvery must be a positive integer')\n  }\n\n  const willReturn = []\n  let counter = 0\n\n  while (counter < listOrString.length){\n    willReturn.push(listOrString.slice(counter, counter += sliceLength))\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { splitEvery } from './splitEvery'\n\ntest('happy', () => {\n  expect(splitEvery(3, [ 1, 2, 3, 4, 5, 6, 7 ])).toEqual([\n    [ 1, 2, 3 ],\n    [ 4, 5, 6 ],\n    [ 7 ],\n  ])\n\n  expect(splitEvery(3)('foobarbaz')).toEqual([ 'foo', 'bar', 'baz' ])\n})\n\ntest('with bad input', () => {\n  expect(() =>\n    expect(splitEvery(0)('foo')).toEqual([ 'f', 'o', 'o' ])).toThrow('First argument to splitEvery must be a positive integer')\n})",
    "explanation": "It splits `listOrString` into slices of `sliceLength`.",
    "example": "const result = [\n  R.splitEvery(2, [1, 2, 3]), \n  R.splitEvery(3, 'foobar') \n]\n\nconst expected = [\n  [[1, 2], [3]],\n  ['foo', 'bar']\n]\n// => `result` is equal to `expected`"
  },
  "startsWith": {
    "typing": "startsWith(target: string, str: string): boolean",
    "allTypings": "startsWith(target: string, str: string): boolean;\nstartsWith(target: string): (str: string) => boolean;",
    "notes": "It doesn't work with arrays unlike its corresponding **Ramda** method.",
    "rambdaSource": "export function startsWith(target, str){\n  if (arguments.length === 1) return _str => startsWith(target, _str)\n\n  return str.startsWith(target)\n}",
    "rambdaSpecs": "import { startsWith } from './startsWith'\n\ntest('true', () => {\n  const result = startsWith('foo', 'foo-bar')\n\n  expect(result).toBeTrue()\n})\n\ntest('false', () => {\n  const result = startsWith('baz')('foo-bar')\n\n  expect(result).toBeFalse()\n})",
    "explanation": "Curried version of `String.prototype.startsWith`",
    "example": "const str = 'foo-bar'\n\nconst result = [\n  R.startsWith('foo', str),\n  R.startsWith('bar', str)\n]\n// => [true, false]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('startsWith', function() {\n  it('should return true when an array starts with the provided value', function() {\n    eq(R.startsWith(['a'], ['a', 'b', 'c']), true);\n  });\n  it('should return true when an array starts with the provided values', function() {\n    eq(R.startsWith(['a', 'b'], ['a', 'b', 'c']), true);\n  });\n  it('should return false when an array does not start with the provided value', function() {\n    eq(R.startsWith(['b'], ['a', 'b', 'c']), false);\n  });\n  it('should return false when an array does not start with the provided values', function() {\n    eq(R.startsWith(['b', 'c'], ['a', 'b', 'c']), false);\n  });\n});",
    "failedSpecsReasons": "rambda doesn't support arrays",
    "failedSpecsCount": 4
  },
  "subtract": {
    "typing": "subtract(x: number, y: number): number",
    "allTypings": "subtract(x: number, y: number): number;\nsubtract(x: number): (y: number) => number;",
    "rambdaSource": "export function subtract(a, b){\n  if (arguments.length === 1) return _b => subtract(a, _b)\n\n  return a - b\n}",
    "rambdaSpecs": "import { subtract } from './subtract'\n\ntest('happy', () => {\n  expect(subtract(2, 1)).toEqual(1)\n  expect(subtract(2)(1)).toEqual(1)\n})",
    "explanation": "Curried version of `x - y`",
    "example": "const x = 3\nconst y = 1\n\nR.subtract(x, y) \n// => 2"
  },
  "sum": {
    "typing": "sum(list: ReadonlyArray<number>): number",
    "allTypings": "sum(list: ReadonlyArray<number>): number;",
    "rambdaSource": "export function sum(list){\n  return list.reduce((prev, current) => prev + current, 0)\n}",
    "rambdaSpecs": "import { sum } from './sum'\n\ntest('happy', () => {\n  expect(sum([ 1, 2, 3, 4, 5 ])).toBe(15)\n})",
    "example": "R.sum([1, 2, 3, 4, 5]) \n// => 15"
  },
  "symmetricDifference": {
    "typing": "symmetricDifference<T>(x: ReadonlyArray<T>, y: ReadonlyArray<T>): T[]",
    "allTypings": "symmetricDifference<T>(x: ReadonlyArray<T>, y: ReadonlyArray<T>): T[];\nsymmetricDifference<T>(x: ReadonlyArray<T>): <T>(y: ReadonlyArray<T>) => T[];",
    "notes": "`R.equals` is used to determine equality, i.e. it can be safely used with list of objects.",
    "rambdaSource": "import { concat } from './concat'\nimport { filter } from './filter'\nimport { includes } from './includes'\n\nexport function symmetricDifference(x, y){\n  if (arguments.length === 1){\n    return _y => symmetricDifference(x, _y)\n  }\n\n  return concat(filter(value => !includes(value, y), x),\n    filter(value => !includes(value, x), y))\n}",
    "rambdaSpecs": "import { symmetricDifference } from './symmetricDifference'\n\ntest('symmetricDifference', () => {\n  const list1 = [ 1, 2, 3, 4 ]\n  const list2 = [ 3, 4, 5, 6 ]\n  expect(symmetricDifference(list1)(list2)).toEqual([ 1, 2, 5, 6 ])\n\n  expect(symmetricDifference([], [])).toEqual([])\n})\n\ntest('symmetricDifference with objects', () => {\n  const list1 = [ { id : 1 }, { id : 2 }, { id : 3 }, { id : 4 } ]\n  const list2 = [ { id : 3 }, { id : 4 }, { id : 5 }, { id : 6 } ]\n  expect(symmetricDifference(list1)(list2)).toEqual([\n    { id : 1 },\n    { id : 2 },\n    { id : 5 },\n    { id : 6 },\n  ])\n})",
    "explanation": "It returns a merged list of `x` and `y` with all equal elements removed.",
    "example": "const x = [ 1, 2, 3, 4 ]\nconst y = [ 3, 4, 5, 6 ]\n\nconst result = symmetricDifference(x, y)\n// => [ 1, 2, 5, 6 ]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('symmetricDifference', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  var Z = [3, 4, 5, 6, 10];\n  var Z2 = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8];\n  it('does not allow duplicates in the output even if the input lists had duplicates', function() {\n    eq(R.symmetricDifference(M2, N2), [1, 2, 5, 6]);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.symmetricDifference([0], [-0]).length, 2);\n    eq(R.symmetricDifference([-0], [0]).length, 2);\n    eq(R.symmetricDifference([NaN], [NaN]).length, 0);\n    eq(R.symmetricDifference([new Just([42])], [new Just([42])]).length, 0);\n  });\n  it('will not create a \"sparse\" array', function() {\n    eq(R.symmetricDifference(M2, [3]).length, 3);\n  });\n});"
  },
  "T": {
    "typing": "T(): boolean",
    "allTypings": "T(): boolean;",
    "rambdaSource": "export function T(){\n  return true\n}",
    "example": "R.T() \n// => true"
  },
  "tail": {
    "typing": "tail<T>(listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "tail<T>(listOrString: ReadonlyArray<T>): T[];\ntail(listOrString: string): string;",
    "rambdaSource": "import { drop } from './drop'\n\nexport function tail(listOrString){\n  return drop(1, listOrString)\n}",
    "rambdaSpecs": "import { tail } from './tail'\n\ntest('tail', () => {\n  expect(tail([ 1, 2, 3 ])).toEqual([ 2, 3 ])\n  expect(tail([ 1, 2 ])).toEqual([ 2 ])\n  expect(tail([ 1 ])).toEqual([])\n  expect(tail([])).toEqual([])\n\n  expect(tail('abc')).toEqual('bc')\n  expect(tail('ab')).toEqual('b')\n  expect(tail('a')).toEqual('')\n  expect(tail('')).toEqual('')\n})",
    "explanation": "It returns all but the first element of `listOrString`.",
    "example": "const result = [\n  R.tail([1, 2, 3]),  \n  R.tail('foo') \n]\n// => [[2, 3], 'oo']"
  },
  "take": {
    "typing": "take<T>(howMany: number, listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "take<T>(howMany: number, listOrString: ReadonlyArray<T>): T[];\ntake(howMany: number, listOrString: string): string;\ntake<T>(howMany: number): {\n  (listOrString: string): string;\n  (listOrString: ReadonlyArray<T>): T[];\n};",
    "rambdaSource": "import baseSlice from './_internals/baseSlice'\n\nexport function take(howMany, listOrString){\n  if (arguments.length === 1)\n    return _listOrString => take(howMany, _listOrString)\n  if (howMany < 0) return listOrString.slice()\n  if (typeof listOrString === 'string') return listOrString.slice(0, howMany)\n\n  return baseSlice(\n    listOrString, 0, howMany\n  )\n}",
    "rambdaSpecs": "import { take } from './take'\n\ntest('happy', () => {\n  const arr = [ 'foo', 'bar', 'baz' ]\n\n  expect(take(1, arr)).toEqual([ 'foo' ])\n\n  expect(arr).toEqual([ 'foo', 'bar', 'baz' ])\n\n  expect(take(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar' ])\n  expect(take(3, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n  expect(take(4, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n  expect(take(3)('rambda')).toEqual('ram')\n})\n\ntest('with negative index', () => {\n  expect(take(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(take(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('with zero index', () => {\n  expect(take(0, [ 1, 2, 3 ])).toEqual([])\n})",
    "explanation": "It returns the first `howMany` elements of `listOrString`.",
    "example": "const howMany = 2\n\nconst result = [\n  R.take(howMany, [1, 2, 3]),\n  R.take(howMany, 'foobar'),\n]\n// => [[1, 2], 'fo']",
    "failedRamdaSpecs": "var assert = require('assert');\nvar sinon = require('sinon');\n\nvar R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('take', function() {\n  it('handles zero correctly (#1224)', function() {\n    eq(R.into([], R.take(0), [1, 2, 3]), []);\n  });\n  it('steps correct number of times', function() {\n    var spy = sinon.spy();\n    R.into([], R.compose(R.map(spy), R.take(2)), [1, 2, 3]);\n    sinon.assert.calledTwice(spy);\n  });\n  it('transducer called for every member of list if `n` is < 0', function() {\n    var spy = sinon.spy();\n    R.into([], R.compose(R.map(spy), R.take(-1)), [1, 2, 3]);\n    sinon.assert.calledThrice(spy);\n  });\n});",
    "failedSpecsReasons": "rambda doesn't have 'R.into` method",
    "failedSpecsCount": 3
  },
  "takeLast": {
    "typing": "takeLast<T>(howMany: number, listOrString: ReadonlyArray<T>): T[]",
    "allTypings": "takeLast<T>(howMany: number, listOrString: ReadonlyArray<T>): T[];\ntakeLast(howMany: number, listOrString: string): string;\ntakeLast<T>(howMany: number): {\n  (listOrString: string): string;\n  (listOrString: ReadonlyArray<T>): T[];\n};",
    "rambdaSource": "import baseSlice from './_internals/baseSlice'\n\nexport function takeLast(howMany, listOrString){\n  if (arguments.length === 1)\n    return _listOrString => takeLast(howMany, _listOrString)\n\n  const len = listOrString.length\n  if (howMany < 0) return listOrString.slice()\n  let numValue = howMany > len ? len : howMany\n\n  if (typeof listOrString === 'string')\n    return listOrString.slice(len - numValue)\n\n  numValue = len - numValue\n\n  return baseSlice(\n    listOrString, numValue, len\n  )\n}",
    "rambdaSpecs": "import { takeLast } from './takeLast'\n\ntest('with arrays', () => {\n  expect(takeLast(1, [ 'foo', 'bar', 'baz' ])).toEqual([ 'baz' ])\n\n  expect(takeLast(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'bar', 'baz' ])\n\n  expect(takeLast(3, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n\n  expect(takeLast(4, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n\n  expect(takeLast(10, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n})\n\ntest('with strings', () => {\n  expect(takeLast(3, 'rambda')).toEqual('bda')\n\n  expect(takeLast(7, 'rambda')).toEqual('rambda')\n})\n\ntest('with negative index', () => {\n  expect(takeLast(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(takeLast(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})",
    "explanation": "It returns the last `howMany` elements of `listOrString`.",
    "example": "const howMany = 2\n\nconst result = [\n  R.takeLast(howMany, [1, 2, 3]),\n  R.takeLast(howMany, 'foobar'),\n]\n// => [[2, 3], 'ar']"
  },
  "tap": {
    "typing": "tap<T>(fn: (a: T) => any, x: T): T",
    "allTypings": "tap<T>(fn: (a: T) => any, x: T): T;\ntap<T>(fn: (a: T) => any): (x: T) => T;",
    "rambdaSource": "export function tap(fn, x){\n  if (arguments.length === 1) return _x => tap(fn, _x)\n\n  fn(x)\n\n  return x\n}",
    "rambdaSpecs": "import { tap } from './tap'\n\ntest('tap', () => {\n  let a = 1\n  const sayX = x => a = x\n\n  expect(tap(sayX, 100)).toEqual(100)\n  expect(tap(sayX)(100)).toEqual(100)\n  expect(a).toEqual(100)\n})",
    "explanation": "It applies function `fn` to input `x` and returns `x`. \n\nOne use case is debuging in the middle of `R.compose`.",
    "example": "const list = [1, 2, 3]\n\nR.compose(\n  R.map(x => x * 2)\n  R.tap(console.log),\n  R.filter(x => x > 1)\n)(list)\n// => `2` and `3` will be logged",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\nvar listXf = require('./helpers/listXf');\nvar _curry2 = require('rambda/internal/_curry2');\n\ndescribe('tap', function() {\n  var pushToList = _curry2(function(lst, x) { lst.push(x); });\n  it('can act as a transducer', function() {\n    var sideEffect = [];\n    var numbers = [1,2,3,4,5];\n    var xf = R.compose(R.map(R.identity), R.tap(pushToList(sideEffect)));\n    eq(R.into([], xf, numbers), numbers);\n    eq(sideEffect, numbers);\n  });\n  it('dispatches to transformer objects', function() {\n    var sideEffect = [];\n    var pushToSideEffect = pushToList(sideEffect);\n    eq(R.tap(pushToSideEffect, listXf), {\n      f: pushToSideEffect,\n      xf: listXf\n    });\n  });\n});",
    "failedSpecsReasons": "ramda can act as a transducer",
    "failedSpecsCount": 2
  },
  "test": {
    "typing": "test(regExpression: RegExp): (str: string) => boolean",
    "allTypings": "test(regExpression: RegExp): (str: string) => boolean;\ntest(regExpression: RegExp, str: string): boolean;",
    "rambdaSource": "export function test(pattern, str){\n  if (arguments.length === 1) return _str => test(pattern, _str)\n\n  if (typeof pattern === 'string'){\n    throw new TypeError(`test requires a value of type RegExp as its first argument; received \"${ pattern }\"`)\n  }\n\n  return str.search(pattern) !== -1\n}",
    "rambdaSpecs": "import { test as testMethod } from './test'\n\ntest('happy', () => {\n  expect(testMethod(/^x/, 'xyz')).toBeTrue()\n\n  expect(testMethod(/^y/)('xyz')).toBeFalse()\n})\n\ntest('throws if first argument is not regex', () => {\n  expect(() => testMethod('foo', 'bar')).toThrow('test requires a value of type RegExp as its first argument; received \"foo\"')\n})",
    "explanation": "It determines whether `str` matches `regExpression`.",
    "example": "R.test(/^f/, 'foo')\n// => true"
  },
  "times": {
    "typing": "times<T>(fn: (i: number) => T, howMany: number): T[]",
    "allTypings": "times<T>(fn: (i: number) => T, howMany: number): T[];\ntimes<T>(fn: (i: number) => T): (howMany: number) => T[];",
    "rambdaSource": "import { map } from './map'\nimport { range } from './range'\n\nexport function times(fn, howMany){\n  if (arguments.length === 1) return _howMany => times(fn, _howMany)\n  if (!Number.isInteger(howMany) || howMany < 0){\n    throw new RangeError('n must be an integer')\n  }\n\n  return map(fn, range(0, howMany))\n}",
    "rambdaSpecs": "import assert from 'assert'\n\nimport { identity } from './identity'\nimport { times } from './times'\n\ntest('happy', () => {\n  const result = times(identity, 5)\n\n  expect(result).toEqual([ 0, 1, 2, 3, 4 ])\n})\n\ntest('with bad input', () => {\n  assert.throws(() => {\n    times(3)('cheers!')\n  }, RangeError)\n  assert.throws(() => {\n    times(identity, -1)\n  }, RangeError)\n})\n\ntest('curry', () => {\n  const result = times(identity)(5)\n\n  expect(result).toEqual([ 0, 1, 2, 3, 4 ])\n})",
    "explanation": "It returns the result of applying function `fn` over members of range array.\n\nThe range array includes numbers between `0` and `howMany`(exclusive).",
    "example": "const fn = x => x * 2\nconst howMany = 5\n\nR.times(fn, howMany)\n//=> [0, 2, 4, 6, 8]"
  },
  "toLower": {
    "typing": "toLower(str: string): string",
    "allTypings": "toLower(str: string): string;",
    "rambdaSource": "export function toLower(str){\n  return str.toLowerCase()\n}",
    "rambdaSpecs": "import { toLower } from './toLower'\n\ntest('toLower', () => {\n  expect(toLower('FOO|BAR|BAZ')).toEqual('foo|bar|baz')\n})",
    "example": "R.toLower('FOO')\n// => 'foo'"
  },
  "toUpper": {
    "typing": "toUpper(str: string): string",
    "allTypings": "toUpper(str: string): string;",
    "rambdaSource": "export function toUpper(str){\n  return str.toUpperCase()\n}",
    "rambdaSpecs": "import { toUpper } from './toUpper'\n\ntest('toUpper', () => {\n  expect(toUpper('foo|bar|baz')).toEqual('FOO|BAR|BAZ')\n})",
    "example": "R.toUpper('foo')\n// => 'FOO'"
  },
  "toPairs": {
    "typing": "toPairs<S>(obj: { [k: string]: S } | { [k: number]: S }): [string, S][]",
    "allTypings": "toPairs<S>(obj: { [k: string]: S } | { [k: number]: S }): [string, S][];",
    "rambdaSource": "export function toPairs(obj){\n  return Object.entries(obj)\n}",
    "rambdaSpecs": "import { toPairs } from './toPairs'\n\nconst obj = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\nconst expected = [\n  [ 'a', 1 ],\n  [ 'b', 2 ],\n  [ 'c', [ 3, 4 ] ],\n]\n\ntest('happy', () => {\n  expect(toPairs(obj)).toEqual(expected)\n})",
    "explanation": "It transforms an object to a list.",
    "example": "const list = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\nconst expected = [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', [ 3, 4 ] ] ]\n\nconst result = R.toPairs(list)\n// => `result` is equal to `expected`"
  },
  "toString": {
    "typing": "toString<T>(x: T): string",
    "allTypings": "toString<T>(x: T): string;",
    "rambdaSource": "export function toString(val){\n  return val.toString()\n}",
    "rambdaSpecs": "import { toString } from './toString'\n\ntest('happy', () => {\n  expect(toString([ 1, 2, 3 ])).toEqual('1,2,3')\n})",
    "example": "R.toString([1, 2]) \n// => '1,2'",
    "failedRamdaSpecs": "var assert = require('assert');\n\nvar R = require('../../../../dist/rambda.js');\ndescribe('toString', function() {\n  it('returns the string representation of null', function() {\n    assert.strictEqual(R.toString(null), 'null');\n  });\n  it('returns the string representation of undefined', function() {\n    assert.strictEqual(R.toString(undefined), 'undefined');\n  });\n  it('returns the string representation of a number primitive', function() {\n    assert.strictEqual(R.toString(0), '0');\n    assert.strictEqual(R.toString(-0), '-0');\n    assert.strictEqual(R.toString(1.23), '1.23');\n    assert.strictEqual(R.toString(-1.23), '-1.23');\n    assert.strictEqual(R.toString(1e+23), '1e+23');\n    assert.strictEqual(R.toString(-1e+23), '-1e+23');\n    assert.strictEqual(R.toString(1e-23), '1e-23');\n    assert.strictEqual(R.toString(-1e-23), '-1e-23');\n    assert.strictEqual(R.toString(Infinity), 'Infinity');\n    assert.strictEqual(R.toString(-Infinity), '-Infinity');\n    assert.strictEqual(R.toString(NaN), 'NaN');\n  });\n  it('returns the string representation of a string primitive', function() {\n    assert.strictEqual(R.toString('abc'), '\"abc\"');\n    assert.strictEqual(R.toString('x \"y\" z'), '\"x \\\\\"y\\\\\" z\"');\n    assert.strictEqual(R.toString(\"' '\"), '\"\\' \\'\"');\n    assert.strictEqual(R.toString('\" \"'), '\"\\\\\" \\\\\"\"');\n    assert.strictEqual(R.toString('\\b \\b'), '\"\\\\b \\\\b\"');\n    assert.strictEqual(R.toString('\\f \\f'), '\"\\\\f \\\\f\"');\n    assert.strictEqual(R.toString('\\n \\n'), '\"\\\\n \\\\n\"');\n    assert.strictEqual(R.toString('\\r \\r'), '\"\\\\r \\\\r\"');\n    assert.strictEqual(R.toString('\\t \\t'), '\"\\\\t \\\\t\"');\n    assert.strictEqual(R.toString('\\v \\v'), '\"\\\\v \\\\v\"');\n    assert.strictEqual(R.toString('\\0 \\0'), '\"\\\\0 \\\\0\"');\n    assert.strictEqual(R.toString('\\\\ \\\\'), '\"\\\\\\\\ \\\\\\\\\"');\n  });\n  it('returns the string representation of a Boolean object', function() {\n    assert.strictEqual(R.toString(new Boolean(true)), 'new Boolean(true)');\n    assert.strictEqual(R.toString(new Boolean(false)), 'new Boolean(false)');\n  });\n  it('returns the string representation of a Number object', function() {\n    assert.strictEqual(R.toString(new Number(0)), 'new Number(0)');\n    assert.strictEqual(R.toString(new Number(-0)), 'new Number(-0)');\n  });\n  it('returns the string representation of a String object', function() {\n    assert.strictEqual(R.toString(new String('abc')), 'new String(\"abc\")');\n    assert.strictEqual(R.toString(new String('x \"y\" z')), 'new String(\"x \\\\\"y\\\\\" z\")');\n    assert.strictEqual(R.toString(new String(\"' '\")), 'new String(\"\\' \\'\")');\n    assert.strictEqual(R.toString(new String('\" \"')), 'new String(\"\\\\\" \\\\\"\")');\n    assert.strictEqual(R.toString(new String('\\b \\b')), 'new String(\"\\\\b \\\\b\")');\n    assert.strictEqual(R.toString(new String('\\f \\f')), 'new String(\"\\\\f \\\\f\")');\n    assert.strictEqual(R.toString(new String('\\n \\n')), 'new String(\"\\\\n \\\\n\")');\n    assert.strictEqual(R.toString(new String('\\r \\r')), 'new String(\"\\\\r \\\\r\")');\n    assert.strictEqual(R.toString(new String('\\t \\t')), 'new String(\"\\\\t \\\\t\")');\n    assert.strictEqual(R.toString(new String('\\v \\v')), 'new String(\"\\\\v \\\\v\")');\n    assert.strictEqual(R.toString(new String('\\0 \\0')), 'new String(\"\\\\0 \\\\0\")');\n    assert.strictEqual(R.toString(new String('\\\\ \\\\')), 'new String(\"\\\\\\\\ \\\\\\\\\")');\n  });\n  it('returns the string representation of a Date object', function() {\n    assert.strictEqual(R.toString(new Date('2001-02-03T04:05:06.000Z')), 'new Date(\"2001-02-03T04:05:06.000Z\")');\n    assert.strictEqual(R.toString(new Date('XXX')), 'new Date(NaN)');\n  });\n  it('returns the string representation of an array', function() {\n    assert.strictEqual(R.toString([]), '[]');\n    assert.strictEqual(R.toString([1, 2, 3]), '[1, 2, 3]');\n    assert.strictEqual(R.toString([1, [2, [3]]]), '[1, [2, [3]]]');\n    assert.strictEqual(R.toString(['x', 'y']), '[\"x\", \"y\"]');\n  });\n  it('returns the string representation of an array with non-numeric property names', function() {\n    var xs = [1, 2, 3];\n    xs.foo = 0;\n    xs.bar = 0;\n    xs.baz = 0;\n    assert.strictEqual(R.toString(xs), '[1, 2, 3, \"bar\": 0, \"baz\": 0, \"foo\": 0]');\n  });\n  it('returns the string representation of an arguments object', function() {\n    assert.strictEqual(R.toString((function() { return arguments; })()), '(function() { return arguments; }())');\n    assert.strictEqual(R.toString((function() { return arguments; })(1, 2, 3)), '(function() { return arguments; }(1, 2, 3))');\n    assert.strictEqual(R.toString((function() { return arguments; })(['x', 'y'])), '(function() { return arguments; }([\"x\", \"y\"]))');\n  });\n  it('returns the string representation of a plain object', function() {\n    assert.strictEqual(R.toString({}), '{}');\n    assert.strictEqual(R.toString({foo: 1, bar: 2, baz: 3}), '{\"bar\": 2, \"baz\": 3, \"foo\": 1}');\n    assert.strictEqual(R.toString({'\"quoted\"': true}), '{\"\\\\\"quoted\\\\\"\": true}');\n    assert.strictEqual(R.toString({a: {b: {c: {}}}}), '{\"a\": {\"b\": {\"c\": {}}}}');\n  });\n  it('treats instance without custom `toString` method as plain object', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    assert.strictEqual(R.toString(new Point(1, 2)), '{\"x\": 1, \"y\": 2}');\n  });\n  it('dispatches to custom `toString` method', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    Point.prototype.toString = function() {\n      return 'new Point(' + this.x + ', ' + this.y + ')';\n    };\n    assert.strictEqual(R.toString(new Point(1, 2)), 'new Point(1, 2)');\n    function Just(x) {\n      if (!(this instanceof Just)) {\n        return new Just(x);\n      }\n      this.value = x;\n    }\n    Just.prototype.toString = function() {\n      return 'Just(' + R.toString(this.value) + ')';\n    };\n    assert.strictEqual(R.toString(Just(42)), 'Just(42)');\n    assert.strictEqual(R.toString(Just([1, 2, 3])), 'Just([1, 2, 3])');\n    assert.strictEqual(R.toString(Just(Just(Just('')))), 'Just(Just(Just(\"\")))');\n    assert.strictEqual(R.toString({toString: R.always('x')}), 'x');\n  });\n  it('handles object with no `toString` method', function() {\n    if (typeof Object.create === 'function') {\n      var a = Object.create(null);\n      var b = Object.create(null); b.x = 1; b.y = 2;\n      assert.strictEqual(R.toString(a), '{}');\n      assert.strictEqual(R.toString(b), '{\"x\": 1, \"y\": 2}');\n    }\n  });\n  it('handles circular references', function() {\n    var a = [];\n    a[0] = a;\n    assert.strictEqual(R.toString(a), '[<Circular>]');\n    var o = {};\n    o.o = o;\n    assert.strictEqual(R.toString(o), '{\"o\": <Circular>}');\n    var b = ['bee'];\n    var c = ['see'];\n    b[1] = c;\n    c[1] = b;\n    assert.strictEqual(R.toString(b), '[\"bee\", [\"see\", <Circular>]]');\n    assert.strictEqual(R.toString(c), '[\"see\", [\"bee\", <Circular>]]');\n    var p = {};\n    var q = {};\n    p.q = q;\n    q.p = p;\n    assert.strictEqual(R.toString(p), '{\"q\": {\"p\": <Circular>}}');\n    assert.strictEqual(R.toString(q), '{\"p\": {\"q\": <Circular>}}');\n    var x = [];\n    var y = {};\n    x[0] = y;\n    y.x = x;\n    assert.strictEqual(R.toString(x), '[{\"x\": <Circular>}]');\n    assert.strictEqual(R.toString(y), '{\"x\": [<Circular>]}');\n  });\n});"
  },
  "transpose": {
    "typing": "transpose<T>(list: T[][]): T[][]",
    "allTypings": "transpose<T>(list: T[][]): T[][];",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function transpose(array){\n  return array.reduce((acc, el) => {\n    el.forEach((nestedEl, i) =>\n      _isArray(acc[ i ]) ? acc[ i ].push(nestedEl) : acc.push([ nestedEl ]))\n\n    return acc\n  }, [])\n}",
    "rambdaSpecs": "import { transpose } from './transpose'\n\ntest('happy', () => {\n  const input = [\n    [ 'a', 1 ],\n    [ 'b', 2 ],\n    [ 'c', 3 ],\n  ]\n\n  expect(transpose(input)).toEqual([\n    [ 'a', 'b', 'c' ],\n    [ 1, 2, 3 ],\n  ])\n})\n\ntest('when rows are shorter', () => {\n  const actual = transpose([ [ 10, 11 ], [ 20 ], [], [ 30, 31, 32 ] ])\n  const expected = [ [ 10, 20, 30 ], [ 11, 31 ], [ 32 ] ]\n  expect(actual).toEqual(expected)\n})\n\ntest('with empty array', () => {\n  expect(transpose([])).toEqual([])\n})\n\ntest('array with falsy values', () => {\n  const actual = transpose([\n    [ true, false, undefined, null ],\n    [ null, undefined, false, true ],\n  ])\n  const expected = [\n    [ true, null ],\n    [ false, undefined ],\n    [ undefined, false ],\n    [ null, true ],\n  ]\n  expect(actual).toEqual(expected)\n})",
    "example": "const list = [[10, 11], [20], [], [30, 31, 32]]\nconst expected = [[10, 20, 30], [11, 31], [32]]\n\nconst result = R.transpose(list)\n// => `result` is equal to `expected`"
  },
  "trim": {
    "typing": "trim(str: string): string",
    "allTypings": "trim(str: string): string;",
    "rambdaSource": "export function trim(str){\n  return str.trim()\n}",
    "rambdaSpecs": "import { trim } from './trim'\n\ntest('trim', () => {\n  expect(trim(' foo ')).toEqual('foo')\n})",
    "example": "R.trim('  foo  ') \n// => 'foo'",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('trim', function() {\n  var test = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFFHello, World!\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n  it('trims all ES5 whitespace', function() {\n    eq(R.trim(test), 'Hello, World!');\n    eq(R.trim(test).length, 13);\n  });\n  if (typeof String.prototype.trim !== 'function') {\n    it('falls back to a shim if String.prototype.trim is not present', function() {\n      eq(R.trim('   xyz  '), 'xyz');\n      eq(R.trim(test), 'Hello, World!');\n      eq(R.trim(test).length, 13);\n      eq(R.trim('\\u200b'), '\\u200b');\n      eq(R.trim('\\u200b').length, 1);\n    });\n  }\n});",
    "failedSpecsReasons": "ramda trims all ES5 whitespace",
    "failedSpecsCount": 1
  },
  "type": {
    "typing": "type(x: any): \"Object\" | \"Number\" | \"Boolean\" | \"String\" | \"Null\" | \"Array\" | \"Function\" | \"Undefined\" | \"Async\" | \"Promise\" | \"RegExp\" | \"NaN\"",
    "allTypings": "type(x: any): \"Object\" | \"Number\" | \"Boolean\" | \"String\" | \"Null\" | \"Array\" | \"Function\" | \"Undefined\" | \"Async\" | \"Promise\" | \"RegExp\" | \"NaN\";",
    "notes": "`NaN`, `Promise` and `Async` are types specific for **Rambda**.",
    "rambdaSource": "import { _isArray } from './_internals/_isArray'\n\nexport function type(input){\n  const typeOf = typeof input\n\n  if (input === null){\n    return 'Null'\n  } else if (input === undefined){\n    return 'Undefined'\n  } else if (typeOf === 'boolean'){\n    return 'Boolean'\n  } else if (typeOf === 'number'){\n    return Number.isNaN(input) ? 'NaN' : 'Number'\n  } else if (typeOf === 'string'){\n    return 'String'\n  } else if (_isArray(input)){\n    return 'Array'\n  } else if (input instanceof RegExp){\n    return 'RegExp'\n  }\n\n  const asStr = input && input.toString ? input.toString() : ''\n\n  if ([ 'true', 'false' ].includes(asStr)) return 'Boolean'\n  if (!Number.isNaN(Number(asStr))) return 'Number'\n  if (asStr.startsWith('async')) return 'Async'\n  if (asStr === '[object Promise]') return 'Promise'\n  if (typeOf === 'function') return 'Function'\n  if (input instanceof String) return 'String'\n\n  return 'Object'\n}",
    "rambdaSpecs": "import { type as ramdaType } from 'ramda'\n\nimport { type } from './type'\n\ntest('with simple promise', () => {\n  expect(type(Promise.resolve(1))).toBe('Promise')\n})\n\ntest('with new Boolean', () => {\n  expect(type(new Boolean(true))).toBe('Boolean')\n})\n\ntest('with new String', () => {\n  expect(type(new String('I am a String object'))).toEqual('String')\n})\n\ntest('with new Number', () => {\n  expect(type(new Number(1))).toBe('Number')\n})\n\ntest('with new promise', () => {\n  const delay = ms =>\n    new Promise(resolve => {\n      setTimeout(() => {\n        resolve(ms + 110)\n      }, ms)\n    })\n\n  expect(type(delay(10))).toEqual('Promise')\n})\n\ntest('async function', () => {\n  expect(type(async () => {})).toEqual('Async')\n})\n\ntest('async arrow', () => {\n  const asyncArrow = async () => {}\n  expect(type(asyncArrow)).toBe('Async')\n})\n\ntest('function', () => {\n  const fn1 = () => {}\n  const fn2 = function (){}\n\n  function fn3(){}\n\n  ;[ () => {}, fn1, fn2, fn3 ].map(val => {\n    expect(type(val)).toEqual('Function')\n  })\n})\n\ntest('object', () => {\n  expect(type({})).toEqual('Object')\n})\n\ntest('number', () => {\n  expect(type(1)).toEqual('Number')\n})\n\ntest('boolean', () => {\n  expect(type(false)).toEqual('Boolean')\n})\n\ntest('string', () => {\n  expect(type('foo')).toEqual('String')\n})\n\ntest('null', () => {\n  expect(type(null)).toEqual('Null')\n})\n\ntest('array', () => {\n  expect(type([])).toEqual('Array')\n  expect(type([ 1, 2, 3 ])).toEqual('Array')\n})\n\ntest('regex', () => {\n  expect(type(/\\s/g)).toEqual('RegExp')\n})\n\ntest('undefined', () => {\n  expect(type(undefined)).toEqual('Undefined')\n})\n\ntest('not a number', () => {\n  expect(type(Number('s'))).toBe('NaN')\n})\n\ntest('function inside object 1', () => {\n  const obj = {\n    f(){\n      return 4\n    },\n  }\n\n  expect(type(obj.f)).toBe('Function')\n  expect(ramdaType(obj.f)).toBe('Function')\n})\n\ntest('function inside object 2', () => {\n  const name = 'f'\n  const obj = {\n    [ name ](){\n      return 4\n    },\n  }\n  expect(type(obj.f)).toBe('Function')\n  expect(ramdaType(obj.f)).toBe('Function')\n})",
    "explanation": "It accepts any input and it returns its type.",
    "example": "R.type(() => {}) // => 'Function'\nR.type(async () => {}) // => 'Async'\nR.type([]) // => 'Array'\nR.type({}) // => 'Object'\nR.type('foo') // => 'String'\nR.type(1) // => 'Number'\nR.type(true) // => 'Boolean'\nR.type(null) // => 'Null'\nR.type(/[A-z]/) // => 'RegExp'\nR.type('foo'*1) // => 'NaN'\n\nconst delay = ms => new Promise(resolve => {\n  setTimeout(function () {\n    resolve()\n  }, ms)\n})\nR.type(delay) // => 'Promise'",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('type', function() {\n  // it('\"Arguments\" if given an arguments object', function() {\n  //   var args = (function() { return arguments; }());\n  //   eq(R.type(args), 'Arguments');\n  // });\n  it('\"Number\" if given the NaN value', function() {\n    eq(R.type(NaN), 'Number');\n  });\n});",
    "failedSpecsReasons": "ramda returns 'Number' type to NaN input, while rambda returns 'NaN'",
    "failedSpecsCount": 1
  },
  "uniq": {
    "typing": "uniq<T>(list: ReadonlyArray<T>): T[]",
    "allTypings": "uniq<T>(list: ReadonlyArray<T>): T[];",
    "notes": "`R.equals` is used to determine equality",
    "rambdaSource": "import { includes } from './includes'\n\nexport function uniq(list){\n  let index = -1\n  const willReturn = []\n\n  while (++index < list.length){\n    const value = list[ index ]\n\n    if (!includes(value, willReturn)){\n      willReturn.push(value)\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { uniq } from './uniq'\n\ntest('uniq', () => {\n  expect(uniq([ 1, 2, 3, 3, 3, 1, 2, 0 ])).toEqual([ 1, 2, 3, 0 ])\n  expect(uniq([ 1, 1, 2, 1 ])).toEqual([ 1, 2 ])\n  expect([ 1, '1' ]).toEqual([ 1, '1' ])\n  expect(uniq([ [ 42 ], [ 42 ] ])).toEqual([ [ 42 ] ])\n})",
    "explanation": "It returns a new array containing only one copy of each element of `list`.",
    "example": "const list = [1, 1, {a: 1}, {a: 2}, {a:1}]\n\nR.uniq(list)\n// => [1, {a: 1}, {a: 2}]",
    "typescriptDefinitionTest": "import {uniq} from 'rambda'\n\ndescribe('uniq', () => {\n  it('happy', () => {\n    const result = uniq([1, 2, 3, 3, 3, 1, 2, 0])\n    result // $ExpectType number[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('uniq', function() {\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.uniq([-0, -0]).length, 1);\n    eq(R.uniq([0, -0]).length, 2);\n    eq(R.uniq([NaN, NaN]).length, 1);\n    eq(R.uniq([[1], [1]]).length, 1);\n    eq(R.uniq([new Just([42]), new Just([42])]).length, 1);\n  it('handles null and undefined elements', function() {\n    eq(R.uniq([void 0, null, void 0, null]), [void 0, null]);\n  it('uses reference equality for functions', function() {\n    eq(R.uniq([R.add, R.identity, R.add, R.identity, R.add, R.identity]).length, 2);\n});",
    "failedSpecsReasons": "ramda pass to `uniq` method | ramda method uses reference equality for functions",
    "failedSpecsCount": 2
  },
  "uniqWith": {
    "typing": "uniqWith<T, U>(uniqFn: (x: T, y: T) => boolean, list: ReadonlyArray<T>): T[]",
    "allTypings": "uniqWith<T, U>(uniqFn: (x: T, y: T) => boolean, list: ReadonlyArray<T>): T[];\nuniqWith<T, U>(uniqFn: (x: T, y: T) => boolean): (list: ReadonlyArray<T>) => T[];",
    "rambdaSource": "import { any } from './any'\n\nexport function uniqWith(fn, list){\n  if (arguments.length === 1) return _list => uniqWith(fn, _list)\n\n  let index = -1\n  const len = list.length\n  const willReturn = []\n\n  while (++index < len){\n    const value = list[ index ]\n    const flag = any(willReturnInstance => fn(value, willReturnInstance),\n      willReturn)\n\n    if (!flag){\n      willReturn.push(value)\n    }\n  }\n\n  return willReturn\n}",
    "rambdaSpecs": "import { uniqWith } from './uniqWith'\n\ntest('happy', () => {\n  const input = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n    {\n      id    : 3,\n      title : 'foo',\n    },\n    {\n      id    : 4,\n      title : 'bar',\n    },\n  ]\n\n  const expectedResult = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n  ]\n\n  const fn = (x, y) => x.title === y.title\n\n  const result = uniqWith(fn, input)\n  const curriedResult = uniqWith(fn)(input)\n\n  expect(result).toEqual(expectedResult)\n\n  expect(curriedResult).toEqual(expectedResult)\n})\n\ntest('uniqWith', () => {\n  const input = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n    {\n      id    : 3,\n      title : 'foo',\n    },\n    {\n      id    : 4,\n      title : 'bar',\n    },\n  ]\n\n  const expectedResult = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n  ]\n\n  const fn = (x, y) => x.title === y.title\n\n  const result = uniqWith(fn, input)\n  //const result = uniqWith(Ramda.eqBy(Ramda.prop('title')), input)\n\n  expect(result).toEqual(expectedResult)\n})",
    "explanation": "It returns a new array containing only one copy of each element in `list` according to boolean returning function `uniqFn`.",
    "example": "const list = [\n  {id: 0, title:'foo'},\n  {id: 1, title:'bar'},\n  {id: 2, title:'baz'},\n  {id: 3, title:'foo'},\n  {id: 4, title:'bar'},\n]\n\nconst expected = [\n  {id: 0, title:'foo'},\n  {id: 1, title:'bar'},\n  {id: 2, title:'baz'},\n]\n\nconst uniqFn = (x,y) => x.title === y.title\n\nconst result = R.uniqWith(uniqFn, list)\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {uniqWith} from 'rambda'\n\ndescribe('uniqWith', () => {\n  it('happy', () => {\n    const input = [\n      {\n        id: 0,\n        title: 'foo',\n      },\n      {\n        id: 1,\n        title: 'bar',\n      },\n      {\n        id: 2,\n        title: 'baz',\n      },\n      {\n        id: 3,\n        title: 'foo',\n      },\n      {\n        id: 4,\n        title: 'bar',\n      },\n    ]\n\n    const fn = (x: any, y: any) => x.title === y.title\n\n    const result = uniqWith(fn, input)\n    result // $ExpectType { id: number; title: string; }[]\n  })\n})"
  },
  "update": {
    "typing": "update<T>(index: number, newValue: T, list: ReadonlyArray<T>): T[]",
    "allTypings": "update<T>(index: number, newValue: T, list: ReadonlyArray<T>): T[];\nupdate<T>(index: number, newValue: T): (list: ReadonlyArray<T>) => T[];",
    "rambdaSource": "import { curry } from './curry'\n\nfunction updateFn(\n  index, newValue, list\n){\n  const arrClone = list.slice()\n\n  return arrClone.fill(\n    newValue, index, index + 1\n  )\n}\n\nexport const update = curry(updateFn)",
    "rambdaSpecs": "import { update } from './update'\n\nconst list = [ 1, 2, 3 ]\n\ntest('happy', () => {\n  const newValue = 8\n  const index = 1\n  const result = update(\n    index, newValue, list\n  )\n  const curriedResult = update(index, newValue)(list)\n  const tripleCurriedResult = update(index)(newValue)(list)\n\n  const expected = [ 1, 8, 3 ]\n  expect(result).toEqual(expected)\n  expect(curriedResult).toEqual(expected)\n  expect(tripleCurriedResult).toEqual(expected)\n})\n\ntest('list has no such index', () => {\n  const newValue = 8\n  const index = 10\n  const result = update(\n    index, newValue, list\n  )\n\n  expect(result).toEqual(list)\n})",
    "explanation": "It returns a copy of `list` with updated element at `index` with `newValue`.",
    "example": "const index = 2\nconst newValue = 88\nconst list = [1, 2, 3, 4, 5]\n\nconst result = R.update(index, newValue, list)\n// => [1, 2, 88, 4, 5]",
    "typescriptDefinitionTest": "import {update} from 'rambda'\n\ndescribe('update', () => {\n  it('happy', () => {\n    const result = update(1, 0, [1, 2, 3])\n    result // $ExpectType number[]\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('update', function() {\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.update(2, 4, args(0, 1, 2, 3)), [0, 1, 4, 3]);\n  });\n});",
    "failedSpecsReasons": "ramda accepts an array-like object",
    "failedSpecsCount": 1
  },
  "values": {
    "typing": "values<T extends object, K extends keyof T>(obj: T): T[K][]",
    "allTypings": "values<T extends object, K extends keyof T>(obj: T): T[K][];",
    "rambdaSource": "import { type } from './type'\n\nexport function values(obj){\n  if (type(obj) !== 'Object') return []\n\n  return Object.values(obj)\n}",
    "rambdaSpecs": "import { values } from './values'\n\ntest('happy', () => {\n  expect(values({\n    a : 1,\n    b : 2,\n    c : 3,\n  })).toEqual([ 1, 2, 3 ])\n})\n\ntest('with bad input', () => {\n  expect(values(null)).toEqual([])\n  expect(values(undefined)).toEqual([])\n  expect(values(55)).toEqual([])\n  expect(values('foo')).toEqual([])\n  expect(values(true)).toEqual([])\n  expect(values(false)).toEqual([])\n  expect(values(NaN)).toEqual([])\n  expect(values(Infinity)).toEqual([])\n  expect(values([])).toEqual([])\n})",
    "explanation": "With correct input, this is nothing more than `Object.values(obj)`. If `obj` is not an object, then it returns an empty array.",
    "example": "const obj = {a:1, b:2}\n\nR.values(obj)\n// => [1, 2]",
    "typescriptDefinitionTest": "import {values} from 'rambda'\n\ndescribe('values', () => {\n  it('happy', () => {\n    const result = values({\n      a: 1,\n      b: 2,\n      c: 3,\n    })\n    result // $ExpectType number[]\n  })\n})"
  },
  "when": {
    "typing": "when<T>(\n  rule: Func<boolean>, resultOrFunction: T | IdentityFunction<T>\n): IdentityFunction<T>",
    "allTypings": "when<T>(\n  rule: Func<boolean>, resultOrFunction: T | IdentityFunction<T>\n): IdentityFunction<T>;\nwhen<T>(\n  rule: Func<boolean>\n): (resultOrFunction: T | IdentityFunction<T>) => IdentityFunction<T>;",
    "rambdaSource": "import { isFunction } from './isFunction'\n\nexport function when(rule, resultOrFunction){\n  if (arguments.length === 1){\n    return whenTrueHolder => when(rule, whenTrueHolder)\n  }\n\n  return input => {\n    if (!rule(input)) return input\n\n    return isFunction(resultOrFunction) ?\n      resultOrFunction(input) :\n      resultOrFunction\n  }\n}",
    "rambdaSpecs": "import { add } from './add'\nimport { is } from './is'\nimport { when } from './when'\n\nconst ruleResult = 'RULE_RESULT'\nconst rule = x => typeof x === 'number'\nconst fn = when(rule, ruleResult)\nconst curriedFn = when(rule)(ruleResult)\n\ntest('when rule returns true', () => {\n  const input = 7\n\n  expect(fn(input)).toBe(ruleResult)\n})\n\ntest('when rule returns false', () => {\n  const input = 'foo'\n\n  expect(fn(input)).toBe(input)\n  expect(curriedFn(input)).toBe(input)\n})\n\ntest('second argument can be a function', () => {\n  const fn = when(is(Number), add(1))\n  expect(fn(10)).toBe(11)\n})",
    "example": "It accepts `rule` and `resultOrFunction` as arguments and returns a function with `input`.\n\nThis function will return `input` if `rule(input)` is false.\n\nIf `resultOrFunction` is function, it will return `resultOrFunction(input)`.\n\nIf `resultOrFunction` is not function, it will return `resultOrFunction`.\n\nMaybe the example use will do a better job in explaining this method.\n\n\nconst rule = x => typeof x === 'number'\nconst whenTrueResult = 6345789\nconst whenTrueFn = R.add(11)\n\nconst fnWithResult = when(rule, whenTrueResult)\nconst fnWithFunction = when(rule, whenTrueFn)\n\nconst goodInput = 88\nconst badInput = 'foo'\n\nconst result = [\n  fnWithResult(goodInput),\n  fnWithResult(badInput),\n  fnWithFn(goodInput)\n  fnWithFn(badInput),\n]\n\nconst expected = [\n  6345789,\n  'foo',\n  99,\n  'foo'\n]\n// => `result` is equal to `expected`",
    "typescriptDefinitionTest": "import {when, add} from 'rambda'\n\nconst ruleResult = 88\nconst rule = (x: number) => x > 2\n\ndescribe('when', () => {\n  it('without passing type - happy', () => {\n    const fn = when(rule, ruleResult)\n    const result = [\n      fn(1),\n      fn(2)\n    ]\n    result[0] // $ExpectType number\n    result[1] // $ExpectType number\n  })\n\n  it('without passing type - second argument is function', () => {\n    const fn = when(rule, add(1))\n    const fnCurried = when(rule)(add(1))\n    const [result1, result2] = [\n      fn(1),\n      fnCurried(2),\n    ]\n    result1 // $ExpectType number\n    result2 // $ExpectType unknown\n  })\n\n  it('with passing type', () => {\n    const fn = when<number>(rule, ruleResult)\n    const result = fn(1) \n    result // $ExpectType number\n  })\n\n  it('with passing type - second argument is function', () => {\n    const fn = when<number>(rule, add(1))\n    const fnCurried = when<number>(rule)(add(1))\n    const [result1, result2] = [\n      fn(1),\n      fnCurried(2),\n    ]\n    result1 // $ExpectType number\n    result2 // $ExpectType number\n  })\n\n  it('curry', () => {\n    const fn = when<number>(rule)(ruleResult)\n    const result = fn(1) \n    result // $ExpectType number\n  })\n})"
  },
  "without": {
    "typing": "without<T>(matchAgainst: ReadonlyArray<T>, source: ReadonlyArray<T>): T[]",
    "allTypings": "without<T>(matchAgainst: ReadonlyArray<T>, source: ReadonlyArray<T>): T[];\nwithout<T>(matchAgainst: ReadonlyArray<T>): (source: ReadonlyArray<T>) => T[];",
    "notes": "`R.equals` is used to determine equality",
    "rambdaSource": "import { includes } from './includes'\nimport { reduce } from './reduce'\n\nexport function without(matchAgainst, source){\n  if (source === undefined){\n    return _source => without(matchAgainst, _source)\n  }\n\n  return reduce(\n    (prev, current) =>\n      includes(current, matchAgainst) ? prev : prev.concat(current),\n    [],\n    source\n  )\n}",
    "rambdaSpecs": "import { without } from './without'\n\ntest('should return a new list without values in the first argument ', () => {\n  const itemsToOmit = [ 'A', 'B', 'C' ]\n  const collection = [ 'A', 'B', 'C', 'D', 'E', 'F' ]\n\n  expect(without(itemsToOmit, collection)).toEqual([ 'D', 'E', 'F' ])\n  expect(without(itemsToOmit)(collection)).toEqual([ 'D', 'E', 'F' ])\n})\n\ntest('ramda test', () => {\n  expect(without([ 1, 2 ])([ 1, 2, 1, 3, 4 ])).toEqual([ 3, 4 ])\n})",
    "explanation": "It will return a new array, based on all members of `source` list that are not part of `matchAgainst` list.",
    "example": "const source = [1, 2, 3, 4]\nconst matchAgainst = [2, 3]\n\nconst result = R.without(matchAgainst, source)\n// => [1, 4]",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('without', function() {\n  it('can act as a transducer', function() {\n    eq(R.into([], R.without([1]), [1]), []);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.without([0], [-0]).length, 1);\n    eq(R.without([-0], [0]).length, 1);\n    eq(R.without([NaN], [NaN]).length, 0);\n    eq(R.without([[1]], [[1]]).length, 0);\n    eq(R.without([new Just([42])], [new Just([42])]).length, 0);\n  });\n});",
    "failedSpecsReasons": "ramda method act as a transducer | ramda method pass to `equals` method",
    "failedSpecsCount": 2
  },
  "xor": {
    "typing": "xor(x: boolean, y: boolean): boolean",
    "allTypings": "xor(x: boolean, y: boolean): boolean;\nxor(y: boolean): (y: boolean) => boolean;",
    "rambdaSource": "export function xor(a, b){\n  if (arguments.length === 1) return _b => xor(a, _b)\n\n  return Boolean(a) && !b || Boolean(b) && !a\n}",
    "rambdaSpecs": "import { xor } from './xor'\n\ntest('compares two values with exclusive or', () => {\n  expect(xor(true, true)).toEqual(false)\n  expect(xor(true, false)).toEqual(true)\n  expect(xor(false, true)).toEqual(true)\n  expect(xor(false, false)).toEqual(false)\n})\n\ntest('when both values are truthy, it should return false', () => {\n  expect(xor(true, 'foo')).toEqual(false)\n  expect(xor(42, true)).toEqual(false)\n  expect(xor('foo', 42)).toEqual(false)\n  expect(xor({}, true)).toEqual(false)\n  expect(xor(true, [])).toEqual(false)\n  expect(xor([], {})).toEqual(false)\n  expect(xor(new Date(), true)).toEqual(false)\n  expect(xor(true, Infinity)).toEqual(false)\n  expect(xor(Infinity, new Date())).toEqual(false)\n})\n\ntest('when both values are falsy, it should return false', () => {\n  expect(xor(null, false)).toEqual(false)\n  expect(xor(false, undefined)).toEqual(false)\n  expect(xor(undefined, null)).toEqual(false)\n  expect(xor(0, false)).toEqual(false)\n  expect(xor(false, NaN)).toEqual(false)\n  expect(xor(NaN, 0)).toEqual(false)\n  expect(xor('', false)).toEqual(false)\n})\n\ntest('when one argument is truthy and the other is falsy, it should return true', () => {\n  expect(xor('foo', null)).toEqual(true)\n  expect(xor(null, 'foo')).toEqual(true)\n  expect(xor(undefined, 42)).toEqual(true)\n  expect(xor(42, undefined)).toEqual(true)\n  expect(xor(Infinity, NaN)).toEqual(true)\n  expect(xor(NaN, Infinity)).toEqual(true)\n  expect(xor({}, '')).toEqual(true)\n  expect(xor('', {})).toEqual(true)\n  expect(xor(new Date(), 0)).toEqual(true)\n  expect(xor(0, new Date())).toEqual(true)\n  expect(xor([], null)).toEqual(true)\n  expect(xor(undefined, [])).toEqual(true)\n})\n\ntest.skip('returns a curried function', () => {\n  expect(xor()(true)(true)).toEqual(false)\n  expect(xor()(true)(false)).toEqual(true)\n  expect(xor()(false)(true)).toEqual(true)\n  expect(xor()(false)(false)).toEqual(false)\n})",
    "example": "const result = [\n  xor(true, true),\n  xor(false, false),\n  xor(false, true),\n]\n// => [false, false, true]",
    "typescriptDefinitionTest": "import {xor} from 'rambda'\n\ndescribe('xor', () => {\n  it('happy', () => {\n    xor(true, false) // $ExpectType boolean\n  })\n  it('curry', () => {\n    xor(true)(false) // $ExpectType boolean\n  })\n})",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('xor', function() {\n  it('returns a curried function', function() {\n    eq(R.xor()(true)(true), false);\n    eq(R.xor()(true)(false), true);\n    eq(R.xor()(false)(true), true);\n    eq(R.xor()(false)(false), false);\n  });\n});",
    "failedSpecsReasons": "ramda support empty call of method",
    "failedSpecsCount": 1
  },
  "zip": {
    "typing": "zip<K, V>(x: ReadonlyArray<K>, y: ReadonlyArray<V>): KeyValuePair<K, V>[]",
    "allTypings": "zip<K, V>(x: ReadonlyArray<K>, y: ReadonlyArray<V>): KeyValuePair<K, V>[];\nzip<K>(x: ReadonlyArray<K>): <V>(y: ReadonlyArray<V>) => KeyValuePair<K, V>[];",
    "rambdaSource": "export function zip(left, right){\n  if (arguments.length === 1) return _right => zip(left, _right)\n\n  const result = []\n  const length = Math.min(left.length, right.length)\n\n  for (let i = 0; i < length; i++){\n    result[ i ] = [ left[ i ], right[ i ] ]\n  }\n\n  return result\n}",
    "rambdaSpecs": "import { zip } from './zip'\n\nconst array1 = [ 1, 2, 3 ]\nconst array2 = [ 'A', 'B', 'C' ]\n\ntest('should return an array', () => {\n  const actual = zip(array1)(array2)\n  expect(actual).toBeInstanceOf(Array)\n})\n\ntest('should return and array or tuples', () => {\n  const expected = [\n    [ 1, 'A' ],\n    [ 2, 'B' ],\n    [ 3, 'C' ],\n  ]\n  const actual = zip(array1, array2)\n  expect(actual).toEqual(expected)\n})\n\ntest('should truncate result to length of shorted input list', () => {\n  const expectedA = [\n    [ 1, 'A' ],\n    [ 2, 'B' ],\n  ]\n  const actualA = zip([ 1, 2 ], array2)\n  expect(actualA).toEqual(expectedA)\n\n  const expectedB = [\n    [ 1, 'A' ],\n    [ 2, 'B' ],\n  ]\n  const actualB = zip(array1, [ 'A', 'B' ])\n  expect(actualB).toEqual(expectedB)\n})",
    "explanation": "It will return a new array containing tuples of equally positions items from both `x` and `y` lists. \n\nThe returned list will be truncated to match the length of the shortest supplied list.",
    "example": "const x = [1, 2]\nconst y = ['A', 'B']\nR.zip(x, y)\n// => [[1, 'A'], [2, 'B']]\n\n// truncates to shortest list\nR.zip([...x, 3], ['A', 'B'])\n// => [[1, 'A'], [2, 'B']]",
    "typescriptDefinitionTest": "import {zip} from 'rambda'\n\ndescribe('zip', () => {\n  it('happy', () => {\n    const array1 = [1, 2, 3]\n    const array2 = ['A', 'B', 'C']\n\n    const result = zip(array1)(array2)\n    result // $ExpectType KeyValuePair<number, string>[]\n  })\n})"
  },
  "zipObj": {
    "typing": "zipObj<T>(keys: ReadonlyArray<string>, values: ReadonlyArray<T>): { [index: string]: T }",
    "allTypings": "zipObj<T>(keys: ReadonlyArray<string>, values: ReadonlyArray<T>): { [index: string]: T };\nzipObj(keys: ReadonlyArray<string>): <T>(values: ReadonlyArray<T>) => { [index: string]: T };",
    "rambdaSource": "import { take } from './take'\n\nexport function zipObj(keys, values){\n  if (arguments.length === 1) return yHolder => zipObj(keys, yHolder)\n\n  return take(values.length, keys).reduce((\n    prev, xInstance, i\n  ) => {\n    prev[ xInstance ] = values[ i ]\n\n    return prev\n  }, {})\n}",
    "rambdaSpecs": "import { equals } from './equals'\nimport { zipObj } from './zipObj'\n\ntest('zipObj', () => {\n  expect(zipObj([ 'a', 'b', 'c' ], [ 1, 2, 3 ])).toEqual({\n    a : 1,\n    b : 2,\n    c : 3,\n  })\n})\n\ntest('0', () => {\n  expect(zipObj([ 'a', 'b' ])([ 1, 2, 3 ])).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('1', () => {\n  expect(zipObj([ 'a', 'b', 'c' ])([ 1, 2 ])).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('ignore extra keys', () => {\n  const result = zipObj([ 'a', 'b', 'c', 'd', 'e', 'f' ], [ 1, 2, 3 ])\n  const expected = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n\n  expect(equals(result, expected)).toBeTrue()\n})",
    "explanation": "It will return a new object with keys of `keys` array and values of `values` array.",
    "example": "const keys = ['a', 'b', 'c']\n\nR.zipObj(keys, [1, 2, 3])\n//=> {a: 1, b: 2, c: 3}\n\n// truncates to shortest list\nR.zipObj(keys, [1, 2])\n//=> {a: 1, b: 2}",
    "typescriptDefinitionTest": "import {zipObj} from 'rambda'\n\ndescribe('zipObj', () => {\n  it('happy', () => {\n    const result = zipObj(['a', 'b', 'c', 'd', 'e', 'f'], [1, 2, 3])\n    result // $ExpectType { [index: string]: number; }\n  })\n})"
  }
}
