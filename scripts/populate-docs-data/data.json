{
  "add": {
    "example": "```javascript\nR.add(2, 3) // =>  5\n```",
    "note": "It doesn't work with strings",
    "explanation": "It adds `a` and `b`. It doesn't work with strings, as the inputs are parsed to numbers before calculation.",
    "typing": "add(a: number, b: number): number"
  },
  "adjust": {
    "example": "```javascript\nR.adjust(\n  0,\n  a => a + 1,\n  [0, 100]\n) // => [1, 100]\n```",
    "note": "",
    "explanation": "It replaces `index` in array `list` with the result of `replaceFn(arr[i])`.",
    "failedRamdaSpecs": "var R = require('../../../../dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('adjust', function() {\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.adjust(2, R.add(1), args(0, 1, 2, 3)), [0, 1, 3, 3]);\n  });\n});",
    "failedSpecsReasons": "ramda accepts an array-like object",
    "typing": "adjust<T>(index: number, replaceFn: (a: T) => T, list: ReadonlyArray<T>): T[]"
  },
  "all": {
    "example": "```javascript\nconst list = [ 0, 1, 2, 3, 4 ]\nconst predicate = x => x > -1\n\nconst result = R.all(fn, arr)\n// => true\n```",
    "note": "",
    "explanation": "It returns `true`, if all members of array `list` returns `true`, when applied as argument to `predicate` function.",
    "typing": "all<T>(predicate: (x: T) => boolean, list: ReadonlyArray<T>): boolean"
  },
  "allPass": {
    "typing": "allPass<T>(predicates: ((x: T) => boolean)[]): (input: T) => boolean"
  },
  "always": {
    "typing": "always<T>(x: T): () => T"
  },
  "any": {
    "typing": "any<T>(fn: (x: T, i: number) => boolean, arr: ReadonlyArray<T>): boolean"
  },
  "anyPass": {
    "typing": "anyPass<T>(preds: ReadonlyArray<SafePred<T>>): SafePred<T>"
  },
  "append": {
    "typing": "append<T>(el: T, list: ReadonlyArray<T>): T[]"
  },
  "applySpec": {
    "typing": "applySpec<Obj extends Record<string, (...args: readonly any[]) => any>>(\n  obj: Obj\n): (\n    ...args: Parameters<ValueOfRecord<Obj>>\n  ) => { [Key in keyof Obj]: ReturnType<Obj[Key]> }"
  },
  "assoc": {
    "typing": "assoc<T, U, K extends string>(prop: K, value: T, obj: U): Record<K, T> & U"
  },
  "assocPath": {
    "typing": "assocPath<T, U>(path: Path, val: T, obj: U): U"
  },
  "and": {
    "typing": "and<T extends { and?: ((...a: readonly any[]) => any)"
  },
  "both": {
    "typing": "both(pred1: Pred, pred2: Pred): Pred"
  },
  "either": {
    "typing": "either(pred1: Pred, pred2: Pred): Pred"
  },
  "clamp": {
    "typing": "clamp(min: number, max: number, input: number): number"
  },
  "clone": {
    "typing": "clone<T>(value: T): T"
  },
  "complement": {
    "typing": "complement(pred: (...args: any[]) => boolean): (...args: any[]) => boolean"
  },
  "compose": {
    "typing": "compose<T1>(fn0: () => T1): () => T1"
  },
  "concat": {
    "typing": "concat<T>(x: ReadonlyArray<T>, y: ReadonlyArray<T>): T[]"
  },
  "cond": {
    "typing": "cond(fns: [Pred, (...a: readonly any[]) => any][]): (...a: readonly any[]) => any"
  },
  "curry": {
    "typing": "curry<F extends (...args: any) => any>(f: F): FToolbelt.Curry<F>"
  },
  "dec": {
    "typing": "dec(n: number): number"
  },
  "defaultTo": {
    "typing": "defaultTo<T>(defaultValue: T): (...inputArguments: (T | null | undefined)[]) => T"
  },
  "difference": {
    "typing": "difference<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]"
  },
  "dissoc": {
    "typing": "dissoc<T>(prop: string, obj: any): T"
  },
  "divide": {
    "typing": "divide(a: number, b: number): number"
  },
  "drop": {
    "typing": "drop<T>(howManyToDrop: number, arrOrStr: ReadonlyArray<T>): T[]"
  },
  "dropLast": {
    "typing": "dropLast<T>(howManyToDrop: number, arrOrStr: ReadonlyArray<T>): T[]"
  },
  "endsWith": {
    "typing": "endsWith(a: string, list: string): boolean"
  },
  "equals": {
    "typing": "equals<T>(a: T, b: T): boolean"
  },
  "F": {
    "typing": "F(): boolean"
  },
  "filter": {
    "typing": "filter<T>(filterFn: FilterFunctionArray<T>): (x: T[]) => T[]"
  },
  "find": {
    "typing": "find<T>(findFn: (a: T) => boolean, arr: ReadonlyArray<T>): T | undefined"
  },
  "findIndex": {
    "typing": "findIndex<T>(findFn: (a: T) => boolean, arr: ReadonlyArray<T>): number"
  },
  "flatten": {
    "typing": "flatten<T>(x: ReadonlyArray<T> | ReadonlyArray<T[]> | ReadonlyArray<ReadonlyArray<T>>): T[]"
  },
  "flip": {
    "typing": "flip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult"
  },
  "forEach": {
    "typing": "forEach<T>(fn: (x: T) => void, list: T[]): T[]"
  },
  "fromPairs": {
    "typing": "fromPairs<V>(pairs: KeyValuePair<string, V>[]): { [index: string]: V }"
  },
  "groupBy": {
    "typing": "groupBy<T>(fn: (a: T) => string, list: ReadonlyArray<T>): { [index: string]: T[] }"
  },
  "has": {
    "typing": "has<T>(prop: string, obj: T): boolean"
  },
  "groupWith": {
    "typing": "groupWith<T>(fn: (x: T, y: T) => boolean): (list: ReadonlyArray<T>) => T[][]"
  },
  "head": {
    "typing": "head<T>(arrOrStr: T[]): T | undefined"
  },
  "identical": {
    "typing": "identical<T>(a: T, b: T): boolean"
  },
  "identity": {
    "typing": "identity<T>(x: T): T"
  },
  "ifElse": {
    "typing": "ifElse(fn: Pred, onTrue: Arity1Fn, onFalse: Arity1Fn): Arity1Fn"
  },
  "inc": {
    "typing": "inc(n: number): number"
  },
  "includes": {
    "typing": "includes(valueToFind: string, input: ReadonlyArray<string> | string): boolean"
  },
  "indexBy": {
    "typing": "indexBy<T>(condition: (a: T) => string, arr: ReadonlyArray<T>): { [key: string]: T }"
  },
  "indexOf": {
    "typing": "indexOf<T>(target: T, arr: ReadonlyArray<T>): number"
  },
  "init": {
    "typing": "init<T>(arrOrStr: ReadonlyArray<T>): T[]"
  },
  "intersperse": {
    "typing": "intersperse<T>(separator: T, list: ReadonlyArray<T>): T[]"
  },
  "intersection": {
    "typing": "intersection<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]"
  },
  "is": {
    "typing": "is(xPrototype: any, x: any): boolean"
  },
  "isEmpty": {
    "typing": "isEmpty<T>(input: T): boolean"
  },
  "isNil": {
    "typing": "isNil(x: any): x is null | undefined"
  },
  "join": {
    "typing": "join(x: string, xs: ReadonlyArray<any>): string"
  },
  "keys": {
    "typing": "keys<T extends object>(x: T): (keyof T)[]"
  },
  "last": {
    "typing": "last<T>(arrOrStr: T[]): T | undefined"
  },
  "lastIndexOf": {
    "typing": "lastIndexOf<T>(x: T, arr: ReadonlyArray<T>): number"
  },
  "length": {
    "typing": "length<T>(list: ReadonlyArray<T>): number"
  },
  "lens": {
    "typing": "lens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens"
  },
  "lensIndex": {
    "typing": "lensIndex(n: number): Lens"
  },
  "lensProp": {
    "typing": "lensProp(str: string): {\n  <T, U>(obj: T): U"
  },
  "over": {
    "typing": "over<T>(lens: Lens, fn: Arity1Fn, value: T): T"
  },
  "set": {
    "typing": "set<T, U>(lens: Lens, a: U, obj: T): T"
  },
  "view": {
    "typing": "view<T, U>(lens: Lens): (obj: T) => U"
  },
  "map": {
    "typing": "map<T, U>(mapFn: MapFunctionObject<T, U>, x: Dictionary<T>): Dictionary<U>"
  },
  "match": {
    "typing": "match(regexp: RegExp, str: string): any[]"
  },
  "max": {
    "typing": "max<T extends Ord>(a: T, b: T): T"
  },
  "maxBy": {
    "typing": "maxBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T"
  },
  "mean": {
    "typing": "mean(list: ReadonlyArray<number>): number"
  },
  "median": {
    "typing": "median(list: ReadonlyArray<number>): number"
  },
  "merge": {
    "typing": "merge<T1, T2>(a: T1, b: T2): Merge<T2, T1>"
  },
  "min": {
    "typing": "min<T extends Ord>(a: T, b: T): T"
  },
  "minBy": {
    "typing": "minBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T"
  },
  "modulo": {
    "typing": "modulo(a: number, b: number): number"
  },
  "multiply": {
    "typing": "multiply(a: number, b: number): number"
  },
  "negate": {
    "typing": "negate(a: number): number"
  },
  "none": {
    "typing": "none<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): boolean"
  },
  "not": {
    "typing": "not(x: any): boolean"
  },
  "nth": {
    "typing": "nth<T>(n: number, list: ReadonlyArray<T>): T | undefined"
  },
  "omit": {
    "typing": "omit<T>(propsToOmit: string | string[], obj: Dictionary<T>): Dictionary<T>"
  },
  "partial": {
    "typing": "partial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, x0: V0): (x1: V1) => T"
  },
  "path": {
    "typing": "path<Input, T>(pathToSearch: string | string[], obj: Input): T | undefined"
  },
  "paths": {
    "typing": "paths<Input, T>(pathsToSearch: (string | string[])[], obj: Input): (T | undefined)[]"
  },
  "pathOr": {
    "typing": "pathOr<T>(defaultValue: T, pathToSearch: Path, obj: any): T"
  },
  "pick": {
    "typing": "pick<T>(propsToPick: string | string[], obj: Dictionary<T>): Dictionary<T>"
  },
  "pickAll": {
    "typing": "pickAll<T, U>(names: ReadonlyArray<string>, obj: T): U"
  },
  "pipe": {
    "typing": "pipe<T1>(fn0: () => T1): () => T1"
  },
  "pluck": {
    "typing": "pluck<T>(property: number, arr: ReadonlyArray<T>): T"
  },
  "prepend": {
    "typing": "prepend<T>(x: T, arr: ReadonlyArray<T>): T[]"
  },
  "product": {
    "typing": "product(list: ReadonlyArray<number>): number"
  },
  "prop": {
    "typing": "prop<P extends keyof T, T>(propToFind: P, obj: T): T[P]"
  },
  "propEq": {
    "typing": "propEq<T>(propToFind: string | number, valueToMatch: T, obj: any): boolean"
  },
  "propIs": {
    "typing": "propIs<P extends keyof T, T>(type: any, name: P, obj: T): boolean"
  },
  "propOr": {
    "typing": "propOr<T, U, V>(val: T, p: string, obj: U): V"
  },
  "range": {
    "typing": "range(start: number, end: number): number[]"
  },
  "reduce": {
    "typing": "reduce<T, TResult>(fn: (acc: TResult, elem: T, i: number) => TResult, acc: TResult, list: ReadonlyArray<T>): TResult"
  },
  "reject": {
    "typing": "reject<T>(filterFn: FilterFunctionArray<T>): (x: T[]) => T[]"
  },
  "repeat": {
    "typing": "repeat<T>(a: T, n: number): T[]"
  },
  "replace": {
    "typing": "replace(strOrRegex: RegExp | string, replacer: string, str: string): string"
  },
  "reverse": {
    "typing": "reverse<T>(list: ReadonlyArray<T>): T[]"
  },
  "slice": {
    "typing": "slice(a: number, b: number, list: string): string"
  },
  "sort": {
    "typing": "sort<T>(sortFn: (a: T, b: T) => number, arr: ReadonlyArray<T>): T[]"
  },
  "sortBy": {
    "typing": "sortBy<T>(sortFn: (a: T) => Ord, arr: ReadonlyArray<T>): T[]"
  },
  "split": {
    "typing": "split(sep: string | RegExp): (str: string) => string[]"
  },
  "splitEvery": {
    "typing": "splitEvery<T>(a: number, list: ReadonlyArray<T>): T[][]"
  },
  "startsWith": {
    "typing": "startsWith(a: string, list: string): boolean"
  },
  "subtract": {
    "typing": "subtract(a: number, b: number): number"
  },
  "sum": {
    "typing": "sum(list: ReadonlyArray<number>): number"
  },
  "symmetricDifference": {
    "typing": "symmetricDifference<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]"
  },
  "T": {
    "typing": "T(): boolean"
  },
  "tail": {
    "typing": "tail<T>(arrOrStr: ReadonlyArray<T>): T[]"
  },
  "take": {
    "typing": "take<T>(num: number, arrOrStr: ReadonlyArray<T>): T[]"
  },
  "takeLast": {
    "typing": "takeLast<T>(num: number, arrOrStr: ReadonlyArray<T>): T[]"
  },
  "tap": {
    "typing": "tap<T>(fn: (a: T) => any, value: T): T"
  },
  "test": {
    "typing": "test(regExpression: RegExp): (str: string) => boolean"
  },
  "times": {
    "typing": "times<T>(fn: (i: number) => T, n: number): T[]"
  },
  "transpose": {
    "typing": "transpose<T>(list: T[][]): T[][]"
  },
  "toPairs": {
    "typing": "toPairs<S>(obj: { [k: string]: S } | { [k: number]: S }): [string, S][]"
  },
  "toLower": {
    "typing": "toLower(str: string): string"
  },
  "toString": {
    "typing": "toString<T>(val: T): string"
  },
  "toUpper": {
    "typing": "toUpper(str: string): string"
  },
  "trim": {
    "typing": "trim(str: string): string"
  },
  "type": {
    "typing": "type(val: any): \"Object\" | \"Number\" | \"Boolean\" | \"String\" | \"Null\" | \"Array\" | \"Function\" | \"Undefined\" | \"Async\" | \"Promise\" | \"RegExp\" | \"NaN\""
  },
  "uniq": {
    "typing": "uniq<T>(arr: ReadonlyArray<T>): T[]"
  },
  "uniqWith": {
    "typing": "uniqWith<T, U>(fn: (x: T, y: T) => boolean, arr: ReadonlyArray<T>): T[]"
  },
  "update": {
    "typing": "update<T>(index: number, value: T, list: ReadonlyArray<T>): T[]"
  },
  "values": {
    "typing": "values<T extends object, K extends keyof T>(obj: T): T[K][]"
  },
  "without": {
    "typing": "without<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[]"
  },
  "xor": {
    "typing": "xor(a: boolean, b: boolean): boolean"
  },
  "zip": {
    "typing": "zip<K, V>(list1: ReadonlyArray<K>, list2: ReadonlyArray<V>): KeyValuePair<K, V>[]"
  },
  "zipObj": {
    "typing": "zipObj<T>(keys: ReadonlyArray<string>, values: ReadonlyArray<T>): { [index: string]: T }"
  }
}
