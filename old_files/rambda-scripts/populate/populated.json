{
  "add": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "ADD",
        "date": "2019-11-13T11:22:57.631Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 407187612,
            "margin": 0.57,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 292541517,
            "margin": 0.9,
            "percentSlower": 28.16
          },
          {
            "name": "Lodash",
            "ops": 97032103,
            "margin": 0.92,
            "percentSlower": 76.17
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Lodash",
          "index": 2
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst add = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.add(1, 1)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.add(1, 1)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.add(1, 1)\n    },\n  },\n]\n\nmodule.exports = add\n"
    },
    "typingSpec": "import { add } from 'rambda'\n\ndescribe('add', () => {\n  it('number', () => {\n    const resultA = add(4)(1); // $ExpectType number\n    resultA // $ExpectType number\n    const resultB = add(4,1); // $ExpectType number\n    resultB // $ExpectType number\n  });\n});\n",
    "methodName": "add",
    "example": "R.add(2, 3) // =>  5",
    "code": "export function add(a, b){\n  if (arguments.length === 1) return _b => add(a, _b)\n\n  return Number(a) + Number(b)\n}",
    "spec": "import { add } from './add'\n\ntest('with number', () => {\n  expect(add(2, 3)).toEqual(5)\n  expect(add(7)(10)).toEqual(17)\n})\n\ntest('string is bad input', () => {\n  expect(add('foo', 'bar')).toBeNaN()\n})\n\ntest('ramda specs', () => {\n  expect(add('1', '2'),).toEqual(3)\n  expect(add(1, '2'),).toEqual(3)\n  expect(add(true, false),).toEqual(1)\n  expect(add(null, null),).toEqual(0)\n  expect(add(undefined, undefined),).toEqual(NaN)\n  expect(add(new Date(1), new Date(2)),).toEqual(3)\n})\n"
  },
  "adjust": {
    "explanation": "It replaces `i` index in `arr` with the result of `replaceFn(arr[i])`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('adjust', function() {\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.adjust(2, R.add(1), args(0, 1, 2, 3)), [0, 1, 3, 3]);\n  });\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "ADJUST",
        "date": "2019-11-13T11:23:08.495Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 3498982,
            "margin": 1.12,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 3400976,
            "margin": 1.15,
            "percentSlower": 2.8
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\nconst list = [ 0, 1, 2 ]\nconst fn = x => x + 1\nconst index = 1\n\nconst adjust = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.adjust(index, fn, list)\n      R.adjust(index, fn)(list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.adjust(index, fn, list)\n      Ramda.adjust(index, fn)(list)\n    },\n  },\n]\n\nmodule.exports = adjust\n"
    },
    "typingSpec": "",
    "methodName": "adjust",
    "example": "R.adjust(\n  0,\n  a => a + 1,\n  [0, 100]\n) // => [1, 100]",
    "code": "import { curry } from './curry'\n\nfunction adjustFn(\n  index, fn, list\n){\n  const actualIndex = index < 0 ? list.length + index : index\n  if (index >= list.length || actualIndex < 0) return list\n\n  const clone = list.slice()\n  clone[ actualIndex ] = fn(clone[ actualIndex ])\n\n  return clone\n}\n\nexport const adjust = curry(adjustFn)",
    "spec": "import { add } from './add'\nimport { adjust } from './adjust'\n\nconst expected = [ 0, 11, 2 ]\n\ntest('without curring', () => {\n  expect(adjust(\n    1, add(10), [ 0, 1, 2 ]\n  )).toEqual(expected)\n})\n\ntest('with curring type 1 1 1', () => {\n  expect(adjust(1)(add(10))([ 0, 1, 2 ])).toEqual(expected)\n})\n\ntest('with curring type 1 2', () => {\n  expect(adjust(1)(add(10), [ 0, 1, 2 ])).toEqual(expected)\n})\n\ntest('with curring type 2 1', () => {\n  expect(adjust(1, add(10))([ 0, 1, 2 ])).toEqual(expected)\n})\n\ntest('with negative index', () => {\n  expect(adjust(\n    -2, add(10), [ 0, 1, 2 ]\n  )).toEqual(expected)\n})\n\ntest('when index is out of bounds', () => {\n  const list = [ 0, 1, 2, 3 ]\n  expect(adjust(\n    4, add(1), list\n  ),).toEqual(list)\n  expect(adjust(\n    -5, add(1), list\n  ),).toEqual(list)\n})\n"
  },
  "all": {
    "explanation": "It returns `true`, if all members of array `arr` returns `true`, when applied as argument to function `fn`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "ALL",
        "date": "2019-11-13T11:23:19.383Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 25139995,
            "margin": 0.63,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 2603537,
            "margin": 0.85,
            "percentSlower": 89.64
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst input = [ 1, 2, 3, 4 ]\n\nconst all = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      const fn = x => x > 2\n\n      R.all(fn, input)\n      R.all(fn)(input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      const fn = x => x > 2\n\n      Ramda.all(fn, input)\n      Ramda.all(fn)(input)\n    },\n  },\n]\n\nmodule.exports = all\n"
    },
    "typingSpec": "import { all } from 'rambda'\n\ndescribe('all', () => {\n  it('happy', () => {\n    const x = all<number>(y => {\n      y // $ExpectType number\n      return y > 0\n    })([1, 2, 3 ]);\n    x // $ExpectType boolean\n\n    const q = all(y => y > 0,[1, 2,3 ]); // $ExpectType boolean\n\n    q // $ExpectType boolean\n  });\n});\n",
    "methodName": "all",
    "example": "const arr = [ 0, 1, 2, 3, 4 ]\nconst fn = x => x > -1\n\nconst result = R.all(fn, arr)\n// => true",
    "code": "export function all(fn, list){\n  if (arguments.length === 1) return _list => all(fn, _list)\n\n  for (let i = 0; i < list.length; i++){\n    if (!fn(list[ i ], i))\n      return false\n  }\n\n  return true\n}",
    "spec": "import { all } from './all'\n\nconst numArr = [ 0, 1, 2, 3, 4 ]\n\ntest('when true', () => {\n  const fn = x => x > -1\n\n  expect(all(fn)(numArr)).toBeTrue()\n})\n\ntest('when false', () => {\n  const fn = x => x > 2\n\n  expect(all(fn, numArr)).toBeFalse()\n})\n\ntest('pass index as second argument', () => {\n  const indexes = []\n  const fn = (x, i) => {\n    indexes.push(i)\n\n    return x > 5\n  }\n  all(fn, [ 10, 12, 14 ])\n\n  expect(indexes).toEqual([ 0, 1, 2 ])\n})\n"
  },
  "allPass": {
    "explanation": "It returns `true`, if all functions of `rules` return `true`, when `input` is their argument.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('allPass', function() {\n  var odd = function(n) { return n % 2 !== 0; };\n  var lt20 = function(n) { return n < 20; };\n  var gt5 = function(n) { return n > 5; };\n  var plusEq = function(w, x, y, z) { return w + x === y + z; };\n  it('returns a curried function whose arity matches that of the highest-arity predicate', function() {\n    eq(R.allPass([odd, gt5, plusEq]).length, 4);\n    eq(R.allPass([odd, gt5, plusEq])(9, 9, 9, 9), true);\n    eq(R.allPass([odd, gt5, plusEq])(9)(9)(9)(9), true);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { allPass } from 'rambda'\n\ndescribe('allPass', () => {\n  it('happy', () => {\n    const x = allPass<number>([\n      y => {\n        y // $ExpectType number\n        return typeof y === 'number'\n      },\n      y => {\n        return y > 0\n      },\n    ])(11)\n\n    x // $ExpectType boolean\n  });\n});\n",
    "methodName": "allPass",
    "example": "const input = {\n  a : 1,\n  b : 2,\n}\nconst rules = [\n  x => x.a === 1,\n  x => x.b === 2,\n]\nconst result = R.allPass(rules)(input) // => true",
    "code": "export function allPass(predicates){\n  return input => {\n    let counter = 0\n    while (counter < predicates.length){\n      if (!predicates[ counter ](input)){\n        return false\n      }\n      counter++\n    }\n\n    return true\n  }\n}",
    "spec": "import { allPass } from './allPass'\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'number', x => x > 10, x => x * 7 < 100 ]\n\n  expect(allPass(rules)(11)).toBeTrue()\n\n  expect(allPass(rules)(undefined)).toBeFalse()\n})\n\ntest('when returns true', () => {\n  const conditionArr = [ val => val.a === 1, val => val.b === 2 ]\n\n  expect(allPass(conditionArr)({\n    a : 1,\n    b : 2,\n  })).toBeTrue()\n})\n\ntest('when returns false', () => {\n  const conditionArr = [ val => val.a === 1, val => val.b === 3 ]\n\n  expect(allPass(conditionArr)({\n    a : 1,\n    b : 2,\n  })).toBeFalse()\n})\n"
  },
  "always": {
    "explanation": "It returns function that always returns `x`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "always",
    "example": "const fn = R.always(7)\n\nconsole.log(fn())// => 7",
    "code": "export function always(x){\n  return () => x\n}",
    "spec": "import { always } from './always'\n\ntest('happy', () => {\n  const fn = always(7)\n\n  expect(fn()).toEqual(7)\n  expect(fn()).toEqual(7)\n})\n"
  },
  "any": {
    "explanation": "It returns `true`, if at least one member of `arr` returns true, when passed to the `condition` function.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "ANY",
        "date": "2019-11-13T11:23:46.822Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 194679164,
            "margin": 0.23,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 15374539,
            "margin": 1.53,
            "percentSlower": 92.1
          },
          {
            "name": "Lodash.some",
            "ops": 137439309,
            "margin": 2.03,
            "percentSlower": 29.4
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst input = [ 1, 2, 3, 4 ]\nconst fn = val => val > 2\n\nconst any = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.any(fn, input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.any(fn, input)\n    },\n  },\n  {\n    label : 'Lodash.some',\n    fn    : () => {\n      _.some(input, fn)\n    },\n  },\n]\n\nmodule.exports = any\n"
    },
    "typingSpec": "import { any } from 'rambda'\n\ndescribe('any', () => {\n  it('1', () => {\n    const x = any<number>((y,i)=> { // $ExpectType boolean\n      y // $ExpectType number\n      i // $ExpectType number\n      return y > 2\n    },[1,2,3]);\n    x // $ExpectType boolean\n  });\n  it('2', () => {\n    const x = any<number>((y)=> { // $ExpectType boolean\n      y // $ExpectType number\n      return y > 2\n    },[1,2,3]);\n    x // $ExpectType boolean\n  });\n\n  it('1 curry', () => {\n    const x = any<number>((y,i)=> { // $ExpectType boolean\n      y // $ExpectType number\n      i // $ExpectType number\n      return y > 2\n    })([1,2,3]);\n    x // $ExpectType boolean\n  });\n  it('2 curry', () => {\n    const x = any<number>((y)=> { // $ExpectType boolean\n      y // $ExpectType number\n      return y > 2\n    })([1,2,3]);\n    x // $ExpectType boolean\n  });\n});\n",
    "methodName": "any",
    "example": "R.any(a => a * a > 8)([1, 2, 3])\n// => true",
    "code": "export function any(fn, list){\n  if (arguments.length === 1) return _list => any(fn, _list)\n\n  let counter = 0\n  while (counter < list.length){\n    if (fn(list[ counter ], counter)){\n      return true\n    }\n    counter++\n  }\n\n  return false\n}",
    "spec": "import { any } from './any'\n\nconst arr = [ 1, 2 ]\n\ntest('no curry', () => {\n  expect(any(val => val < 0, arr)).toBeFalse()\n})\n\ntest('with curry', () => {\n  expect(any(val => val < 2)(arr)).toBeTrue()\n})\n\ntest('passes index to predicate', () => {\n  any((x, i) => {\n    expect(typeof x).toBe('string')\n    expect(typeof i).toBe('number')\n  })([ 'foo', 'bar' ])\n})\n"
  },
  "anyPass": {
    "explanation": "It returns `true`, if any of `predicates` return `true` with `input` is their argument.",
    "ramdaDiff": "const eq = require('./shared/eq')\nconst R = require('../../../../../rambda/dist/rambda.js')\n\ndescribe('anyPass', () => {\n  const odd = function(n){ return n % 2 !== 0 }\n  const gt20 = function(n){ return n > 20 }\n  const lt5 = function(n){ return n < 5 }\n  const plusEq = function(w, x, y, z){ return w + x === y + z }\n  it('returns a curried function whose arity matches that of the highest-arity predicate', () => {\n    eq(R.anyPass([ odd, lt5, plusEq ]).length, 4)\n    eq(R.anyPass([ odd, lt5, plusEq ])(6, 7, 8, 9), false)\n    eq(R.anyPass([ odd, lt5, plusEq ])(6)(7)(8)(9), false)\n  })\n})",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { anyPass } from 'rambda'\n\ndescribe('anyPass', () => {\n  it('happy', () => {\n    const x = anyPass<number>([\n      y => {\n        y // $ExpectType number\n        return typeof y === 'number'\n      },\n      y => {\n        return y > 0\n      },\n    ])(11)\n\n    x // $ExpectType boolean\n  });\n});\n",
    "methodName": "anyPass",
    "example": "const isBig = a => a > 20\nconst isOdd = a => a % 2 === 1\n\nconst result = R.anyPass(\n  [isBig, isOdd]\n)(11)\n// => true",
    "code": "export function anyPass(predicates){\n  return input => {\n    let counter = 0\n    while (counter < predicates.length){\n      if (predicates[ counter ](input)){\n        return true\n      }\n      counter++\n    }\n\n    return false\n  }\n}",
    "spec": "import { anyPass } from './anyPass'\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'string', x => x > 10 ]\n  const predicate = anyPass(rules)\n  expect(predicate('foo')).toBeTrue()\n  expect(predicate(6)).toBeFalse()\n})\n\ntest('happy', () => {\n  const rules = [ x => typeof x === 'string', x => x > 10 ]\n\n  expect(anyPass(rules)(11)).toBeTrue()\n\n  expect(anyPass(rules)(undefined)).toBeFalse()\n})\n\nconst obj = {\n  a : 1,\n  b : 2,\n}\n\ntest('when returns true', () => {\n  const conditionArr = [ val => val.a === 1, val => val.a === 2 ]\n\n  expect(anyPass(conditionArr)(obj)).toBeTrue()\n})\n\ntest('when returns false + curry', () => {\n  const conditionArr = [ val => val.a === 2, val => val.b === 3 ]\n\n  expect(anyPass(conditionArr)(obj)).toBeFalse()\n})\n\ntest('happy', () => {\n  expect(anyPass([])(3)).toEqual(false)\n})\n"
  },
  "append": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "APPEND",
        "date": "2019-11-13T11:24:08.609Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 13407000,
            "margin": 0.44,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 1992102,
            "margin": 0.42,
            "percentSlower": 85.14
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst append = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.append(0)([ 1, 2, 3, 4 ])\n      R.append('bar')('foo')\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.append(0)([ 1, 2, 3, 4 ])\n      Ramda.append('bar')('foo')\n    },\n  },\n]\n\nmodule.exports = append\n"
    },
    "typingSpec": "",
    "methodName": "append",
    "example": "R.append(\n  'foo',\n  ['bar', 'baz']\n) // => ['bar', 'baz', 'foo']",
    "code": "export function append(el, list){\n  if (arguments.length === 1) return _list => append(el, _list)\n\n  if (typeof list === 'string') return `${ list }${ el }`\n\n  const clone = list.slice()\n  clone.push(el)\n\n  return clone\n}",
    "spec": "import { compose, flatten, map } from '../rambda'\nimport { append } from './append'\n\ntest('with strings', () => {\n  expect(append('o', 'fo')).toEqual('foo')\n})\n\ntest('with arrays', () => {\n  expect(append('tests', [ 'write', 'more' ])).toEqual([ 'write', 'more', 'tests' ])\n})\n\ntest('append to empty array', () => {\n  expect(append('tests', [])).toEqual([ 'tests' ])\n})\n\ntest('happy', () => {\n  const result = compose(flatten, map(append(0)))([ [ 1 ], [ 2 ], [ 3 ] ])\n  expect(result).toEqual([ 1, 0, 2, 0, 3, 0 ])\n})\n\ntest('should not modify arguments', () => {\n  const a = [ 1, 2, 3 ]\n  const b = append(4, a)\n\n  expect(a).toEqual([ 1, 2, 3 ])\n  expect(b).toEqual([ 1, 2, 3, 4 ])\n})\n"
  },
  "applySpec": {
    "explanation": "Returns a curried function with the same arity as the longest function in the spec object.\nArguments will be applied to the spec methods recursively.\n\nNote that the currying in this function works best with functions with 4 arguments or less. (arity of 4)",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { multiply, applySpec, inc, dec, add } from 'rambda'\n\ndescribe('applySpec', () => {\n  it('ramda 1', () => {\n    const result = applySpec({\n      v : inc,\n      u : dec,\n    })(1)\n    result // $ExpectType { v: number; u: number; }\n  });\n  it('ramda 1', () => {\n    interface Output{\n      sum: number\n      multiplied: number\n    }\n    const result = applySpec<Output>({ \n      sum : add, \n      multiplied: multiply \n    })(1, 2)\n\n    result // $ExpectType Output\n  });\n});\n",
    "methodName": "applySpec",
    "example": "const getMetrics = R.applySpec({\n  sum: R.add,\n  nested: { mul: R.multiply }\n});\ngetMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }\n\nconst spec = {\n  name: R.path('deeply.nested.object.user.firstname')\n}\n\nconst json = {\n  deeply: {\n   nested: {\n     object: {\n       user: {\n         firstname: 'barry'\n        } \n      }\n    }\n  }\n}\nconst result = R.applySpec(spec, json) \n// => { name: 'barry' }",
    "code": "// recursively traverse the given spec object to find the highest arity function\nfunction __findHighestArity(spec, max = 0){\n  for (const key in spec){\n    if (spec.hasOwnProperty(key) === false || key === 'constructor') continue\n\n    if (typeof spec[ key ] === 'object'){\n      max = Math.max(max, __findHighestArity(spec[ key ]))\n    }\n\n    if (typeof spec[ key ] === 'function'){\n      max = Math.max(max, spec[ key ].length)\n    }\n  }\n\n  return max\n}\n\nfunction __filterUndefined(){\n  const defined = []\n  let i = 0\n  const l = arguments.length\n  while (i < l){\n    if (typeof arguments[ i ] === 'undefined') break\n    defined[ i ] = arguments[ i ]\n    i++\n  }\n\n  return defined\n}\n\nexport function handleArrayOfFunctions(obj){\n  const keys = Object.keys(obj)\n  const toReturn = Array(keys.length)\n\n  keys.forEach(x => {\n    toReturn[ x ] = obj[ x ]\n  })\n\n  return toReturn\n}\n\nfunction __applySpecWithArity(\n  spec, arity, cache\n){\n  const remaining = arity - cache.length\n\n  if (remaining === 1) return x => __applySpecWithArity(\n    spec, arity, __filterUndefined(...cache, x)\n  )\n  if (remaining === 2)\n    return (x, y) => __applySpecWithArity(\n      spec, arity, __filterUndefined(\n        ...cache, x, y\n      )\n    )\n  if (remaining === 3)\n    return (\n      x, y, z\n    ) => __applySpecWithArity(\n      spec, arity, __filterUndefined(\n        ...cache, x, y, z\n      )\n    )\n  if (remaining === 4)\n    return (\n      x, y, z, a\n    ) =>\n      __applySpecWithArity(\n        spec, arity, __filterUndefined(\n          ...cache, x, y, z, a\n        )\n      )\n  if (remaining > 4)\n    return (...args) => __applySpecWithArity(\n      spec, arity, __filterUndefined(...cache, ...args)\n    )\n\n  const ret = {}\n\n  // apply callbacks to each property in the spec object\n  for (const key in spec){\n    if (spec.hasOwnProperty(key) === false || key === 'constructor') continue\n\n    // apply the spec recursively\n    if (typeof spec[ key ] === 'object'){\n      ret[ key ] = __applySpecWithArity(\n        spec[ key ], arity, cache\n      )\n      continue\n    }\n\n    // apply spec to the key\n    if (typeof spec[ key ] === 'function'){\n      ret[ key ] = spec[ key ](...cache)\n    }\n  }\n\n  return Array.isArray(spec) ? handleArrayOfFunctions(ret) : ret\n}\n\nexport function applySpec(spec, ...args){\n  // get the highest arity spec function, cache the result and pass to __applySpecWithArity\n  const arity = __findHighestArity(spec)\n\n  if (arity === 0){\n    return () => ({})\n  }\n  const toReturn = __applySpecWithArity(\n    spec, arity, args\n  )\n\n  return toReturn\n}",
    "spec": "import { nAry } from 'ramda'\n\nimport { add, always, compose, dec, inc, map, path, prop, T } from '../rambda'\nimport { applySpec } from './applySpec'\n\ntest.skip('with bad input', () => {\n  const result = applySpec({ sum : { a : 1 } })(1, 2)\n  console.log({ result })\n})\n\ntest('works with empty spec', () => {\n  expect(applySpec({})()).toEqual({})\n  expect(applySpec([])(1, 2)).toEqual({})\n  expect(applySpec(null)(1, 2)).toEqual({})\n})\n\ntest('works with unary functions', () => {\n  const result = applySpec({\n    v : inc,\n    u : dec,\n  })(1)\n  const expected = {\n    v : 2,\n    u : 0,\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('works with binary functions', () => {\n  const result = applySpec({ sum : add })(1, 2)\n  expect(result).toEqual({ sum : 3 })\n})\n\ntest('works with nested specs', () => {\n  const result = applySpec({\n    unnested : always(0),\n    nested   : { sum : add },\n  })(1, 2)\n  const expected = {\n    unnested : 0,\n    nested   : { sum : 3 },\n  }\n  expect(result).toEqual(expected)\n})\n\ntest('works with arrays of nested specs', () => {\n  const result = applySpec({\n    unnested : always(0),\n    nested   : [ { sum : add } ],\n  })(1, 2)\n\n  expect(result).toEqual({\n    unnested : 0,\n    nested   : [ { sum : 3 } ],\n  })\n})\n\ntest('works with arrays of spec objects', () => {\n  const result = applySpec([ { sum : add } ])(1, 2)\n\n  expect(result).toEqual([ { sum : 3 } ])\n})\n\ntest('works with arrays of functions', () => {\n  const result = applySpec([ map(prop('a')), map(prop('b')) ])([\n    {\n      a : 'a1',\n      b : 'b1',\n    },\n    {\n      a : 'a2',\n      b : 'b2',\n    },\n  ])\n  const expected = [\n    [ 'a1', 'a2' ],\n    [ 'b1', 'b2' ],\n  ]\n  expect(result).toEqual(expected)\n})\n\ntest('works with a spec defining a map key', () => {\n  expect(applySpec({ map : prop('a') })({ a : 1 })).toEqual({ map : 1 })\n})\n\ntest.skip('retains the highest arity', () => {\n  const f = applySpec({\n    f1 : nAry(2, T),\n    f2 : nAry(5, T),\n  })\n  expect(f.length).toBe(5)\n})\n\ntest('returns a curried function', () => {\n  expect(applySpec({ sum : add })(1)(2)).toEqual({ sum : 3 })\n})\n\n// Additional tests\n// ============================================\ntest('arity', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n  }\n  expect(applySpec(\n    spec, 1, 2, 3\n  )).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n  })\n})\n\ntest('arity over 5 arguments', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n    four : (\n      x1, x2, x3, x4\n    ) => x1 + x2 + x3 + x4,\n    five : (\n      x1, x2, x3, x4, x5\n    ) => x1 + x2 + x3 + x4 + x5,\n  }\n  expect(applySpec(\n    spec, 1, 2, 3, 4, 5\n  )).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n    four  : 10,\n    five  : 15,\n  })\n})\n\ntest('curried', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n  }\n  expect(applySpec(spec)(1)(2)(3)).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n  })\n})\n\ntest('curried over 5 arguments', () => {\n  const spec = {\n    one   : x1 => x1,\n    two   : (x1, x2) => x1 + x2,\n    three : (\n      x1, x2, x3\n    ) => x1 + x2 + x3,\n    four : (\n      x1, x2, x3, x4\n    ) => x1 + x2 + x3 + x4,\n    five : (\n      x1, x2, x3, x4, x5\n    ) => x1 + x2 + x3 + x4 + x5,\n  }\n  expect(applySpec(spec)(1)(2)(3)(4)(5)).toEqual({\n    one   : 1,\n    two   : 3,\n    three : 6,\n    four  : 10,\n    five  : 15,\n  })\n})\n\ntest('undefined property', () => {\n  const spec = { prop : path([ 'property', 'doesnt', 'exist' ]) }\n  expect(applySpec(spec, {})).toEqual({ prop : undefined })\n})\n\ntest('restructure json object', () => {\n  const spec = {\n    id          : path('user.id'),\n    name        : path('user.firstname'),\n    profile     : path('user.profile'),\n    doesntExist : path('user.profile.doesntExist'),\n    info        : { views : compose(inc, prop('views')) },\n    type        : always('playa'),\n  }\n\n  const data = {\n    user : {\n      id        : 1337,\n      firstname : 'john',\n      lastname  : 'shaft',\n      profile   : 'shaft69',\n    },\n    views : 42,\n  }\n\n  expect(applySpec(spec, data)).toEqual({\n    id          : 1337,\n    name        : 'john',\n    profile     : 'shaft69',\n    doesntExist : undefined,\n    info        : { views : 43 },\n    type        : 'playa',\n  })\n})\n"
  },
  "assoc": {
    "explanation": "Makes a shallow clone of `obj`, setting or overriding the property `prop` with\nthe value `value`. Note that this copies and flattens prototype properties\nonto the new object as well. All non-primitive properties are copied by\nreference.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "ASSOC",
        "date": "2019-11-13T11:24:25.100Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 6228535,
            "margin": 0.57,
            "percentSlower": 76.71
          },
          {
            "name": "Ramda",
            "ops": 9762145,
            "margin": 0.53,
            "percentSlower": 63.5
          },
          {
            "name": "Lodash.set",
            "ops": 26748254,
            "margin": 0.87,
            "percentSlower": 0
          }
        ],
        "fastest": {
          "name": "Lodash.set",
          "index": 2
        },
        "slowest": {
          "name": "Rambda",
          "index": 0
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst input = {\n  a : 1,\n  b : 2,\n}\nconst key = 'c'\nconst value = 3\n\nconst assoc = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.assoc(key, value, input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.assoc(key, value, input)\n    },\n  },\n  {\n    label : 'Lodash.set',\n    fn    : () => {\n      _.set(input, key, value)\n    },\n  },\n]\n\nmodule.exports = assoc\n"
    },
    "typingSpec": "",
    "methodName": "assoc",
    "example": "R.assoc('c', 3, {a: 1, b: 2})\n//=> {a: 1, b: 2, c: 3}",
    "code": "import { curry } from './curry'\n\nfunction assocFn(\n  prop, val, obj\n){\n  return Object.assign(\n    {}, obj, { [ prop ] : val }\n  )\n}\n\nexport const assoc = curry(assocFn)",
    "spec": "import { assoc } from './assoc'\n\ntest('adds a key to an empty object', () => {\n  expect(assoc(\n    'a', 1, {}\n  )).toEqual({ a : 1 })\n})\n\ntest('adds a key to a non-empty object', () => {\n  expect(assoc(\n    'b', 2, { a : 1 }\n  )).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 1', () => {\n  expect(assoc('b', 2)({ a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 2', () => {\n  expect(assoc('b')(2, { a : 1 })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('adds a key to a non-empty object - curry case 3', () => {\n  const result = assoc('b')(2)({ a : 1 })\n\n  expect(result).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('changes an existing key', () => {\n  expect(assoc(\n    'a', 2, { a : 1 }\n  )).toEqual({ a : 2 })\n})\n\ntest('undefined is considered an empty object', () => {\n  expect(assoc(\n    'a', 1, undefined\n  )).toEqual({ a : 1 })\n})\n\ntest('null is considered an empty object', () => {\n  expect(assoc(\n    'a', 1, null\n  )).toEqual({ a : 1 })\n})\n\ntest('value can be null', () => {\n  expect(assoc(\n    'a', null, null\n  )).toEqual({ a : null })\n})\n\ntest('value can be undefined', () => {\n  expect(assoc(\n    'a', undefined, null\n  )).toEqual({ a : undefined })\n})\n\ntest('assignment is shallow', () => {\n  expect(assoc(\n    'a', { b : 2 }, { a : { c : 3 } }\n  )).toEqual({ a : { b : 2 } })\n})\n"
  },
  "both": {
    "explanation": "It returns `true`, if both function `firstCondition` and function `secondCondition` return `true`, when `input` is their argument.",
    "ramdaDiff": "var S = require('sanctuary');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('both', function() {\n  it('accepts fantasy-land applicative functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.both(Just(true), Just(true)), Just(true));\n    eq(R.both(Just(true), Just(false)), Just(false));\n    eq(R.both(Just(true), Nothing()), Nothing());\n    eq(R.both(Nothing(), Just(false)), Nothing());\n    eq(R.both(Nothing(), Nothing()), Nothing());\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { both } from 'rambda'\n\ndescribe('both', () => { \n  it('with passed type', () => {\n    const fn = both<number>( // $ExpectType Predicate<number>\n      x => {\n        return x > 1\n      },\n      x => {\n        return x % 2 === 0\n      },\n    );\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  });\n  it('no type passed', () => {\n    const fn = both(\n      x => {\n        x // $ExpectType any\n        return x > 1\n      },\n      x => {\n        return x % 2 === 0\n      },\n    );\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  });\n});\n\ndescribe('both + curry', () => {\n  it('with passed type', () => {\n    const fn = both<number>( // $ExpectType Predicate<number>\n      x => {\n        return x > 1\n      })(\n      x => {\n        return x % 2 === 0\n      },\n    );\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  });\n  it('no type passed', () => {\n    const fn = both(\n      x => {\n        x // $ExpectType unknown\n        return x as number > 1\n      })(\n      x => {\n        return x as number % 2 === 0\n      },\n    );\n    const result = fn(2) // $ExpectType boolean\n    result // $ExpectType boolean\n  });\n});\n",
    "methodName": "both",
    "example": "const fn = R.both(\n  a => a > 10,\n  a => a < 20\n)\nconsole.log(fn(15)) //=> true\nconsole.log(fn(30)) //=> false",
    "code": "export function both(f, g){\n  if (arguments.length === 1) return _g => both(f, _g)\n\n  return (...input) => f(...input) && g(...input)\n}",
    "spec": "import { both } from './both'\n\nconst firstFn = val => val > 0\nconst secondFn = val => val < 10\n\ntest('with curry', () => {\n  expect(both(firstFn)(secondFn)(17)).toBeFalse()\n})\n\ntest('without curry', () => {\n  expect(both(firstFn, secondFn)(7)).toBeTrue()\n})\n\ntest('with multiple inputs', () => {\n  const between = function(\n    a, b, c\n  ){ return a < b && b < c }\n  const total20 = function(\n    a, b, c\n  ){ return a + b + c === 20 }\n  const fn = both(between, total20)\n  expect(fn(\n    5, 7, 8\n  )).toBeTrue()\n})\n\ntest('skip evaluation of the second expression', () => {\n  let effect = 'not evaluated'\n  const F = function(){ return false }\n  const Z = function(){ effect = 'Z got evaluated' }\n  both(F, Z)()\n\n  expect(effect).toBe('not evaluated')\n})\n"
  },
  "clamp": {
    "explanation": "Restrict a number `input` to be withing `min` and `max` limits.\nIf `input` is bigger than `max`, then result is `max`.\nIf `input` is smaller than `min`, then result is `min`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "clamp",
    "example": "R.clamp(0, 10, 5) //=> 5\nR.clamp(0, 10, -1) //=> 0\nR.clamp(0, 10, 11) //=> 10",
    "code": "import { curry } from './curry'\n\nfunction clampFn(\n  lowLimit, highLimit, input\n){\n  if (input >= lowLimit && input <= highLimit) return input\n\n  if (input > highLimit) return highLimit\n  if (input < lowLimit) return lowLimit\n}\n\nexport const clamp = curry(clampFn)",
    "spec": "import { clamp } from './clamp'\n\ntest('rambda specs', () => {\n  expect(clamp(\n    1, 10, 0\n  )).toEqual(1)\n  expect(clamp(\n    3, 12, 1\n  )).toEqual(3)\n  expect(clamp(\n    -15, 3, -100\n  )).toEqual(-15)\n  expect(clamp(\n    1, 10, 20\n  )).toEqual(10)\n  expect(clamp(\n    3, 12, 23\n  )).toEqual(12)\n  expect(clamp(\n    -15, 3, 16\n  )).toEqual(3)\n  expect(clamp(\n    1, 10, 4\n  )).toEqual(4)\n  expect(clamp(\n    3, 12, 6\n  )).toEqual(6)\n  expect(clamp(\n    -15, 3, 0\n  )).toEqual(0)\n})\n"
  },
  "clone": {
    "explanation": "Creates a deep copy of the value which may contain (nested) Arrays and Objects, Numbers, Strings, Booleans and Dates.",
    "ramdaDiff": "var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('deep clone integers, strings and booleans', function() {\n  it('clones integers', function() {\n    eq(R.clone(-4), -4);\n    eq(R.clone(9007199254740991), 9007199254740991);\n  });\n  it('clones floats', function() {\n    eq(R.clone(-4.5), -4.5);\n    eq(R.clone(0.0), 0.0);\n  });\n  it('clones strings', function() {\n    eq(R.clone('ramda'), 'ramda');\n  });\n  it('clones booleans', function() {\n    eq(R.clone(true), true);\n  });\n});\ndescribe('deep clone objects', function() {\n  it('clones objects with circular references', function() {\n    var x = {c: null};\n    var y = {a: x};\n    var z = {b: y};\n    x.c = z;\n    var clone = R.clone(x);\n    assert.notStrictEqual(x, clone);\n    assert.notStrictEqual(x.c, clone.c);\n    assert.notStrictEqual(x.c.b, clone.c.b);\n    assert.notStrictEqual(x.c.b.a, clone.c.b.a);\n    assert.notStrictEqual(x.c.b.a.c, clone.c.b.a.c);\n    eq(R.keys(clone), R.keys(x));\n    eq(R.keys(clone.c), R.keys(x.c));\n    eq(R.keys(clone.c.b), R.keys(x.c.b));\n    eq(R.keys(clone.c.b.a), R.keys(x.c.b.a));\n    eq(R.keys(clone.c.b.a.c), R.keys(x.c.b.a.c));\n    x.c.b = 1;\n    assert.notDeepEqual(clone.c.b, x.c.b);\n  });\n});\ndescribe('deep clone arrays', function() {\n});\ndescribe('deep clone functions', function() {\n});\ndescribe('built-in types', function() {\n  it('clones RegExp object', function() {\n    R.forEach(function(pattern) {\n      var clone = R.clone(pattern);\n      assert.notStrictEqual(clone, pattern);\n      eq(clone.constructor, RegExp);\n      eq(clone.source, pattern.source);\n      eq(clone.global, pattern.global);\n      eq(clone.ignoreCase, pattern.ignoreCase);\n      eq(clone.multiline, pattern.multiline);\n    }, [/x/, /x/g, /x/i, /x/m, /x/gi, /x/gm, /x/im, /x/gim]);\n  });\n});\ndescribe('deep clone deep nested mixed objects', function() {\n  it('clones array with mutual ref object', function() {\n    var obj = {a: 1};\n    var list = [{b: obj}, {b: obj}];\n    var clone = R.clone(list);\n    assert.strictEqual(list[0].b, list[1].b);\n    assert.strictEqual(clone[0].b, clone[1].b);\n    assert.notStrictEqual(clone[0].b, list[0].b);\n    assert.notStrictEqual(clone[1].b, list[1].b);\n    eq(clone[0].b, {a:1});\n    eq(clone[1].b, {a:1});\n    obj.a = 2;\n    eq(clone[0].b, {a:1});\n    eq(clone[1].b, {a:1});\n  });\n});\ndescribe('deep clone edge cases', function() {\n  it('nulls, undefineds and empty objects and arrays', function() {\n    eq(R.clone(null), null);\n    eq(R.clone(undefined), undefined);\n    assert.notStrictEqual(R.clone(undefined), null);\n    var obj = {};\n    assert.notStrictEqual(R.clone(obj), obj);\n    var list = [];\n    assert.notStrictEqual(R.clone(list), list);\n  });\n});\ndescribe('Let `R.clone` use an arbitrary user defined `clone` method', function() {\n  it('dispatches to `clone` method if present', function() {\n    function ArbitraryClone(x) { this.value = x; }\n    ArbitraryClone.prototype.clone = function() { return new ArbitraryClone(this.value); };\n    var obj = new ArbitraryClone(42);\n    var arbitraryClonedObj = R.clone(obj);\n    eq(arbitraryClonedObj, new ArbitraryClone(42));\n    eq(arbitraryClonedObj instanceof ArbitraryClone, true);\n  });\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "CLONE",
        "date": "2019-11-13T11:24:41.471Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 20627735,
            "margin": 0.33,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 1331218,
            "margin": 0.28,
            "percentSlower": 93.55
          },
          {
            "name": "Lodash.cloneDeep",
            "ops": 2280068,
            "margin": 0.52,
            "percentSlower": 88.95
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst input = {\n  a : 1,\n  b : 2,\n}\n\nconst clone = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.clone(input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.clone(input)\n    },\n  },\n  {\n    label : 'Lodash.cloneDeep',\n    fn    : () => {\n      _.cloneDeep(input)\n    },\n  },\n]\n\nmodule.exports = clone\n"
    },
    "typingSpec": "",
    "methodName": "clone",
    "example": "const objects = [{}, {}, {}];\nconst objectsClone = R.clone(objects);\nobjects === objectsClone; //=> false\nobjects[0] === objectsClone[0]; //=> false",
    "code": "export function clone(val){\n  const out = Array.isArray(val) ? Array(val.length) : {}\n  if (val && val.getTime) return new Date(val.getTime())\n\n  for (const key in val){\n    const v = val[ key ]\n    out[ key ] =\n      typeof v === 'object' && v !== null ?\n        v.getTime ?\n          new Date(v.getTime()) :\n          clone(v) :\n        v\n  }\n\n  return out\n}",
    "spec": "import assert from 'assert'\n\nimport { clone } from './clone'\n\ntest('with array', () => {\n  const arr = [\n    {\n      b : 2,\n      c : 'foo',\n      d : [ 1, 2, 3 ],\n    },\n    1,\n    new Date(),\n    null,\n  ]\n  expect(clone(arr)).toEqual(arr)\n})\n\ntest('with object', () => {\n  const arr = {\n    a : 1,\n    b : 2,\n    c : 3,\n    d : [ 1, 2, 3 ],\n    e : new Date(),\n  }\n  expect(clone(arr)).toEqual(arr)\n})\n\ntest('with date', () => {\n  const date = new Date(\n    2014, 10, 14, 23, 59, 59, 999\n  )\n\n  const cloned = clone(date)\n  assert.notStrictEqual(date, cloned)\n  expect(cloned).toEqual(new Date(\n    2014, 10, 14, 23, 59, 59, 999\n  ))\n\n  expect(cloned.getDay()).toEqual(5)\n})\n"
  },
  "compose": {
    "explanation": "It performs right-to-left function composition.",
    "ramdaDiff": "var assert = require('assert');\nvar jsv = require('jsverify');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('compose', function() {\n  it('performs right-to-left function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.compose(R.map, R.multiply, parseInt);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.compose(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.compose(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });\n});\ndescribe('compose properties', function() {\n  jsv.property('composes two functions', jsv.fn(), jsv.fn(), jsv.nat, function(f, g, x) {\n    return R.equals(R.compose(f, g)(x), f(g(x)));\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "COMPOSE",
        "date": "2019-11-13T11:24:57.743Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 17071780,
            "margin": 0.48,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 838335,
            "margin": 2.4,
            "percentSlower": 95.09
          },
          {
            "name": "Lodash.flowRight",
            "ops": 3429490,
            "margin": 1.94,
            "percentSlower": 79.91
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst input = [ 1, 2, 3, 4 ]\nconst fns = [ val => val + 1, val => val.length ]\n\nconst compose = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.compose(...fns)(input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.compose(...fns)(input)\n    },\n  },\n  {\n    label : 'Lodash.flowRight',\n    fn    : () => {\n      _.flowRight(...fns)(input)\n    },\n  },\n]\n\nmodule.exports = compose\n"
    },
    "typingSpec": "",
    "methodName": "compose",
    "example": "const result = R.compose(\n  R.map(x => x * 2),both\n  R.filter(x => x > 2)\n)([1, 2, 3, 4])\n\n// => [6, 8]",
    "code": "export function compose(...fns){\n  if (fns.length === 0){\n    throw new Error('compose requires at least one argument')\n  }\n\n  return (...args) => {\n    const list = fns.slice()\n    if (list.length > 0){\n      const fn = list.pop()\n      let result = fn(...args)\n      while (list.length > 0){\n        result = list.pop()(result)\n      }\n\n      return result\n    }\n  }\n}",
    "spec": "import { add, filter, last, map } from '../rambda'\nimport { compose } from './compose'\n\ntest('happy', () => {\n  const result = compose(\n    last, map(add(10)), map(add(1))\n  )([ 1, 2, 3 ])\n\n  expect(result).toEqual(14)\n})\n\ntest('accepts initially two arguments', () => {\n  const result = compose(map(x => x * 2),\n    (a, y) => filter(x => x > y, a))([ 1, 2, 3, 4 ], 2)\n\n  expect(result).toEqual([ 6, 8 ])\n})\n\ntest('when no arguments is passed', () => {\n  expect(() => compose()).toThrow('compose requires at least one argument')\n})\n\ntest('ramda spec', () => {\n  const f = function(\n    a, b, c\n  ){\n    return [ a, b, c ]\n  }\n  const g = compose(f)\n  expect(g(\n    1, 2, 3\n  )).toEqual([ 1, 2, 3 ])\n})\n"
  },
  "complement": {
    "explanation": "It returns `complemented` function that accept `input` as argument.\n\nThe return value of `complemented` is the negative boolean value of `fn(input)`.",
    "ramdaDiff": "var S = require('sanctuary');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('complement', function() {\n  it('accepts fantasy-land functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.complement(Just(true)), Just(false));\n    eq(R.complement(Just(false)), Just(true));\n    eq(R.complement(Nothing()), Nothing());\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "complement",
    "example": "const fn = R.complement(x => !x)\n\nconst result = fn(false) // => false",
    "code": "export function complement(fn){\n  return (...input) => !fn(...input)\n}",
    "spec": "import { complement } from './complement'\n\ntest('happy', () => {\n  const fn = complement(x => x.length === 0)\n\n  expect(fn([ 1, 2, 3 ])).toBeTrue()\n})\n\ntest('with multiple parameters', () => {\n  const between = function(\n    a, b, c\n  ){\n    return a < b && b < c\n  }\n  const f = complement(between)\n  expect(f(\n    4, 5, 11\n  )).toEqual(false)\n  expect(f(\n    12, 2, 6\n  )).toEqual(true)\n})\n"
  },
  "concat": {
    "explanation": "It returns a new string or array, which is the result of merging `x` and `y`.",
    "ramdaDiff": "var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('concat', function() {\n  var z1 = {\n    x: 'z1',\n    concat: function(that) { return this.x + ' ' + that.x; }\n  };\n  var z2 = {\n    x: 'z2'\n  };\n  it('delegates to non-String object with a concat method, as second param', function() {\n    eq(R.concat(z1, z2), 'z1 z2');\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "concat",
    "example": "R.concat([1, 2])([3, 4]) // => [1, 2, 3, 4]\nR.concat('foo')('bar') // => 'foobar'",
    "code": "export function concat(left, right){\n  if (arguments.length === 1) return _right => concat(left, _right)\n\n  return typeof left === 'string' ? `${ left }${ right }` : [ ...left, ...right ]\n}",
    "spec": "import { concat } from './concat'\n\ntest('happy', () => {\n  const arr1 = [ 'a', 'b', 'c' ]\n  const arr2 = [ 'd', 'e', 'f' ]\n\n  const a = concat(arr1, arr2)\n  const b = concat(arr1)(arr2)\n  const expectedResult = [ 'a', 'b', 'c', 'd', 'e', 'f' ]\n\n  expect(a).toEqual(expectedResult)\n  expect(b).toEqual(expectedResult)\n})\n\ntest('with strings', () => {\n  expect(concat('ABC', 'DEF')).toEqual('ABCDEF')\n})\n"
  },
  "curry": {
    "explanation": "It returns curried version of `fn`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\nvar jsv = require('jsverify');\nvar funcN = require('./shared/funcN');\n\ndescribe('curry', function() {\n  it('properly reports the length of the curried function', function() {\n    var f = R.curry(function(a, b, c, d) {return (a + b * c) / d;});\n    eq(f.length, 4);\n    var g = f(12);\n    eq(g.length, 3);\n    var h = g(3);\n    eq(h.length, 2);\n    eq(g(3, 6).length, 1);\n  });\n  it('preserves context', function() {\n    var ctx = {x: 10};\n    var f = function(a, b) { return a + b * this.x; };\n    var g = R.curry(f);\n    eq(g.call(ctx, 2, 4), 42);\n    eq(g.call(ctx, 2).call(ctx, 4), 42);\n  });\n  it('supports R.__ placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = R.__;\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n  it('supports @@functional/placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n});\ndescribe('curry properties', function() {\n  jsv.property('curries multiple values', funcN(4), jsv.json, jsv.json, jsv.json, jsv.json, function(f, a, b, c, d) {\n    var g = R.curry(f);\n    return R.all(R.equals(f(a, b, c, d)), [\n      g(a, b, c, d),\n      g(a)(b)(c)(d),\n      g(a)(b, c, d),\n      g(a, b)(c, d),\n      g(a, b, c)(d)\n    ]);\n  jsv.property('curries with placeholder', funcN(3), jsv.json, jsv.json, jsv.json, function(f, a, b, c) {\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    var g = R.curry(f);\n    return R.all(R.equals(f(a, b, c)), [\n      g(_, _, c)(a, b),\n      g(a, _, c)(b),\n      g(_, b, c)(a),\n      g(a, _, _)(_, c)(b),\n      g(a, b, _)(c)\n    ]);\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "CURRY",
        "date": "2019-11-13T11:25:08.743Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 4012015,
            "margin": 0.82,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 2288738,
            "margin": 0.65,
            "percentSlower": 42.95
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst addFourNumbers = (a, b, c, d) => a + b + c + d\n\nconst curry = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      const curriedAddFourNumbers = R.curry(addFourNumbers)\n      const f = curriedAddFourNumbers(1, 2)\n      const g = f(3)\n\n      g(4)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      const curriedAddFourNumbers = Ramda.curry(addFourNumbers)\n      const f = curriedAddFourNumbers(1, 2)\n      const g = f(3)\n\n      g(4)\n    },\n  },\n]\n\nmodule.exports = curry\n"
    },
    "typingSpec": "",
    "methodName": "curry",
    "example": "const addFourNumbers = (a, b, c, d) => a + b + c + d\nconst curriedAddFourNumbers = R.curry(addFourNumbers)\nconst f = curriedAddFourNumbers(1, 2)\nconst g = f(3)\nconst result = g(4) // => 10",
    "code": "export function curry(fn, args = []){\n  return (..._args) =>\n    (rest => rest.length >= fn.length ? fn(...rest) : curry(fn, rest))([\n      ...args,\n      ..._args,\n    ])\n}",
    "spec": "import { curry } from './curry'\n\ntest('happy', () => {\n  const addFourNumbers = (\n    a, b, c, d\n  ) => a + b + c + d\n  const curriedAddFourNumbers = curry(addFourNumbers)\n  const f = curriedAddFourNumbers(1, 2)\n  const g = f(3)\n\n  expect(g(4)).toEqual(10)\n})\n\ntest('when called with more arguments', () => {\n  const add = curry((n, n2) => n + n2)\n\n  expect(add(\n    1, 2, 3\n  )).toEqual(3)\n})\n\ntest('when called with zero arguments', () => {\n  const sub = curry((a, b) => a - b)\n  const s0 = sub()\n\n  expect(s0(5, 2)).toEqual(3)\n})\n\ntest('when called via multiple curry stages', () => {\n  const join = curry((\n    a, b, c, d\n  ) => [ a, b, c, d ].join('-'))\n\n  const stage1 = join('A')\n  const stage2 = stage1('B', 'C')\n\n  expect(stage2('D')).toEqual('A-B-C-D')\n})\n"
  },
  "dec": {
    "explanation": "It decrements a number.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "dec",
    "example": "R.dec(2) // => 1",
    "code": "export const dec = n => n - 1",
    "spec": "import { dec } from './dec'\n\ntest('happy', () => {\n  expect(dec(2)).toBe(1)\n})\n"
  },
  "defaultTo": {
    "explanation": "It either returns `defaultValue`, if all of `inputArguments` are `undefined`, `null` or `NaN`.\n\nOr it returns the first truthy `inputArguments` instance(from left to right).",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { defaultTo } from 'rambda'\n\ndescribe('defaultTo with Ramda spec', () => {\n  it('happy', () => {\n    const x = defaultTo<string>('foo',undefined); // $ExpectType string\n    x // $ExpectType string\n  });\n  it('fallback', () => {\n    const x = defaultTo('foo',undefined); // $ExpectType \"foo\"\n    x // $ExpectType \"foo\"\n    const y = defaultTo('foo','bar'); // $ExpectType \"foo\" | \"bar\"\n    y // $ExpectType \"foo\" | \"bar\"\n  });\n  it('with one type', () => {\n    const x = defaultTo<string>('foo','bar'); // $ExpectType string\n    x // $ExpectType string\n  });\n  it('with two types', () => {\n    const x = defaultTo<string, number>('foo',1); // $ExpectType string | number\n    x // $ExpectType string | number\n  });\n});\n\ndescribe('defaultTo with Rambda spec', () => {\n  it('happy', () => {\n    const x = defaultTo<string>('foo',undefined, 'bar'); // $ExpectType string\n    x // $ExpectType string\n  });\n\n  it('happy with curry', () => {\n    const fn = defaultTo<string>('foo')\n    const x = fn(undefined, 'bar', null); // $ExpectType string\n    x // $ExpectType string\n    const y = fn(undefined); // $ExpectType string\n    y // $ExpectType string\n  });\n\n  it('with two types', () => {\n    const x = defaultTo<string, number>('foo',undefined, 1, null, 2, 'bar'); // $ExpectType string | number\n    x // $ExpectType string | number\n  });\n});\n",
    "methodName": "defaultTo",
    "example": "R.defaultTo('foo', undefined) // => 'foo'\nR.defaultTo('foo', undefined, null, NaN) // => 'foo'\nR.defaultTo('foo', undefined, 'bar', NaN, 'baz') // => 'bar'\nR.defaultTo('foo', undefined, null, NaN, 'baz') // => 'baz'\nR.defaultTo('foo', 'bar') // => 'bar'",
    "code": "function flagIs(inputArguments){\n  return (\n    inputArguments === undefined ||\n    inputArguments === null ||\n    Number.isNaN(inputArguments) === true\n  )\n}\n\nexport function defaultTo(defaultArgument, ...inputArguments){\n  if (arguments.length === 1){\n    return _inputArguments => defaultTo(defaultArgument, _inputArguments)\n  } else if (arguments.length === 2){\n    return flagIs(inputArguments[ 0 ]) ? defaultArgument : inputArguments[ 0 ]\n  }\n\n  const limit = inputArguments.length - 1\n  let len = limit + 1\n  let ready = false\n  let holder\n\n  while (!ready){\n    const instance = inputArguments[ limit - len + 1 ]\n\n    if (len === 0){\n      ready = true\n    } else if (flagIs(instance)){\n      len -= 1\n    } else {\n      holder = instance\n      ready = true\n    }\n  }\n\n  return holder === undefined ? defaultArgument : holder\n}",
    "spec": "import { defaultTo } from './defaultTo'\n\ntest('with undefined', () => {\n  expect(defaultTo('foo')(undefined)).toEqual('foo')\n})\n\ntest('with null', () => {\n  expect(defaultTo('foo')(null)).toEqual('foo')\n})\n\ntest('with NaN', () => {\n  expect(defaultTo('foo')(NaN)).toEqual('foo')\n})\n\ntest('with empty string', () => {\n  expect(defaultTo('foo', '')).toEqual('')\n})\n\ntest('with false', () => {\n  expect(defaultTo('foo', false)).toEqual(false)\n})\n\ntest('when inputArgument passes initial check', () => {\n  expect(defaultTo('foo', 'bar')).toEqual('bar')\n})\n\ntest('default extends to indefinite input arguments - case 1', () => {\n  const result = defaultTo(\n    'foo', null, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 2', () => {\n  const result = defaultTo(\n    'foo', null, NaN, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 3', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined\n  )\n  const expected = 'foo'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 4', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined, 'bar'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 5', () => {\n  const result = defaultTo(\n    'foo', null, NaN, 'bar', 'baz'\n  )\n  const expected = 'bar'\n\n  expect(result).toEqual(expected)\n})\n\ntest('default extends to indefinite input arguments - case 6', () => {\n  const result = defaultTo(\n    'foo', null, NaN, undefined, null, NaN\n  )\n  const expected = 'foo'\n\n  expect(result).toEqual(expected)\n})\n\n"
  },
  "dissoc": {
    "explanation": "It returns a new object that does not contain a `prop` property.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "dissoc",
    "example": "R.dissoc('b', {a: 1, b: 2, c: 3})\n//=> {a: 1, c: 3}",
    "code": "export function dissoc(prop, obj){\n  if (arguments.length === 1) return _obj => dissoc(prop, _obj)\n\n  if (obj === null || obj === undefined) return {}\n\n  const willReturn = {}\n  for (const p in obj){\n    willReturn[ p ] = obj[ p ]\n  }\n  delete willReturn[ prop ]\n\n  return willReturn\n}",
    "spec": "import { dissoc } from './dissoc'\n\ntest('input is null or undefined', () => {\n  expect(dissoc('b', null)).toEqual({})\n  expect(dissoc('b', undefined)).toEqual({})\n})\n\ntest('property exists curried', () => {\n  expect(dissoc('b')({\n    a : 1,\n    b : 2,\n  })).toEqual({ a : 1 })\n})\n\ntest('property doesn\\'t exists', () => {\n  expect(dissoc('c', {\n    a : 1,\n    b : 2,\n  })).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('works with non-string property', () => {\n  expect(dissoc(42, {\n    a  : 1,\n    42 : 2,\n  })).toEqual({ a : 1 })\n\n  expect(dissoc(null, {\n    a    : 1,\n    null : 2,\n  })).toEqual({ a : 1 })\n\n  expect(dissoc(undefined, {\n    a         : 1,\n    undefined : 2,\n  })).toEqual({ a : 1 })\n})\n\ntest('includes prototype properties', () => {\n  function Rectangle(width, height){\n    this.width = width\n    this.height = height\n  }\n  const area = Rectangle.prototype.area = function(){\n    return this.width * this.height\n  }\n  const rect = new Rectangle(7, 6)\n\n  expect(dissoc('area', rect)).toEqual({\n    width  : 7,\n    height : 6,\n  })\n\n  expect(dissoc('width', rect)).toEqual({\n    height : 6,\n    area   : area,\n  })\n\n  expect(dissoc('depth', rect)).toEqual({\n    width  : 7,\n    height : 6,\n    area   : area,\n  })\n})\n"
  },
  "drop": {
    "explanation": "It returns `arrOrStr` with `howManyToDrop` items dropped from the left.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "DROP",
        "date": "2019-11-13T11:25:36.230Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 43744156,
            "margin": 2.61,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 4724526,
            "margin": 0.76,
            "percentSlower": 89.2
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst input = [ 1, 2, 3, 4 ]\n\nconst drop = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.drop(3, input)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.drop(3, input)\n    },\n  },\n]\n\nmodule.exports = drop\n"
    },
    "typingSpec": "import { drop } from 'rambda'\n\ndescribe('drop', () => {\n  it('happy', () => {\n    const x = drop(2, 'foo'); // $ExpectType string\n    x // $ExpectType string\n    const xx = drop(2)('foo'); // $ExpectType string\n    xx // $ExpectType string\n    const y = drop(2, [1,2,3]); // $ExpectType number[]\n    y // $ExpectType number[]\n    const yy = drop<number>(2)([1,2,3]); // $ExpectType number[]\n    yy // $ExpectType number[]\n  });\n});\n",
    "methodName": "drop",
    "example": "R.drop(1, ['foo', 'bar', 'baz']) // => ['bar', 'baz']\nR.drop(1, 'foo')  // => 'oo'",
    "code": "export function drop(n, listOrString){\n  if (arguments.length === 1) return _list => drop(n, _list)\n\n  return listOrString.slice(n > 0 ? n : 0)\n}",
    "spec": "import assert from 'assert'\n\nimport { drop } from './drop'\n\ntest('with array', () => {\n  expect(drop(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'baz' ])\n  expect(drop(3, [ 'foo', 'bar', 'baz' ])).toEqual([])\n  expect(drop(4, [ 'foo', 'bar', 'baz' ])).toEqual([])\n})\n\ntest('with string', () => {\n  expect(drop(3, 'rambda')).toEqual('bda')\n})\n\ntest('with non-positive count', () => {\n  expect(drop(0, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(drop(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(drop(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('should return copy', () => {\n  const xs = [ 1, 2, 3 ]\n\n  assert.notStrictEqual(drop(0, xs), xs)\n  assert.notStrictEqual(drop(-1, xs), xs)\n})\n"
  },
  "dropLast": {
    "explanation": "It returns `arrOrStr` with `howManyToDrop` items dropped from the right.",
    "ramdaDiff": "var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('dropLast', function() {\n  it('can act as a transducer', function() {\n    var dropLast2 = R.dropLast(2);\n    assert.deepEqual(R.into([], dropLast2, [1, 3, 5, 7, 9, 1, 2]), [1, 3, 5, 7, 9]);\n    assert.deepEqual(R.into([], dropLast2, [1]), []);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "dropLast",
    "example": "R.dropLast(1, ['foo', 'bar', 'baz']) // => ['foo', 'bar']\nR.dropLast(1, 'foo')  // => 'fo'",
    "code": "export function dropLast(n, list){\n  if (arguments.length === 1) return _list => dropLast(n, _list)\n\n  return n > 0 ? list.slice(0, -n) : list.slice()\n}",
    "spec": "import assert from 'assert'\n\nimport { dropLast } from './dropLast'\n\ntest('with array', () => {\n  expect(dropLast(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'foo' ])\n  expect(dropLast(3, [ 'foo', 'bar', 'baz' ])).toEqual([])\n  expect(dropLast(4, [ 'foo', 'bar', 'baz' ])).toEqual([])\n})\n\ntest('with string', () => {\n  expect(dropLast(3, 'rambda')).toEqual('ram')\n})\n\ntest('with non-positive count', () => {\n  expect(dropLast(0, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(dropLast(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(dropLast(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('should return copy', () => {\n  const xs = [ 1, 2, 3 ]\n\n  assert.notStrictEqual(dropLast(0, xs), xs)\n  assert.notStrictEqual(dropLast(-1, xs), xs)\n})\n"
  },
  "endsWith": {
    "explanation": "",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('startsWith', function() {\n  it('should return true when an array ends with the provided value', function() {\n    eq(R.endsWith(['c'], ['a', 'b', 'c']), true);\n  });\n  it('should return true when an array ends with the provided values', function() {\n    eq(R.endsWith(['b', 'c'], ['a', 'b', 'c']), true);\n  });\n  it('should return false when an array does not end with the provided value', function() {\n    eq(R.endsWith(['b'], ['a', 'b', 'c']), false);\n  });\n  it('should return false when an array does not end with the provided values', function() {\n    eq(R.endsWith(['a', 'b'], ['a', 'b', 'c']), false);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "endsWith",
    "example": "R.endsWith(\n  'bar',\n  'foo-bar'\n) // => true\n\nR.endsWith(\n  'foo',\n  'foo-bar'\n) // => false",
    "code": "export function endsWith(suffix, list){\n  if (arguments.length === 1) return _list => endsWith(suffix, _list)\n\n  return list.endsWith(suffix)\n}",
    "spec": "import { endsWith } from './endsWith'\n\ntest('string ends with suffix', () => {\n  expect(endsWith('bar', 'foo-bar')).toBeTrue()\n})\n\ntest('currying', () => {\n  expect(endsWith('baz')('foo-bar')).toBeFalse()\n})\n\ntest('list ends with suffix', () => {\n  expect(() => endsWith([ 'c' ], [ 'a', 'b', 'c' ])).toThrow('list.endsWith is not a function')\n})\n"
  },
  "either": {
    "explanation": "",
    "ramdaDiff": "var S = require('sanctuary');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('either', function() {\n  it('accepts fantasy-land applicative functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.either(Just(true), Just(true)), Just(true));\n    eq(R.either(Just(true), Just(false)), Just(true));\n    eq(R.either(Just(false), Just(false)), Just(false));\n    eq(R.either(Just(true), Nothing()), Nothing());\n    eq(R.either(Nothing(), Just(false)), Nothing());\n    eq(R.either(Nothing(), Nothing()), Nothing());\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "either",
    "example": "R.either(\n  a => a > 10,\n  a => a % 2 === 0\n)(15) //=> true",
    "code": "export function either(f, g){\n  if (arguments.length === 1) return _g => either(f, _g)\n\n  return (...input) => f(...input) || g(...input)\n}",
    "spec": "import { either } from './either'\n\ntest('with multiple inputs', () => {\n  const between = function(\n    a, b, c\n  ){ return a < b && b < c }\n  const total20 = function(\n    a, b, c\n  ){ return a + b + c === 20 }\n  const fn = either(between, total20)\n  expect(fn(\n    7, 8, 5\n  )).toBeTrue()\n})\n\ntest('skip evaluation of the second expression', () => {\n  let effect = 'not evaluated'\n  const F = function(){ return true }\n  const Z = function(){ effect = 'Z got evaluated' }\n  either(F, Z)()\n\n  expect(effect).toBe('not evaluated')\n})\n\ntest('case 1', () => {\n  const firstFn = val => val > 0\n  const secondFn = val => val * 5 > 10\n\n  expect(either(firstFn, secondFn)(1)).toBeTrue()\n})\n\ntest('case 2', () => {\n  const firstFn = val => val > 0\n  const secondFn = val => val === -10\n  const fn = either(firstFn)(secondFn)\n\n  expect(fn(-10)).toBeTrue()\n})\n"
  },
  "equals": {
    "explanation": "It returns equality match between `a` and `b`.\n\nIt doesn't handle cyclical data structures.",
    "ramdaDiff": "/* global Map, Set, WeakMap, WeakSet */\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('equals', function() {\n  var a = [];\n  var b = a;\n  it('never considers Boolean primitive equal to Boolean object', function() {\n    eq(R.equals(true, new Boolean(true)), false);\n    eq(R.equals(new Boolean(true), true), false);\n    eq(R.equals(false, new Boolean(false)), false);\n    eq(R.equals(new Boolean(false), false), false);\n  });\n  it('never considers number primitive equal to Number object', function() {\n    eq(R.equals(0, new Number(0)), false);\n    eq(R.equals(new Number(0), 0), false);\n  });\n  it('never considers string primitive equal to String object', function() {\n    eq(R.equals('', new String('')), false);\n    eq(R.equals(new String(''), ''), false);\n    eq(R.equals('x', new String('x')), false);\n    eq(R.equals(new String('x'), 'x'), false);\n  });\n  var supportsSticky = false;\n  try { RegExp('', 'y'); supportsSticky = true; } catch (e) {}\n  var supportsUnicode = false;\n  try { RegExp('', 'u'); supportsUnicode = true; } catch (e) {}\n  var listA = [1, 2, 3];\n  var listB = [1, 3, 2];\n  var c = {}; c.v = c;\n  var d = {}; d.v = d;\n  var e = []; e.push(e);\n  var f = []; f.push(f);\n  var nestA = {a:[1, 2, {c:1}], b:1};\n  var nestB = {a:[1, 2, {c:1}], b:1};\n  var nestC = {a:[1, 2, {c:2}], b:1};\n  it('handles recursive data structures', function() {\n    eq(R.equals(c, d), true);\n    eq(R.equals(e, f), true);\n    eq(R.equals(nestA, nestB), true);\n    eq(R.equals(nestA, nestC), false);\n  });\n  it('requires that both objects have the same enumerable properties with the same values', function() {\n    var a1 = [];\n    var a2 = [];\n    a2.x = 0;\n    var b1 = new Boolean(false);\n    var b2 = new Boolean(false);\n    b2.x = 0;\n    var d1 = new Date(0);\n    var d2 = new Date(0);\n    d2.x = 0;\n    var n1 = new Number(0);\n    var n2 = new Number(0);\n    n2.x = 0;\n    var r1 = /(?:)/;\n    var r2 = /(?:)/;\n    r2.x = 0;\n    var s1 = new String('');\n    var s2 = new String('');\n    s2.x = 0;\n    eq(R.equals(a1, a2), false);\n    eq(R.equals(b1, b2), false);\n    eq(R.equals(d1, d2), false);\n    eq(R.equals(n1, n2), false);\n    eq(R.equals(r1, r2), false);\n    eq(R.equals(s1, s2), false);\n  });\n  if (typeof ArrayBuffer !== 'undefined' && typeof Int8Array !== 'undefined') {\n    var typArr1 = new ArrayBuffer(10);\n    typArr1[0] = 1;\n    var typArr2 = new ArrayBuffer(10);\n    typArr2[0] = 1;\n    var typArr3 = new ArrayBuffer(10);\n    var intTypArr = new Int8Array(typArr1);\n    typArr3[0] = 0;\n    it('handles typed arrays', function() {\n      eq(R.equals(typArr1, typArr2), true);\n      eq(R.equals(typArr1, typArr3), false);\n      eq(R.equals(typArr1, intTypArr), false);\n    });\n  }\n  if (typeof Promise !== 'undefined') {\n    it('compares Promise objects by identity', function() {\n      var p = Promise.resolve(42);\n      var q = Promise.resolve(42);\n      eq(R.equals(p, p), true);\n      eq(R.equals(p, q), false);\n    });\n  }\n  if (typeof Map !== 'undefined') {\n    it('compares Map objects by value', function() {\n      eq(R.equals(new Map([]), new Map([])), true);\n      eq(R.equals(new Map([]), new Map([[1, 'a']])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[1, 'a']])), true);\n      eq(R.equals(new Map([[1, 'a'], [2, 'b']]), new Map([[2, 'b'], [1, 'a']])), true);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[2, 'a']])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[1, 'b']])), false);\n      eq(R.equals(new Map([[1, 'a'], [2, new Map([[3, 'c']])]]), new Map([[1, 'a'], [2, new Map([[3, 'c']])]])), true);\n      eq(R.equals(new Map([[1, 'a'], [2, new Map([[3, 'c']])]]), new Map([[1, 'a'], [2, new Map([[3, 'd']])]])), false);\n      eq(R.equals(new Map([[[1, 2, 3], [4, 5, 6]]]), new Map([[[1, 2, 3], [4, 5, 6]]])), true);\n      eq(R.equals(new Map([[[1, 2, 3], [4, 5, 6]]]), new Map([[[1, 2, 3], [7, 8, 9]]])), false);\n    });\n    it('dispatches to `equals` method recursively in Set', function() {\n      var a = new Map();\n      var b = new Map();\n      a.set(a, a);\n      eq(R.equals(a, b), false);\n      a.set(b, b);\n      b.set(b, b);\n      b.set(a, a);\n      eq(R.equals(a, b), true);\n    });\n  }\n  if (typeof Set !== 'undefined') {\n    it('compares Set objects by value', function() {\n      eq(R.equals(new Set([]), new Set([])), true);\n      eq(R.equals(new Set([]), new Set([1])), false);\n      eq(R.equals(new Set([1]), new Set([])), false);\n      eq(R.equals(new Set([1, 2]), new Set([2, 1])), true);\n      eq(R.equals(new Set([1, new Set([2, new Set([3])])]), new Set([1, new Set([2, new Set([3])])])), true);\n      eq(R.equals(new Set([1, new Set([2, new Set([3])])]), new Set([1, new Set([2, new Set([4])])])), false);\n      eq(R.equals(new Set([[1, 2, 3], [4, 5, 6]]), new Set([[1, 2, 3], [4, 5, 6]])), true);\n      eq(R.equals(new Set([[1, 2, 3], [4, 5, 6]]), new Set([[1, 2, 3], [7, 8, 9]])), false);\n    });\n    it('dispatches to `equals` method recursively in Set', function() {\n      var a = new Set();\n      var b = new Set();\n      a.add(a);\n      eq(R.equals(a, b), false);\n      a.add(b);\n      b.add(b);\n      b.add(a);\n      eq(R.equals(a, b), true);\n    });\n  }\n  if (typeof WeakMap !== 'undefined') {\n    it('compares WeakMap objects by identity', function() {\n      var m = new WeakMap([]);\n      eq(R.equals(m, m), true);\n      eq(R.equals(m, new WeakMap([])), false);\n    });\n  }\n  if (typeof WeakSet !== 'undefined') {\n    it('compares WeakSet objects by identity', function() {\n      var s = new WeakSet([]);\n      eq(R.equals(s, s), true);\n      eq(R.equals(s, new WeakSet([])), false);\n    });\n  }\n  it('dispatches to `equals` method recursively', function() {\n    function Left(x) { this.value = x; }\n    Left.prototype.equals = function(x) {\n      return x instanceof Left && R.equals(x.value, this.value);\n    };\n    function Right(x) { this.value = x; }\n    Right.prototype.equals = function(x) {\n      return x instanceof Right && R.equals(x.value, this.value);\n    };\n    eq(R.equals(new Left([42]), new Left([42])), true);\n    eq(R.equals(new Left([42]), new Left([43])), false);\n    eq(R.equals(new Left(42), {value: 42}), false);\n    eq(R.equals({value: 42}, new Left(42)), false);\n    eq(R.equals(new Left(42), new Right(42)), false);\n    eq(R.equals(new Right(42), new Left(42)), false);\n    eq(R.equals([new Left(42)], [new Left(42)]), true);\n    eq(R.equals([new Left(42)], [new Right(42)]), false);\n    eq(R.equals([new Right(42)], [new Left(42)]), false);\n    eq(R.equals([new Right(42)], [new Right(42)]), true);\n  });\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "EQUALS",
        "date": "2019-11-13T11:26:03.758Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 1403639,
            "margin": 0.3,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 212400,
            "margin": 0.53,
            "percentSlower": 84.87
          },
          {
            "name": "Lodash",
            "ops": 564047,
            "margin": 0.21,
            "percentSlower": 59.82
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst a = { a : { b : { c : 1 } } }\nconst b = { a : { b : { c : 1 } } }\n\nconst equals = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.equals(a, b)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.equals(a, b)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.isEqual(a, b)\n    },\n  },\n]\n\nmodule.exports = equals\n"
    },
    "typingSpec": "",
    "methodName": "equals",
    "example": "R.equals(\n  [1, {a:2}, [{b:3}]],\n  [1, {a:2}, [{b:3}]]\n) // => true",
    "code": "import { type } from './type'\n\nfunction parseError(maybeError){\n  const typeofError = maybeError.__proto__.toString()\n  if (![ 'Error', 'TypeError' ].includes(typeofError)) return []\n\n  return [ typeofError, maybeError.message ]\n}\n\nfunction parseDate(maybeDate){\n  if (!maybeDate.toDateString) return [ false ]\n\n  return [ true, maybeDate.getTime() ]\n}\n\nfunction parseRegex(maybeRegex){\n  if (maybeRegex.constructor !== RegExp) return [ false ]\n\n  return [ true, maybeRegex.toString() ]\n}\n\nexport function equals(a, b){\n  if (arguments.length === 1) return _b => equals(a, _b)\n\n  const aType = type(a)\n\n  if (aType !== type(b)) return false\n  if ([ 'NaN', 'Undefined', 'Null' ].includes(aType)) return true\n  if ([ 'Boolean', 'Number', 'String' ].includes(aType)) return a.toString() === b.toString()\n\n  if (aType === 'Array'){\n    const aClone = Array.from(a)\n    const bClone = Array.from(b)\n\n    if (aClone.toString() !== bClone.toString()){\n      return false\n    }\n\n    let loopArrayFlag = true\n    aClone.forEach((aCloneInstance, aCloneIndex) => {\n      if (loopArrayFlag){\n        if (\n          aCloneInstance !== bClone[ aCloneIndex ] &&\n          !equals(aCloneInstance, bClone[ aCloneIndex ])\n        ){\n          loopArrayFlag = false\n        }\n      }\n    })\n\n    return loopArrayFlag\n  }\n\n  const aRegex = parseRegex(a)\n  const bRegex = parseRegex(b)\n\n  if (aRegex[ 0 ]){\n    return bRegex[ 0 ] ? aRegex[ 1 ] === bRegex[ 1 ] : false\n  } else if (bRegex[ 0 ]) return false\n\n  const aDate = parseDate(a)\n  const bDate = parseDate(b)\n\n  if (aDate[ 0 ]){\n    return bDate[ 0 ] ? aDate[ 1 ] === bDate[ 1 ] : false\n  } else if (bDate[ 0 ]) return false\n\n  const aError = parseError(a)\n  const bError = parseError(b)\n\n  if (\n    aError[ 0 ]\n  ){\n    return bError[ 0 ] ?\n      aError[ 0 ] === bError[ 0 ] && aError[ 1 ] === bError[ 1 ] :\n      false\n  }\n\n  if (aType === 'Object'){\n    const aKeys = Object.keys(a)\n\n    if (aKeys.length !== Object.keys(b).length){\n      return false\n    }\n\n    let loopObjectFlag = true\n    aKeys.forEach(aKeyInstance => {\n      if (loopObjectFlag){\n        const aValue = a[ aKeyInstance ]\n        const bValue = b[ aKeyInstance ]\n\n        if (aValue !== bValue && !equals(aValue, bValue)){\n          loopObjectFlag = false\n        }\n      }\n    })\n\n    return loopObjectFlag\n  }\n\n  return false\n}",
    "spec": "import { equals } from './equals'\n\ntest('happy', () => {\n  const result = equals([ 1, { a : 1 }, [ { b : 3 } ] ],\n    [ 1, { a : 2 }, [ { b : 3 } ] ])\n\n  expect(result).toBeFalse()\n})\n\ntest('with regex', () => {\n  expect(equals(/s/, /s/)).toEqual(true)\n  expect(equals(/s/, /d/)).toEqual(false)\n  expect(equals(/a/gi, /a/ig)).toEqual(true)\n  expect(equals(/a/mgi, /a/img)).toEqual(true)\n  expect(equals(/a/gi, /a/i)).toEqual(false)\n})\n\ntest('not a number', () => {\n  expect(equals([ NaN ], [ NaN ])).toBe(true)\n})\n\ntest('new number', () => {\n  expect(equals(new Number(0), new Number(0))).toEqual(true)\n  expect(equals(new Number(0), new Number(1))).toEqual(false)\n  expect(equals(new Number(1), new Number(0))).toEqual(false)\n})\n\ntest('new string', () => {\n  expect(equals(new String(''), new String(''))).toEqual(true)\n  expect(equals(new String(''), new String('x'))).toEqual(false)\n  expect(equals(new String('x'), new String(''))).toEqual(false)\n  expect(equals(new String('foo'), new String('foo'))).toEqual(true)\n  expect(equals(new String('foo'), new String('bar'))).toEqual(false)\n  expect(equals(new String('bar'), new String('foo'))).toEqual(false)\n})\n\ntest('new Boolean', () => {\n  expect(equals(new Boolean(true), new Boolean(true))).toEqual(true)\n  expect(equals(new Boolean(false), new Boolean(false))).toEqual(true)\n  expect(equals(new Boolean(true), new Boolean(false))).toEqual(false)\n  expect(equals(new Boolean(false), new Boolean(true))).toEqual(false)\n})\n\ntest('new Error', () => {\n  expect(equals(new Error('XXX'), {})).toEqual(false)\n  expect(equals(new Error('XXX'), new TypeError('XXX'))).toEqual(false)\n  expect(equals(new Error('XXX'), new Error('YYY'))).toEqual(false)\n  expect(equals(new Error('XXX'), new Error('XXX'))).toEqual(true)\n  expect(equals(new Error('XXX'), new TypeError('YYY'))).toEqual(false)\n})\n\ntest('with dates', () => {\n  expect(equals(new Date(0), new Date(0))).toEqual(true)\n  expect(equals(new Date(1), new Date(1))).toEqual(true)\n  expect(equals(new Date(0), new Date(1))).toEqual(false)\n  expect(equals(new Date(1), new Date(0))).toEqual(false)\n  expect(equals(new Date(0), {})).toEqual(false)\n  expect(equals({}, new Date(0))).toEqual(false)\n})\n\ntest('ramda spec', () => {\n  expect(equals({}, {})).toEqual(true)\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    a : 1,\n    b : 2,\n  })).toEqual(true)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n  },\n  {\n    b : 3,\n    a : 2,\n  })).toEqual(true)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n  },\n  {\n    a : 3,\n    b : 3,\n  })).toEqual(false)\n\n  expect(equals({\n    a : 2,\n    b : 3,\n    c : 1,\n  },\n  {\n    a : 2,\n    b : 3,\n  })).toEqual(false)\n})\n\ntest('works with boolean tuple', () => {\n  expect(equals([ true, false ], [ true, false ])).toBeTrue()\n  expect(equals([ true, false ], [ true, true ])).toBeFalse()\n})\n\ntest('works with equal objects within array', () => {\n  const objFirst = {\n    a : {\n      b : 1,\n      c : 2,\n      d : [ 1 ],\n    },\n  }\n  const objSecond = {\n    a : {\n      b : 1,\n      c : 2,\n      d : [ 1 ],\n    },\n  }\n\n  const x = [ 1, 2, objFirst, null, '', [] ]\n  const y = [ 1, 2, objSecond, null, '', [] ]\n  expect(equals(x, y)).toBeTrue()\n})\n\ntest('works with different objects within array', () => {\n  const objFirst = { a : { b : 1 } }\n  const objSecond = { a : { b : 2 } }\n\n  const x = [ 1, 2, objFirst, null, '', [] ]\n  const y = [ 1, 2, objSecond, null, '', [] ]\n  expect(equals(x, y)).toBeFalse()\n})\n\ntest('works with undefined as second argument', () => {\n  expect(equals(1, undefined)).toBeFalse()\n\n  expect(equals(undefined, undefined)).toBeTrue()\n})\n\ntest('various examples', () => {\n  expect(equals([ 1, 2, 3 ])([ 1, 2, 3 ])).toBeTrue()\n\n  expect(equals([ 1, 2, 3 ], [ 1, 2 ])).toBeFalse()\n\n  expect(equals(1, 1)).toBeTrue()\n\n  expect(equals(1, '1')).toBeFalse()\n\n  expect(equals({}, {})).toBeTrue()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 2,\n    a : 1,\n  })).toBeTrue()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    a : 1,\n    b : 1,\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : false,\n  },\n  {\n    a : 1,\n    b : 1,\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 2,\n    a : 1,\n    c : 3,\n  })).toBeFalse()\n\n  expect(equals({\n    x : {\n      a : 1,\n      b : 2,\n    },\n  },\n  {\n    x : {\n      b : 2,\n      a : 1,\n      c : 3,\n    },\n  })).toBeFalse()\n\n  expect(equals({\n    a : 1,\n    b : 2,\n  },\n  {\n    b : 3,\n    a : 1,\n  })).toBeFalse()\n\n  expect(equals({ a : { b : { c : 1 } } }, { a : { b : { c : 1 } } })).toBeTrue()\n\n  expect(equals({ a : { b : { c : 1 } } }, { a : { b : { c : 2 } } })).toBeFalse()\n\n  expect(equals({ a : {} }, { a : {} })).toBeTrue()\n\n  expect(equals('', '')).toBeTrue()\n\n  expect(equals('foo', 'foo')).toBeTrue()\n\n  expect(equals('foo', 'bar')).toBeFalse()\n\n  expect(equals(0, false)).toBeFalse()\n\n  expect(equals(/\\s/g, null)).toBeFalse()\n\n  expect(equals(null, null)).toBeTrue()\n\n  expect(equals(false)(null)).toBeFalse()\n})\n"
  },
  "filter": {
    "explanation": "It filters `x` iterable over boolean returning `filterFn`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('filter', function() {\n  var even = function(x) {return x % 2 === 0;};\n  it('dispatches to passed-in non-Array object with a `filter` method', function() {\n    var f = {filter: function(f) { return f('called f.filter'); }};\n    eq(R.filter(function(s) { return s; }, f), 'called f.filter');\n  });\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "FILTER",
        "date": "2019-11-13T11:26:20.041Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 39855937,
            "margin": 0.87,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 10909111,
            "margin": 0.52,
            "percentSlower": 72.63
          },
          {
            "name": "Lodash",
            "ops": 35159419,
            "margin": 0.8,
            "percentSlower": 11.78
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst arr = [ 1, 2, 3, 4 ]\nconst fn = x => x > 2\nconst filter = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.filter(fn, arr)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.filter(fn, arr)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.filter(arr, fn)\n    },\n  },\n]\n\nmodule.exports = filter\n"
    },
    "typingSpec": "import { filter } from 'rambda'\n\ndescribe('filter with array', () => {\n  it('1 curry', () => {\n    const x = filter<number>((a)=> { // $ExpectType number[]\n      a // $ExpectType number\n      return a > 1\n    })([1,2,3]);\n    x // $ExpectType number[]\n  });\n  it('1', () => {\n    const x = filter<number>((a)=> { // $ExpectType number[]\n      a // $ExpectType number\n      return a > 1\n    },[1,2,3]);\n    x // $ExpectType number[]\n  });\n  it('2', () => {\n    const x = filter<number>((a, b)=> { // $ExpectType number[]\n      a // $ExpectType number\n      return a > 1\n    },[1,2,3]);\n    x // $ExpectType number[]\n  });\n})\n\ndescribe('filter with objects', () => {\n  it('curry', () => {\n    const x = filter<number, number>((a,b,c)=> { // $ExpectType Dictionary<number>\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n\n      return a > 1\n    })({a:1,b:2});\n    x // $ExpectType Dictionary<number>\n  });\n\n  it('object with three arguments predicate', () => {\n    const x = filter<number>((a,b,c)=> { // $ExpectType Dictionary<number>\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n\n      return a > 1\n    },{a:1,b:2});\n    x // $ExpectType Dictionary<number>\n  });\n\n  it('object with two arguments predicate', () => {\n    const x = filter<number>((a,b)=> { // $ExpectType Dictionary<number>\n      b // $ExpectType string\n      return a > 1\n    },{a:1,b:2});\n    x // $ExpectType Dictionary<number>\n  });\n  it('object with one argument predicate', () => {\n    const x = filter<number>((a)=> { // $ExpectType Dictionary<number>\n      a // $ExpectType number\n      return a > 1\n    },{a:1,b:2});\n    x // $ExpectType Dictionary<number>\n  });\n});\n",
    "methodName": "filter",
    "example": "const filterFn = a => a % 2 === 0\n\nconst result = R.filter(filterFn, [1, 2, 3, 4])\n// => [2, 4]\n\nconst objResult = R.filter(filterFn, {a: 1, b: 2})\n// => {b: 2}",
    "code": "function filterObject(fn, obj){\n  const willReturn = {}\n\n  for (const prop in obj){\n    if (fn(\n      obj[ prop ], prop, obj\n    )){\n      willReturn[ prop ] = obj[ prop ]\n    }\n  }\n\n  return willReturn\n}\n\nexport function filter(fn, list){\n  if (arguments.length === 1) return _list => filter(fn, _list)\n\n  if (!list) return []\n\n  if (!Array.isArray(list)){\n    return filterObject(fn, list)\n  }\n\n  let index = -1\n  let resIndex = 0\n  const len = list.length\n  const willReturn = []\n\n  while (++index < len){\n    const value = list[ index ]\n\n    if (fn(value, index)){\n      willReturn[ resIndex++ ] = value\n    }\n  }\n\n  return willReturn\n}",
    "spec": "import Ramda from 'ramda'\n\nimport { filter } from './filter'\nimport { T } from './T'\n\nconst sampleObject = {\n  a : 1,\n  b : 2,\n  c : 3,\n  d : 4,\n}\n\ntest('happy', () => {\n  const isEven = n => n % 2 === 0\n\n  expect(filter(isEven, [ 1, 2, 3, 4 ])).toEqual([ 2, 4 ])\n  expect(filter(isEven, {\n    a : 1,\n    b : 2,\n    d : 3,\n  })).toEqual({ b : 2 })\n})\n\ntest('bad inputs', () => {\n  expect(filter(T)(undefined)).toEqual([])\n  expect(filter(T, null)).toEqual([])\n  expect(() => Ramda.filter(T, null)).toThrow()\n  expect(() => Ramda.filter(T, undefined)).toThrow()\n})\n\ntest('predicate when input is object', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n  }\n  const predicate = (\n    val, prop, inputObject\n  ) => {\n    expect(inputObject).toEqual(obj)\n    expect(typeof prop).toEqual('string')\n\n    return val < 2\n  }\n  expect(filter(predicate, obj)).toEqual({ a : 1 })\n})\n\ntest('pass index as second argument', () => {\n  let counter = 0\n  filter((x, i) => {\n    expect(i).toBe(counter)\n    counter++\n  },\n  [ 10, 20, 30 ])\n})\n\ntest('with object', () => {\n  const isEven = n => n % 2 === 0\n  const result = filter(isEven, sampleObject)\n  const expectedResult = {\n    b : 2,\n    d : 4,\n  }\n\n  expect(result).toEqual(expectedResult)\n})\n"
  },
  "find": {
    "explanation": "It returns `undefined` or the first element of `arr` satisfying `findFn`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "FIND",
        "date": "2019-11-13T11:26:36.393Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 33301799,
            "margin": 0.24,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 17354496,
            "margin": 0.68,
            "percentSlower": 47.89
          },
          {
            "name": "Lodash",
            "ops": 13257546,
            "margin": 0.32,
            "percentSlower": 60.19
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Lodash",
          "index": 2
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst fn = x => x > 2\nconst list = [ 1, 2, 3, 4 ]\n\nconst find = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.find(fn, list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.find(fn, list)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.find(list, fn)\n    },\n  },\n]\n\nmodule.exports = find\n"
    },
    "typingSpec": "",
    "methodName": "find",
    "example": "const findFn = a => R.type(a.foo) === 'Number'\nconst arr = [{foo: 'bar'}, {foo: 1}]\n\nconst result = R.find(findFn, arr)\n// => {foo: 1}",
    "code": "export function find(fn, list){\n  if (arguments.length === 1) return _list => find(fn, _list)\n\n  return list.find(fn)\n}",
    "spec": "import { find } from './find'\nimport { propEq } from './propEq'\n\ntest('happy', () => {\n  expect(find(propEq('a', 2), [ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual({ a : 2 })\n})\n\ntest('with curry', () => {\n  expect(find(propEq('a', 4))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(undefined)\n})\n"
  },
  "findIndex": {
    "explanation": "It returns `-1` or the index of the first element of `arr` satisfying `findFn`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "findIndex",
    "example": "const findFn = a => R.type(a.foo) === 'Number'\nconst arr = [{foo: 'bar'}, {foo: 1}]\n\nconst result = R.findIndex(findFn, arr)\n// => 1",
    "code": "export function findIndex(fn, list){\n  if (arguments.length === 1) return _list => findIndex(fn, _list)\n\n  const len = list.length\n  let index = -1\n\n  while (++index < len){\n    if (fn(list[ index ], index)){\n      return index\n    }\n  }\n\n  return -1\n}",
    "spec": "import { findIndex } from './findIndex'\nimport { propEq } from './propEq'\n\ntest('happy', () => {\n  expect(findIndex(propEq('a', 2))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(1)\n\n  expect(findIndex(propEq('a', 1))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(0)\n\n  expect(findIndex(propEq('a', 4))([ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual(-1)\n})\n\ntest('pass index as second argument', () => {\n  findIndex((x, i) => {\n    expect(typeof x).toBe('number')\n    expect(typeof i).toBe('number')\n  })([ 10, 12, 15 ])\n})\n"
  },
  "findLast": {
    "explanation": "It returns `undefined` or the last element of `arr` satisfying `findFn`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "findLast",
    "example": "const findFn = a => R.type(a.foo) === 'Number'\nconst arr = [{foo: 'bar'}, {foo: 1}]\n\nconst result = R.findLast(findFn, arr)\n// => {foo: 1}",
    "code": "export function findLast(fn, list){\n  if (arguments.length === 1) return _list => findLast(fn, _list)\n\n  let index = list.length\n\n  while (--index >= 0){\n    if (fn(list[ index ], index)){\n      return list[ index ]\n    }\n  }\n\n  return undefined\n}",
    "spec": "import { findLast } from './findLast'\n\ntest('happy', () => {\n  const result = findLast((x, i) => {\n    expect(typeof i).toBe('number')\n\n    return x > 1\n  }, [ 1, 1, 1, 2, 3, 4, 1 ])\n  expect(result).toEqual(4)\n\n  expect(findLast(x => x === 0, [ 0, 1, 1, 2, 3, 4, 1 ])).toEqual(0)\n})\n\ntest('with curry', () => {\n  expect(findLast(x => x > 1)([ 1, 1, 1, 2, 3, 4, 1 ])).toEqual(4)\n})\n\nconst obj1 = { x : 100 }\nconst obj2 = { x : 200 }\nconst a = [ 11, 10, 9, 'cow', obj1, 8, 7, 100, 200, 300, obj2, 4, 3, 2, 1, 0 ]\nconst even = function(x){ return x % 2 === 0 }\nconst gt100 = function(x){ return x > 100 }\nconst isStr = function(x){ return typeof x === 'string' }\nconst xGt100 = function(o){ return o && o.x > 100 }\n\ntest('ramda 1', () => {\n  expect(findLast(even, a)).toEqual(0)\n  expect(findLast(gt100, a)).toEqual(300)\n  expect(findLast(isStr, a)).toEqual('cow')\n  expect(findLast(xGt100, a)).toEqual(obj2)\n})\n\ntest('ramda 2', () => {\n  expect(findLast(even, [ 'zing' ])).toEqual(undefined)\n})\n\ntest('ramda 3', () => {\n  expect(findLast(even, [ 2, 3, 5 ])).toEqual(2)\n})\n\ntest('ramda 4', () => {\n  expect(findLast(even, [])).toEqual(undefined)\n})\n"
  },
  "findLastIndex": {
    "explanation": "It returns `-1` or the last index of the first element of `arr` satisfying `findFn`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "findLastIndex",
    "example": "const findFn = a => R.type(a.foo) === 'Number'\nconst arr = [{foo: 'bar'}, {foo: 1}]\n\nconst result = R.findLastIndex(findFn, arr)\n// => 1",
    "code": "export function findLastIndex(fn, list){\n  if (arguments.length === 1) return _list => findLastIndex(fn, _list)\n\n  let index = list.length\n\n  while (--index >= 0){\n    if (fn(list[ index ], index)){\n      return index\n    }\n  }\n\n  return -1\n}",
    "spec": "import { findLastIndex } from './findLastIndex'\n\ntest('happy', () => {\n  const result = findLastIndex((x, i) => {\n    expect(typeof i).toBe('number')\n\n    return x > 1\n  }, [ 1, 1, 1, 2, 3, 4, 1 ])\n\n  expect(result).toEqual(5)\n\n  expect(findLastIndex(x => x === 0, [ 0, 1, 1, 2, 3, 4, 1 ])).toEqual(0)\n})\n\ntest('with curry', () => {\n  expect(findLastIndex(x => x > 1)([ 1, 1, 1, 2, 3, 4, 1 ])).toEqual(5)\n})\n\nconst obj1 = { x : 100 }\nconst obj2 = { x : 200 }\nconst a = [ 11, 10, 9, 'cow', obj1, 8, 7, 100, 200, 300, obj2, 4, 3, 2, 1, 0 ]\nconst even = function(x){\n  return x % 2 === 0\n}\nconst gt100 = function(x){\n  return x > 100\n}\nconst isStr = function(x){\n  return typeof x === 'string'\n}\nconst xGt100 = function(o){\n  return o && o.x > 100\n}\n\ntest('ramda 1', () => {\n  expect(findLastIndex(even, a)).toEqual(15)\n  expect(findLastIndex(gt100, a)).toEqual(9)\n  expect(findLastIndex(isStr, a)).toEqual(3)\n  expect(findLastIndex(xGt100, a)).toEqual(10)\n})\n\ntest('ramda 2', () => {\n  expect(findLastIndex(even, [ 'zing' ])).toEqual(-1)\n})\n\ntest('ramda 3', () => {\n  expect(findLastIndex(even, [ 2, 3, 5 ])).toEqual(0)\n})\n\ntest('ramda 4', () => {\n  expect(findLastIndex(even, [])).toEqual(-1)\n})\n"
  },
  "flatten": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "FLATTEN",
        "date": "2019-11-13T11:27:09.375Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 22853375,
            "margin": 0.55,
            "percentSlower": 10.31
          },
          {
            "name": "Ramda",
            "ops": 911163,
            "margin": 0.55,
            "percentSlower": 96.42
          },
          {
            "name": "Lodash",
            "ops": 25479962,
            "margin": 1.02,
            "percentSlower": 0
          }
        ],
        "fastest": {
          "name": "Lodash",
          "index": 2
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst list = [ 1, [ 2, [ 3, 4, 6 ] ] ]\n\nconst flatten = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.flatten(list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.flatten(list)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.flatten(list)\n    },\n  },\n]\n\nmodule.exports = flatten\n"
    },
    "typingSpec": "",
    "methodName": "flatten",
    "example": "R.flatten([ 1, [ 2, [ 3 ] ] ])\n// => [ 1, 2, 3 ]",
    "code": "export function flatten(list, input){\n  const willReturn = input === undefined ? [] : input\n\n  for (let i = 0; i < list.length; i++){\n    if (Array.isArray(list[ i ])){\n      flatten(list[ i ], willReturn)\n    } else {\n      willReturn.push(list[ i ])\n    }\n  }\n\n  return willReturn\n}",
    "spec": "import { flatten } from './flatten'\n\ntest('happy', () => {\n  expect(flatten([ 1, 2, 3, [ [ [ [ [ 4 ] ] ] ] ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, [ 2, [ [ 3 ] ] ], [ 4 ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, [ 2, [ [ [ 3 ] ] ] ], [ 4 ] ])).toEqual([ 1, 2, 3, 4 ])\n\n  expect(flatten([ 1, 2, [ 3, 4 ], 5, [ 6, [ 7, 8, [ 9, [ 10, 11 ], 12 ] ] ] ])).toEqual([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ])\n})\n"
  },
  "flip": {
    "explanation": "It returns function which calls `fn` with exchanged first and second argument.",
    "ramdaDiff": "var jsv = require('jsverify');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\nvar funcN = require('./shared/funcN');\ndescribe('flip', function() {\n  it('returns a function which inverts the first two arguments to the supplied function', function() {\n    var f = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    var g = R.flip(f);\n    eq(f('a', 'b', 'c'), 'a b c');\n    eq(g('a', 'b', 'c'), 'b a c');\n  });\n  it('returns a curried function', function() {\n    var f = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    var g = R.flip(f)('a');\n    eq(g('b', 'c'), 'b a c');\n  });\n  it('returns a function with the correct arity', function() {\n    var f2 = function(a, b) {return a + ' ' + b;};\n    var f3 = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    eq(R.flip(f2).length, 2);\n    eq(R.flip(f3).length, 3);\n  });\n});\ndescribe('flip properties', function() {\n  jsv.property('inverts first two arguments', funcN(3), jsv.json, jsv.json, jsv.json, function(f, a, b, c) {\n    var g = R.flip(f);\n    return R.equals(f(a, b, c), g(b, a, c));\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "flip",
    "example": "const subtractFlip = R.flip(R.subtract)\n\nconst result = subtractFlip(1,7)\n// => 6",
    "code": "function flipExport(fn){\n  return (...input) => {\n    if (input.length === 1){\n      return holder => fn(holder, input[ 0 ])\n    } else if (input.length === 2){\n      return fn(input[ 1 ], input[ 0 ])\n    }\n\n    return undefined\n  }\n}\n\nexport function flip(fn){\n  return flipExport(fn)\n}",
    "spec": "import { flip } from './flip'\nimport { subtract } from './subtract'\n\ntest('flip', () => {\n  const fn = flip(subtract)\n\n  expect(fn(1)(7)).toEqual(6)\n  expect(fn(1, 7)).toEqual(6)\n  expect(fn(\n    1, 7, 9\n  )).toEqual(undefined)\n})\n"
  },
  "forEach": {
    "explanation": "It applies function `fn` over all members of iterable `x` and returns `x`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('forEach', function() {\n  var list = [{x: 1, y: 2}, {x: 100, y: 200}, {x: 300, y: 400}, {x: 234, y: 345}];\n  it('dispatches to `forEach` method', function() {\n    var dispatched = false;\n    var fn = function() {};\n    function DummyList() {}\n    DummyList.prototype.forEach = function(callback) {\n      dispatched = true;\n      eq(callback, fn);\n    };\n    R.forEach(fn, new DummyList());\n    eq(dispatched, true);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "forEach",
    "example": "const sideEffect = {}\nconst result = R.forEach(\n  x => sideEffect[`foo${x}`] = x\n)([1, 2])\n\nconsole.log(sideEffect) //=> {foo1 : 1, foo2 : 2}\nconsole.log(result) //=> [1, 2]",
    "code": "import { map } from './map'\n\nexport function forEach(fn, list){\n  if (arguments.length === 1) return _list => forEach(fn, _list)\n\n  map(fn, list)\n\n  return list\n}",
    "spec": "import { forEach } from './forEach'\nimport { type } from './type'\n\ntest('iterate over object', () => {\n  const obj = {\n    a : 1,\n    b : [ 1, 2 ],\n    c : { d : 7 },\n    f : 'foo',\n  }\n  const result = {}\n  const returned = forEach((\n    val, prop, inputObj\n  ) => {\n    expect(type(inputObj)).toBe('Object')\n    result[ prop ] = `${ prop }-${ type(val) }`\n  })(obj)\n\n  const expected = {\n    a : 'a-Number',\n    b : 'b-Array',\n    c : 'c-Object',\n    f : 'f-String',\n  }\n\n  expect(result).toEqual(expected)\n  expect(returned).toEqual(obj)\n})\n\ntest('happy', () => {\n  const sideEffect = {}\n  forEach(x => sideEffect[ `foo${ x }` ] = x + 10)([ 1, 2 ])\n\n  expect(sideEffect).toEqual({\n    foo1 : 11,\n    foo2 : 12,\n  })\n})\n\ntest('happy 2', () => {\n  const list = [\n    {\n      x : 1,\n      y : 2,\n    },\n    {\n      x : 100,\n      y : 200,\n    },\n    {\n      x : 300,\n      y : 400,\n    },\n    {\n      x : 234,\n      y : 345,\n    },\n  ]\n  const sideEffect = {}\n  const result = forEach(elem => {\n    sideEffect[ elem.x ] = elem.y\n  }, list)\n  const expectedSideEffect = {\n    1   : 2,\n    100 : 200,\n    300 : 400,\n    234 : 345,\n  }\n\n  expect(sideEffect).toEqual(expectedSideEffect)\n  expect(result).toEqual(list)\n})\n\ntest('with empty list', () => {\n  const list = []\n  const result = forEach(x => x * x)(list)\n\n  expect(result).toEqual(list)\n})\n\ntest('returns the input', () => {\n  const list = [ 1, 2, 3 ]\n  const result = forEach(x => x * x)(list)\n\n  expect(result).toEqual(list)\n})\n\ntest('pass index as second argument', () => {\n  const list = [ 11, 21, 31 ]\n  const indexes = []\n  const result = forEach((x, i) => indexes.push(i))(list)\n\n  expect(indexes).toEqual([ 0, 1, 2 ])\n})\n"
  },
  "fromPairs": {
    "explanation": "It transforms a list to an object.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "fromPairs",
    "example": "const list = [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', [ 3, 4 ] ] ]\nconst expected = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\n\nconst result = R.fromPairs(list)\n// expected === result",
    "code": "export function fromPairs(list){\n  const toReturn = {}\n  list.forEach(([ prop, value ]) => toReturn[ prop ] = value)\n\n  return toReturn\n}",
    "spec": "import { fromPairs } from './fromPairs'\n\nconst list = [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', [ 3, 4 ] ] ]\nconst expected = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\n\ntest('happy', () => {\n  expect(fromPairs(list)).toEqual(expected)\n})\n"
  },
  "groupBy": {
    "explanation": "It groups array `arr` by provided selector function `fn`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\nvar _isTransformer = require('rambda/internal/_isTransformer');\n\ndescribe('groupBy', function() {\n  it('dispatches on transformer objects in list position', function() {\n    var byType = R.prop('type');\n    var xf = {\n      '@@transducer/init': function() { return {}; },\n      '@@transducer/result': function(x) { return x; },\n      '@@transducer/step': R.mergeRight\n    };\n    eq(_isTransformer(R.groupBy(byType, xf)), true);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "groupBy",
    "example": "R.groupBy(\n  x => x.length,\n  [ 'a', 'b', 'aa', 'bb' ]\n)\n// => { '1': ['a', 'b'], '2': ['aa', 'bb'] }",
    "code": "export function groupBy(fn, list){\n  if (arguments.length === 1) return _list => groupBy(fn, _list)\n\n  const result = {}\n  for (let i = 0; i < list.length; i++){\n    const item = list[ i ]\n    const key = fn(item)\n\n    if (!result[ key ]){\n      result[ key ] = []\n    }\n\n    result[ key ].push(item)\n  }\n\n  return result\n}",
    "spec": "import { groupBy } from './groupBy'\nimport { prop } from './prop'\n\ntest('groupBy', () => {\n  const list = [\n    {\n      age  : 12,\n      name : 'john',\n    },\n    {\n      age  : 12,\n      name : 'jack',\n    },\n    {\n      age  : 24,\n      name : 'mary',\n    },\n    {\n      age  : 24,\n      name : 'steve',\n    },\n  ]\n  const expectedResult = {\n    12 : [ {\n      age  : 12,\n      name : 'john',\n    }, {\n      age  : 12,\n      name : 'jack',\n    } ],\n    24 : [ {\n      age  : 24,\n      name : 'mary',\n    }, {\n      age  : 24,\n      name : 'steve',\n    } ],\n  }\n\n  expect(groupBy(prop('age'))(list)).toEqual(expectedResult)\n  expect(groupBy(prop('age'), list)).toEqual(expectedResult)\n})\n"
  },
  "groupWith": {
    "explanation": "It creates a groups of array members defined by equality function `fn`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('groupWith', function() {\n  it('splits the list into groups according to the grouping function', function() {\n    eq(R.groupWith(R.equals, [1, 2, 2, 3]), [[1], [2, 2], [3]]);\n    eq(R.groupWith(R.equals, [1, 1, 1, 1]), [[1, 1, 1, 1]]);\n    eq(R.groupWith(R.equals, [1, 2, 3, 4]), [[1], [2], [3], [4]]);\n  });\n  it('can be turned into the original list through concatenation', function() {\n    var list = [1, 1, 2, 3, 4, 4, 5, 5];\n    eq(R.unnest(R.groupWith(R.equals, list)), list);\n    eq(R.unnest(R.groupWith(R.complement(R.equals), list)), list);\n    eq(R.unnest(R.groupWith(R.T, list)), list);\n    eq(R.unnest(R.groupWith(R.F, list)), list);\n  });\n  it('also works on strings', function() {\n    eq(R.groupWith(R.equals)('Mississippi'), ['M','i','ss','i','ss','i','pp','i']);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "groupWith",
    "example": "const list = [ 4, 3, 6, 2, 2, 1 ]\nconst result = R.groupWith(\n  (a,b) => a - b === 0,\n  list\n)\nconst expected = [\n  [ 4, 3 ],\n  [ 6 ],\n  [ 2 ],\n  [ 2, 1 ],\n]\n// result === expected",
    "code": "export function groupWith(predicate, list){\n  const toReturn = []\n  let holder = []\n\n  list.reduce((\n    prev, current, i\n  ) => {\n    if (i > 0 && predicate(prev, current)){\n      if (holder.length === 0){\n        holder.push(prev)\n        holder.push(current)\n      } else {\n        holder.push(current)\n      }\n    } else if (i > 0){\n      if (holder.length === 0){\n        toReturn.push([ prev ])\n        if (i === list.length - 1) holder.push(current)\n      } else {\n        toReturn.push(holder)\n        holder = []\n      }\n    }\n\n    return current\n  }, undefined)\n\n  return holder.length === 0 ? toReturn : [ ...toReturn, holder ]\n}",
    "spec": "import { equals } from './equals'\nimport { groupWith } from './groupWith'\n\ntest('happy', () => {\n  const result = groupWith(equals, [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 21, 21, 1, 2 ])\n\n  const expected = [ [ 0 ], [ 1, 1 ], [ 2 ], [ 3 ], [ 5 ], [ 8 ], [ 13 ], [ 21, 21, 21 ], [ 1 ], [ 2 ] ]\n\n  expect(result).toEqual(expected)\n})\n\ntest('readme example', () => {\n  const list = [ 4, 3, 6, 2, 2, 1 ]\n\n  const result = groupWith((a, b) => a - b === 1, list)\n  const expected = [ [ 4, 3 ], [ 6 ], [ 2 ], [ 2, 1 ] ]\n  expect(result).toEqual(expected)\n})\n\ntest('throw with string as input', () => {\n  expect(() => groupWith(equals, 'Mississippi')).toThrowWithMessage(TypeError,\n    'list.reduce is not a function')\n})\n\ntest('from ramda', () => {\n  expect(groupWith(equals, [])).toEqual([])\n\n  const isConsecutive = function(a, b){\n    return a + 1 === b\n  }\n  expect(groupWith(isConsecutive, [])).toEqual([])\n  expect(groupWith(isConsecutive, [ 4, 3, 2, 1 ])).toEqual([ [ 4 ], [ 3 ], [ 2 ], [ 1 ] ])\n  expect(groupWith(isConsecutive, [ 1, 2, 3, 4 ])).toEqual([ [ 1, 2, 3, 4 ] ])\n  expect(groupWith(isConsecutive, [ 1, 2, 2, 3 ])).toEqual([\n    [ 1, 2 ],\n    [ 2, 3 ],\n  ])\n  expect(groupWith(isConsecutive, [ 1, 2, 9, 3, 4 ])).toEqual([ [ 1, 2 ], [ 9 ], [ 3, 4 ] ])\n})\n"
  },
  "has": {
    "explanation": "- It returns `true` if `obj` has property `prop`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('has', function() {\n  var fred = {name: 'Fred', age: 23};\n  var anon = {age: 99};\n  it('does not check properties from the prototype chain', function() {\n    var Person = function() {};\n    Person.prototype.age = function() {};\n    var bob = new Person();\n    eq(R.has('age', bob), false);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "has",
    "example": "R.has('a', {a: 1}) // => true\nR.has('b', {a: 1}) // => false",
    "code": "export function has(prop, obj){\n  if (arguments.length === 1) return _obj => has(prop, _obj)\n\n  if (!obj) return false\n\n  return obj[ prop ] !== undefined\n}",
    "spec": "import { has } from './has'\n\ntest('happy', () => {\n  expect(has('a')({ a : 1 })).toBeTrue()\n  expect(has('b', { a : 1 })).toBeFalse()\n})\n\ntest('with non-object', () => {\n  expect(has('a', undefined)).toEqual(false)\n  expect(has('a', null)).toEqual(false)\n  expect(has('a', true)).toEqual(false)\n  expect(has('a', '')).toEqual(false)\n  expect(has('a', /a/)).toEqual(false)\n})\n"
  },
  "head": {
    "explanation": "It returns the first element of `arrOrStr`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "head",
    "example": "R.head([1, 2, 3]) // => 1\nR.head('foo') // => 'f'",
    "code": "export function head(list){\n  if (typeof list === 'string') return list[ 0 ] || ''\n\n  return list[ 0 ]\n}",
    "spec": "import { head } from './head'\n\ntest('head', () => {\n  expect(head([ 'fi', 'fo', 'fum' ])).toEqual('fi')\n  expect(head([])).toEqual(undefined)\n  expect(head('foo')).toEqual('f')\n  expect(head('')).toEqual('')\n})\n"
  },
  "identical": {
    "explanation": "Returns true if its arguments are identical, false otherwise. Values are identical if they reference the same memory. NaN is identical to NaN; 0 and -0 are not identical.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "identical",
    "example": "const o = {};\nR.identical(o, o); //=> true\nR.identical(1, 1); //=> true\nR.identical(1, '1'); //=> false\nR.identical([], []); //=> false\nR.identical(0, -0); //=> false\nR.identical(NaN, NaN); //=> true",
    "code": "import _objectIs from './internal/_objectIs'\n\nexport function identical(a, b){\n  if (arguments.length === 1) return _b => identical(a, _b)\n\n  return _objectIs(a, b)\n}",
    "spec": "import { F, T } from '../rambda.js'\nimport { identical } from './identical'\nimport { _isInteger } from './internal/_isInteger'\nimport { _objectIs } from './internal/_objectIs'\n\ntest('with boolean', () => {\n  expect(F()).toBe(false)\n  expect(T()).toBe(true)\n})\n\ntest('internal isInteger', () => {\n  expect(_isInteger(1)).toBe(true)\n  expect(_isInteger(0.3)).toBe(false)\n})\n\ntest('internal objectIs', () => {\n  expect(_objectIs(1, 1)).toBe(true)\n  expect(_objectIs(NaN, NaN)).toBe(true)\n})\n\ntest('identical', () => {\n  const a = {}\n\n  expect(identical(100)(100)).toEqual(true)\n  expect(identical(100, '100')).toEqual(false)\n  expect(identical('string', 'string')).toEqual(true)\n  expect(identical([], [])).toEqual(false)\n  expect(identical(a, a)).toEqual(true)\n  expect(identical(undefined, undefined)).toEqual(true)\n  expect(identical(null, undefined)).toEqual(false)\n})\n"
  },
  "identity": {
    "explanation": "It just passes back the supplied arguments.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "identity",
    "example": "R.identity(7) // => 7",
    "code": "export function identity(x){\n  return x\n}",
    "spec": "import { identity } from './identity'\n\ntest('happy', () => {\n  expect(identity(7)).toEqual(7)\n  expect(identity(true)).toEqual(true)\n  expect(identity({ a : 1 })).toEqual({ a : 1 })\n})\n"
  },
  "ifElse": {
    "explanation": "It returns another function. When this new function is called with `input` argument, it will return either `ifFn(input)` or `elseFn(input)` depending on `condition(input)` evaluation.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('ifElse', function() {\n  var t = function(a) { return a + 1; };\n  var identity = function(a) { return a; };\n  var isArray = function(a) { return Object.prototype.toString.call(a) === '[object Array]'; };\n  it('returns a function whose arity equals the max arity of the three arguments to `ifElse`', function() {\n    function a0() { return 0; }\n    function a1(x) { return x; }\n    function a2(x, y) { return x + y; }\n    eq(R.ifElse(a0, a1, a2).length, 2);\n    eq(R.ifElse(a0, a2, a1).length, 2);\n    eq(R.ifElse(a1, a0, a2).length, 2);\n    eq(R.ifElse(a1, a2, a0).length, 2);\n    eq(R.ifElse(a2, a0, a1).length, 2);\n    eq(R.ifElse(a2, a1, a0).length, 2);\n  });\n  it('returns a curried function', function() {\n    var v = function(a) { return typeof a === 'number'; };\n    var ifIsNumber = R.ifElse(v);\n    eq(ifIsNumber(t, identity)(15), 16);\n    eq(ifIsNumber(t, identity)('hello'), 'hello');\n    var fn = R.ifElse(R.gt, R.subtract, R.add);\n    eq(fn(2)(7), 9);\n    eq(fn(2, 7), 9);\n    eq(fn(7)(2), 5);\n    eq(fn(7, 2), 5);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "ifElse",
    "example": "const fn = R.ifElse(\n x => x > 10,\n x => x*2,\n x => x*10\n)\n\nconst result = fn(8)\n// => 80",
    "code": "import { curry } from './curry'\n\nfunction ifElseFn(\n  condition, onTrue, onFalse\n){\n\n  return (...input) => {\n    const conditionResult = typeof condition === 'boolean' ? condition : condition(...input)\n\n    if (conditionResult === true){\n      return onTrue(...input)\n    }\n\n    return onFalse(...input)\n  }\n}\n\nexport const ifElse = curry(ifElseFn)",
    "spec": "import { always, has, identity, prop } from '../rambda'\nimport { ifElse } from './ifElse'\n\nconst condition = has('foo')\nconst v = function(a){\n  return typeof a === 'number'\n}\nconst t = function(a){\n  return a + 1\n}\nconst ifFn = x => prop('foo', x).length\nconst elseFn = () => false\n\ntest('happy', () => {\n  const fn = ifElse(condition, ifFn)(elseFn)\n\n  expect(fn({ foo : 'bar' })).toEqual(3)\n  expect(fn({ fo : 'bar' })).toEqual(false)\n})\n\ntest('ramda spec', () => {\n  const ifIsNumber = ifElse(v)\n  expect(ifIsNumber(t, identity)(15)).toEqual(16)\n  expect(ifIsNumber(t, identity)('hello')).toEqual('hello')\n})\n\ntest('pass all arguments', () => {\n  const identity = function(a){\n    return a\n  }\n  const v = function(){\n    return true\n  }\n  const onTrue = function(a, b){\n    expect(a).toEqual(123)\n    expect(b).toEqual('abc')\n  }\n  ifElse(\n    v, onTrue, identity\n  )(123, 'abc')\n})\n\ntest('accept constant as condition', () => {\n  const fn = ifElse(true)(always(true))(always(false))\n\n  expect(fn()).toEqual(true)\n})\n\ntest('accept constant as condition - case 2', () => {\n  const fn = ifElse(\n    false, always(true), always(false)\n  )\n\n  expect(fn()).toEqual(false)\n})\n\ntest('curry 1', () => {\n  const fn = ifElse(condition, ifFn)(elseFn)\n\n  expect(fn({ foo : 'bar' })).toEqual(3)\n  expect(fn({ fo : 'bar' })).toEqual(false)\n})\n\ntest('curry 2', () => {\n  const fn = ifElse(condition)(ifFn)(elseFn)\n\n  expect(fn({ foo : 'bar' })).toEqual(3)\n  expect(fn({ fo : 'bar' })).toEqual(false)\n})\n"
  },
  "inc": {
    "explanation": "It increments a number.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "inc",
    "example": "R.inc(1) // => 2",
    "code": "export const inc = n => n + 1",
    "spec": "import { inc } from './inc'\n\ntest('happy', () => {\n  expect(inc(1)).toBe(2)\n})\n"
  },
  "includes": {
    "explanation": "If `input` is string, then this method work as native `includes`.\nIf `input` is array, then `R.equals` is used to define if `valueToFind` belongs to the list.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('includes', function() {\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.includes(0, [-0]), false);\n    eq(R.includes(-0, [0]), false);\n    eq(R.includes(NaN, [NaN]), true);\n    eq(R.includes(new Just([42]), [new Just([42])]), true);\n  });\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "INCLUDES",
        "date": "2019-12-18T21:50:33.865Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 7033531,
            "margin": 5.34,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 2334817,
            "margin": 5.4,
            "percentSlower": 66.8
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst str = 'more is less'\n\nconst includes = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.includes('less')(str)\n      R.includes('more', str)\n      R.includes('foo', str)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.includes('less')(str)\n      Ramda.includes('more', str)\n      Ramda.includes('foo', str)\n    },\n  },\n]\n\nmodule.exports = includes\n"
    },
    "typingSpec": "",
    "methodName": "includes",
    "example": "R.includes('oo', 'foo') // => true\nR.includes({a: 1}, [{a: 1}]) // => true",
    "code": "import { equals } from './equals'\n\nexport function includes(target, list){\n  if (arguments.length === 1) return _input => includes(target, _input)\n\n  if (typeof list === 'string'){\n    return list.includes(target)\n  }\n  if (!Array.isArray(list)) return false\n\n  let index = -1\n\n  while (++index < list.length){\n    if (equals(list[ index ], target)){\n      return true\n    }\n  }\n\n  return false\n}",
    "spec": "import R from 'ramda'\n\nimport { includes } from './includes'\n\ntest('includes with string', () => {\n  const str = 'more is less'\n\n  expect(includes('less')(str)).toBeTrue()\n  expect(R.includes('less')(str)).toBeTrue()\n  expect(includes('never', str)).toBeFalse()\n  expect(R.includes('never', str)).toBeFalse()\n})\n\ntest('includes with array', () => {\n  const arr = [ 1, 2, 3 ]\n\n  expect(includes(2)(arr)).toBeTrue()\n  expect(R.includes(2)(arr)).toBeTrue()\n\n  expect(includes(4, arr)).toBeFalse()\n  expect(R.includes(4, arr)).toBeFalse()\n})\n\ntest('return false if input is falsy', () => {\n  expect(includes(2, null)).toBeFalse()\n  expect(() => R.includes(2, null)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'indexOf\\' of null')\n  expect(includes(4, undefined)).toBeFalse()\n  expect(() => R.includes(4, undefined)).toThrowWithMessage(TypeError,\n    'Cannot read property \\'indexOf\\' of undefined')\n})\n"
  },
  "indexBy": {
    "explanation": "Generates object with properties provided by `condition` and values provided by `arr`. If `condition` is a string, then it is passed to `R.path`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('indexBy', function() {\n  it('can act as a transducer', function() {\n    var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];\n    var transducer = R.compose(\n      R.indexBy(R.prop('id')),\n      R.map(R.pipe(\n        R.adjust(0, R.toUpper),\n        R.adjust(1, R.omit(['id']))\n      )));\n    var result = R.into({}, transducer, list);\n    eq(result, {ABC: {title: 'B'}, XYZ: {title: 'A'}});\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { indexBy } from 'rambda'\n\nconst list = [\n  {a:{b:'1'}},\n  {a:{c:'2'}},\n  {a:{b:'3'}},\n]\n\ndescribe('indexBy', () => {\n  it('happy', () => {\n    const result = indexBy<any>(x => x.a.b, list); \n    const resultCurried = indexBy<any>(x => x.a.b)(list); \n    result // $ExpectType { [key: string]: any; }\n    resultCurried // $ExpectType { [key: string]: any; }\n  });\n\n  it('with string', () => {\n    const result = indexBy<any>('a.b', list); \n    const resultCurried = indexBy<any>('a.b')(list); \n    result // $ExpectType { [key: string]: any; }\n    resultCurried // $ExpectType { [key: string]: any; }\n  });\n\n  it('with interface', () => {\n    interface Foo{\n      a: string\n    }\n    const interfaceList = [{a:'foo'}, {a:'bar'}]\n    const result = indexBy<Foo>(x => {\n      x.a // $ExpectType string\n      return x.a\n    }, interfaceList); \n    const resultCurried = indexBy<Foo>(x => {\n      x.a // $ExpectType string\n      return x.a\n    })(interfaceList); \n    result // $ExpectType { [key: string]: Foo; }\n    resultCurried // $ExpectType { [key: string]: Foo; }\n  });\n});\n",
    "methodName": "indexBy",
    "example": "const arr = [ {id: 1}, {id: 2} ]\nconst result = R.indexBy(\n  x => x.id,\n  arr\n)\nconst pathResult = R.indexBy(\n  'id',\n  arr\n)\n// => { 1: {id: 1}, 2: {id: 2} }\n// pathResult === result",
    "code": "import { path } from './path'\n\nfunction indexByPath(pathInput, list){\n  const toReturn = {}\n  for (let i = 0; i < list.length; i++){\n    const item = list[ i ]\n    toReturn[ path(pathInput, item) ] = item\n  }\n\n  return toReturn\n}\n\nexport function indexBy(fnOrPath, list){\n  if (arguments.length === 1){\n    return _list => indexBy(fnOrPath, _list)\n  }\n\n  if (typeof fnOrPath === 'string'){\n    return indexByPath(fnOrPath, list)\n  }\n\n  const toReturn = {}\n  for (let i = 0; i < list.length; i++){\n    const item = list[ i ]\n    toReturn[ fnOrPath(item) ] = item\n  }\n\n  return toReturn\n}",
    "spec": "import { indexBy } from './indexBy'\nimport { prop } from './prop'\n\ntest('happy', () => {\n  const list = [\n    { id : 1 },\n    {\n      id : 1,\n      a  : 2,\n    },\n    { id : 2 },\n    { id : 10 },\n    { id : 'a' },\n  ]\n\n  expect(indexBy(prop('id'))(list)).toEqual({\n    1 : {\n      id : 1,\n      a  : 2,\n    },\n    2  : { id : 2 },\n    10 : { id : 10 },\n    a  : { id : 'a' },\n  })\n})\n\ntest('with string as condition', () => {\n  const list = [ { id : 1 }, { id : 2 }, { id : 10 }, { id : 'a' } ]\n  const standardResult = indexBy(obj => obj.id, list)\n  const suggestionResult = indexBy('id', list)\n\n  expect(standardResult).toEqual(suggestionResult)\n})\n\ntest('with string - bad path', () => {\n  const list = [\n    {\n      a : {\n        b : 1,\n        c : 2,\n      },\n    },\n    { a : { c : 4 } },\n    {},\n    {\n      a : {\n        b : 10,\n        c : 20,\n      },\n    },\n  ]\n\n  const result = indexBy('a.b', list)\n  const expected = {\n    1 : {\n      a : {\n        b : 1,\n        c : 2,\n      },\n    },\n    10 : {\n      a : {\n        b : 10,\n        c : 20,\n      },\n    },\n    undefined : {},\n  }\n\n  expect(result).toEqual(expected)\n})\n"
  },
  "indexOf": {
    "explanation": "It returns `-1` or the index of the first element of `arr` equal of `valueToFind`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('indexOf', function() {\n  var input = [1, 2, 3, 4, 5];\n  var list = [1, 2, 3];\n  list[-2] = 4; // Throw a wrench in the gears by assigning a non-valid array index as object property.\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.indexOf(0, [-0]), -1);\n    eq(R.indexOf(-0, [0]), -1);\n    eq(R.indexOf(NaN, [NaN]), 0);\n    eq(R.indexOf(new Just([42]), [new Just([42])]), 0);\n  });\n  it('dispatches to `indexOf` method', function() {\n    function Empty() {}\n    Empty.prototype.indexOf = R.always(-1);\n    function List(head, tail) {\n      this.head = head;\n      this.tail = tail;\n    }\n    List.prototype.indexOf = function(x) {\n      var idx = this.tail.indexOf(x);\n      return this.head === x ? 0 : idx >= 0 ? 1 + idx : -1;\n    };\n    var list = new List('b',\n      new List('a',\n        new List('n',\n          new List('a',\n            new List('n',\n              new List('a',\n                new Empty()\n              )\n            )\n          )\n        )\n      )\n    );\n    eq(R.indexOf('a', 'banana'), 1);\n    eq(R.indexOf('x', 'banana'), -1);\n    eq(R.indexOf('a', list), 1);\n    eq(R.indexOf('x', list), -1);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "indexOf",
    "example": "R.indexOf(1, [1, 2]) // => 0\nR.indexOf(0, [1, 2]) // => -1",
    "code": "export function indexOf(target, list){\n  if (arguments.length === 1) return _list => indexOf(target, _list)\n\n  let index = -1\n  const { length } = list\n\n  while (++index < length){\n    if (list[ index ] === target){\n      return index\n    }\n  }\n\n  return -1\n}",
    "spec": "import { indexOf } from './indexOf'\n\ntest('indexOf', () => {\n  expect(indexOf(3, [ 1, 2, 3, 4 ])).toEqual(2)\n\n  expect(indexOf(10)([ 1, 2, 3, 4 ])).toEqual(-1)\n})\n"
  },
  "init": {
    "explanation": "- It returns all but the last element of `arrOrStr`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "INIT",
        "date": "2019-11-13T11:27:42.212Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 106420299,
            "margin": 0.93,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 6199923,
            "margin": 1.93,
            "percentSlower": 94.17
          },
          {
            "name": "Lodash",
            "ops": 103619525,
            "margin": 1.93,
            "percentSlower": 2.63
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst list = [ 1, 2, 3, 4 ]\n\nconst init = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.init(list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.init(list)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.initial(list)\n    },\n  },\n]\n\nmodule.exports = init\n"
    },
    "typingSpec": "",
    "methodName": "init",
    "example": "R.init([1, 2, 3])  // => [1, 2]\nR.init('foo')  // => 'fo'",
    "code": "import baseSlice from './internal/baseSlice'\n\nexport function init(list){\n  if (typeof list === 'string') return list.slice(0, -1)\n\n  return list.length ? baseSlice(\n    list, 0, -1\n  ) : []\n}",
    "spec": "import { compose, flatten, tail } from '../rambda'\nimport { init } from './init'\n\ntest('init', () => {\n  expect(compose(\n    tail, init, flatten\n  )([ [ [ 1, [ 2 ] ] ], [ 3, 4 ] ])).toEqual([ 2, 3 ])\n\n  expect(init([ 1, 2, 3 ])).toEqual([ 1, 2 ])\n  expect(init([ 1, 2 ])).toEqual([ 1 ])\n  expect(init([ 1 ])).toEqual([])\n  expect(init([])).toEqual([])\n\n  expect(init([])).toEqual([])\n\n  expect(init([ 1 ])).toEqual([])\n\n  expect(init('foo')).toEqual('fo')\n\n  expect(init('f')).toEqual('')\n\n  expect(init('')).toEqual('')\n})\n"
  },
  "is": {
    "explanation": "It returns `true` is `x` is instance of `xPrototype`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "IS",
        "date": "2019-12-18T21:47:03.410Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 1188634,
            "margin": 7.83,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 665019,
            "margin": 5.19,
            "percentSlower": 44.05
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst is = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.is(Array, undefined)\n      R.is(Array)([])\n      R.is(Boolean, new Boolean(false))\n      R.is(Date, new Date())\n      R.is(Function, () => {})\n      R.is(Number, new Number(0))\n      R.is(Object, {})\n      R.is(RegExp, /(?:)/)\n      R.is(String, new String(''))\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.is(Array, undefined)\n      Ramda.is(Array)([])\n      Ramda.is(Boolean, new Boolean(false))\n      Ramda.is(Date, new Date())\n      Ramda.is(Function, () => {})\n      Ramda.is(Number, new Number(0))\n      Ramda.is(Object, {})\n      Ramda.is(RegExp, /(?:)/)\n      Ramda.is(String, new String(''))\n    },\n  },\n]\n\nmodule.exports = is\n"
    },
    "typingSpec": "",
    "methodName": "is",
    "example": "R.is(String, 'foo')  // => true\nR.is(Array, 1)  // => false",
    "code": "export function is(ctor, val){\n  if (arguments.length === 1) return _val => is(ctor, _val)\n\n  return (\n    val != null && val.constructor === ctor ||\n    val instanceof ctor\n  )\n}",
    "spec": "import { is } from './is'\n\ntest('works with built-in types', () => {\n  expect(is(Array, undefined)).toBeFalse()\n  expect(is(Array)([])).toBeTrue()\n  expect(is(Boolean, new Boolean(false))).toBeTrue()\n  expect(is(Date, new Date())).toBeTrue()\n  expect(is(Function, () => {})).toBeTrue()\n  expect(is(Number, new Number(0))).toBeTrue()\n  expect(is(Object, {})).toBeTrue()\n  expect(is(RegExp, /(?:)/)).toBeTrue()\n  expect(is(String, new String(''))).toBeTrue()\n})\n\ntest('works with user-defined types', () => {\n  function Foo(){}\n  function Bar(){}\n  Bar.prototype = new Foo()\n\n  const foo = new Foo()\n  const bar = new Bar()\n\n  expect(is(Foo, foo)).toBeTrue()\n  expect(is(Bar, bar)).toBeTrue()\n  expect(is(Foo, bar)).toBeTrue()\n  expect(is(Bar, foo)).toBeFalse()\n})\n\ntest('does not coerce', () => {\n  expect(is(Boolean, 1)).toBeFalse()\n  expect(is(Number, '1')).toBeFalse()\n  expect(is(Number, false)).toBeFalse()\n})\n\ntest('recognizes primitives as their object equivalents', () => {\n  expect(is(Boolean, false)).toBeTrue()\n  expect(is(Number, 0)).toBeTrue()\n  expect(is(String, '')).toBeTrue()\n})\n\ntest('does not consider primitives to be instances of Object', () => {\n  expect(is(Object, false)).toBeFalse()\n  expect(is(Object, 0)).toBeFalse()\n  expect(is(Object, '')).toBeFalse()\n})\n"
  },
  "isNil": {
    "explanation": "It returns `true` is `x` is either `null` or `undefined`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "isNil",
    "example": "R.isNil(null)  // => true\nR.isNil(1)  // => false",
    "code": "export function isNil(x){\n  return x === undefined || x === null\n}",
    "spec": "import { isNil } from './isNil'\n\ntest('happy', () => {\n  expect(isNil(null)).toBeTrue()\n\n  expect(isNil(undefined)).toBeTrue()\n\n  expect(isNil([])).toBeFalse()\n})\n"
  },
  "isEmpty": {
    "explanation": "It returns `true` is `x` is `empty`.",
    "ramdaDiff": "var R = require('rambda');\nvar eq = require('./shared/eq');\n\ndescribe('isEmpty', function() {\n  const a = 1\n  it('returns true for empty typed array', function() {\n    eq(R.isEmpty(Uint8Array.from('')), true);\n    eq(R.isEmpty(Float32Array.from('')), true);\n    eq(R.isEmpty(new Float32Array([])), true);\n    eq(R.isEmpty(Uint8Array.from('1')), false);\n    eq(R.isEmpty(Float32Array.from('1')), false);\n    eq(R.isEmpty(new Float32Array([1])), false);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "isEmpty",
    "example": "R.isEmpty('')  // => true\nR.isEmpty({ x : 0 })  // => false",
    "code": "import { type } from './type.js'\n\nexport function isEmpty(input){\n  const inputType = type(input)\n  if ([ 'Undefined', 'NaN', 'Number', 'Null' ].includes(inputType)) return false\n  if (!input) return true\n\n  if (inputType === 'Object'){\n    return Object.keys(input).length === 0\n  }\n\n  if (inputType === 'Array'){\n    return input.length === 0\n  }\n\n  return false\n}",
    "spec": "import { isEmpty } from './isEmpty'\n\ntest('happy', () => {\n  expect(isEmpty(undefined)).toEqual(false)\n  expect(isEmpty('')).toEqual(true)\n  expect(isEmpty(null)).toEqual(false)\n  expect(isEmpty(' ')).toEqual(false)\n  expect(isEmpty(new RegExp(''))).toEqual(false)\n  expect(isEmpty([])).toEqual(true)\n  expect(isEmpty([ [] ])).toEqual(false)\n  expect(isEmpty({})).toEqual(true)\n  expect(isEmpty({ x : 0 })).toEqual(false)\n  expect(isEmpty(0)).toEqual(false)\n  expect(isEmpty(NaN)).toEqual(false)\n  expect(isEmpty([ '' ])).toEqual(false)\n})\n"
  },
  "join": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "join",
    "example": "R.join('-', [1, 2, 3])  // => '1-2-3'",
    "code": "export function join(separator, list){\n  if (arguments.length === 1) return _list => join(separator, _list)\n\n  return list.join(separator)\n}",
    "spec": "import { join } from './join'\n\ntest('curry', () => {\n  expect(join('|')([ 'foo', 'bar', 'baz' ])).toEqual('foo|bar|baz')\n\n  expect(join('|', [ 1, 2, 3 ])).toEqual('1|2|3')\n\n  const spacer = join(' ')\n\n  expect(spacer([ 'a', 2, 3.4 ])).toEqual('a 2 3.4')\n})\n"
  },
  "keys": {
    "explanation": "",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('keys', function() {\n  var obj = {a: 100, b: [1, 2, 3], c: {x: 200, y: 300}, d: 'D', e: null, f: undefined};\n  function C() { this.a = 100; this.b = 200; }\n  C.prototype.x = function() { return 'x'; };\n  C.prototype.y = 'y';\n  var cobj = new C();\n  it('works for primitives', function() {\n    eq(R.keys(null), []);\n    eq(R.keys(undefined), []);\n    eq(R.keys(55), []);\n    eq(R.keys('foo'), []);\n    eq(R.keys(true), []);\n    eq(R.keys(false), []);\n    eq(R.keys(NaN), []);\n    eq(R.keys(Infinity), []);\n    eq(R.keys([]), []);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "keys",
    "example": "R.keys({a:1, b:2})  // => ['a', 'b']",
    "code": "export function keys(obj){\n  return Object.keys(obj)\n}",
    "spec": "import { keys } from './keys.js'\n\ntest('happy', () => {\n  expect(keys({ a : 1 })).toEqual([ 'a' ])\n})\n"
  },
  "last": {
    "explanation": "It returns the last element of `arrOrStr`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "LAST",
        "date": "2019-11-13T11:28:14.846Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 773599809,
            "margin": 1.06,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 7615209,
            "margin": 1.77,
            "percentSlower": 99.02
          },
          {
            "name": "Lodash",
            "ops": 746561110,
            "margin": 0.4,
            "percentSlower": 3.5
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst list = [ 1, 2, 3, 4 ]\n\nconst last = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.last(list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.last(list)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.last(list)\n    },\n  },\n]\n\nmodule.exports = last\n"
    },
    "typingSpec": "",
    "methodName": "last",
    "example": "R.last(['foo', 'bar', 'baz']) // => 'baz'\nR.last('foo') // => 'o'",
    "code": "export function last(list){\n  if (typeof list === 'string') return list[ list.length - 1 ] || ''\n\n  return list[ list.length - 1 ]\n}",
    "spec": "import { last } from './last'\n\ntest('happy', () => {\n  expect(last([ 'foo', 'bar', 'baz' ])).toEqual('baz')\n  expect(last([])).toEqual(undefined)\n  expect(last('abc')).toEqual('c')\n  expect(last('')).toEqual('')\n})\n"
  },
  "lastIndexOf": {
    "explanation": "It returns the last index of `x` in array `arr`.\n\n`R.equals` is used to determine equality between `x` and members of `arr`.\n\nValue `-1` is returned if no `x` is found in `arr`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('lastIndexOf', function() {\n  var input = [1, 2, 3, 4, 5, 1];\n  var list = ['a', 1, 'a'];\n  list[-2] = 'a'; // Throw a wrench in the gears by assigning a non-valid array index as object property.\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.lastIndexOf(0, [-0]), -1);\n    eq(R.lastIndexOf(-0, [0]), -1);\n    eq(R.lastIndexOf(NaN, [NaN]), 0);\n    eq(R.lastIndexOf(new Just([42]), [new Just([42])]), 0);\n  });\n  it('dispatches to `lastIndexOf` method', function() {\n    function Empty() {}\n    Empty.prototype.lastIndexOf = R.always(-1);\n    function List(head, tail) {\n      this.head = head;\n      this.tail = tail;\n    }\n    List.prototype.lastIndexOf = function(x) {\n      var idx = this.tail.lastIndexOf(x);\n      return idx >= 0 ? 1 + idx : this.head === x ? 0 : -1;\n    };\n    var list = new List('b',\n      new List('a',\n        new List('n',\n          new List('a',\n            new List('n',\n              new List('a',\n                new Empty()\n              )\n            )\n          )\n        )\n      )\n    );\n    eq(R.lastIndexOf('a', 'banana'), 5);\n    eq(R.lastIndexOf('x', 'banana'), -1);\n    eq(R.lastIndexOf('a', list), 5);\n    eq(R.lastIndexOf('x', list), -1);\n  });\n  it('finds function, compared by identity', function() {\n    var f = function() {};\n    var g = function() {};\n    var list = [g, f, g, f];\n    eq(R.lastIndexOf(f, list), 3);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "lastIndexOf",
    "example": "R.lastIndexOf(1, [1, 2, 3, 1, 2]) // => 3\nR.lastIndexOf(10, [1, 2, 3, 1, 2]) // => -1",
    "code": "import { equals } from './equals'\n\nexport function lastIndexOf(target, list){\n  if (arguments.length === 1) return _list => lastIndexOf(target, _list)\n\n  let index = list.length\n\n  while (--index > 0){\n    if (equals(list[ index ], target)){\n      return index\n    }\n  }\n\n  return -1\n}",
    "spec": "import { lastIndexOf } from './lastIndexOf'\n\ntest('happy', () => {\n  const a = lastIndexOf(1, [ 1, 2, 3, 1, 2 ])\n  const b = lastIndexOf(1)([ 1, 2, 3, 1, 2 ])\n\n  expect(a).toEqual(3)\n  expect(b).toEqual(3)\n})\n\ntest('false', () => {\n  const a = lastIndexOf(10, [ 1, 2, 3, 1, 2 ])\n\n  expect(a).toEqual(-1)\n})\n"
  },
  "length": {
    "explanation": "",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('length', function() {\n  it('returns NaN for length property of unexpected type', function() {\n    eq(R.identical(NaN, R.length({length: ''})), true);\n    eq(R.identical(NaN, R.length({length: '1.23'})), true);\n    eq(R.identical(NaN, R.length({length: null})), true);\n    eq(R.identical(NaN, R.length({length: undefined})), true);\n    eq(R.identical(NaN, R.length({})), true);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "length",
    "example": "R.length([1, 2, 3]) // => 3",
    "code": "export function length(list){\n  if (!list || list.length === undefined){\n    return NaN\n  }\n\n  return list.length\n}",
    "spec": "import { length } from './length'\n\ntest('happy', () => {\n  expect(length('foo')).toEqual(3)\n  expect(length([ 1, 2, 3 ])).toEqual(3)\n  expect(length([])).toEqual(0)\n})\n\ntest('with bad input returns NaN', () => {\n  expect(length(0)).toBeNaN()\n  expect(length({})).toBeNaN()\n  expect(length(null)).toBeNaN()\n  expect(length(undefined)).toBeNaN()\n})\n"
  },
  "lens": {
    "explanation": "Returns a `lens` for the given `getter` and `setter` functions. \n\nThe `getter` \"gets\" the value of the focus; the `setter` \"sets\" the value of the focus. \n\nThe setter should not mutate the data structure.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "lens",
    "example": "const xLens = R.lens(R.prop('x'), R.assoc('x'));\n\nR.view(xLens, {x: 1, y: 2}) //=> 1\nR.set(xLens, 4, {x: 1, y: 2}) //=> {x: 4, y: 2}\nR.over(xLens, R.negate, {x: 1, y: 2}) //=> {x: -1, y: 2}",
    "code": "import { map } from './map'\n\nexport function lens(getter, setter){\n\n  if (arguments.length === 1)\n    return _setter => lens(getter, _setter)\n\n  return function(functor){\n    return function(target){\n      return functor(getter(target))\n        .map(focus => setter(focus, target))\n    }\n  }\n}",
    "spec": ""
  },
  "lensIndex": {
    "explanation": "Returns a lens that focuses on the specified index",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "lensIndex",
    "example": "const headLens = R.lensIndex(0)\n\nR.view(headLens, ['a', 'b', 'c']) //=> 'a'\nR.set(headLens, 'x', ['a', 'b', 'c']) //=> ['x', 'b', 'c']\nR.over(headLens, R.toUpper, ['a', 'b', 'c']) //=> ['A', 'b', 'c']",
    "code": "import { lens } from './lens'\nimport { nth } from './nth'\nimport { update } from './update'\n\nexport function lensIndex(i){\n  return lens(nth(i), update(i))\n}",
    "spec": "import { compose } from './compose'\nimport { keys } from './keys'\nimport { lensIndex } from './lensIndex'\nimport { over } from './over'\nimport { set } from './set'\nimport { view } from './view'\n\nconst testList = [ { a : 1 }, { b : 2 }, { c : 3 } ]\n\ntest('focuses list element at the specified index', () => {\n  expect(view(lensIndex(0), testList)).toEqual({ a : 1 })\n})\n\ntest('returns undefined if the specified index does not exist', () => {\n  expect(view(lensIndex(10), testList)).toEqual(undefined)\n})\n\ntest('sets the list value at the specified index', () => {\n  expect(set(\n    lensIndex(0), 0, testList\n  )).toEqual([ 0, { b : 2 }, { c : 3 } ])\n})\n\ntest('applies function to the value at the specified list index', () => {\n  expect(over(\n    lensIndex(2), keys, testList\n  )).toEqual([ { a : 1 }, { b : 2 }, [ 'c' ] ])\n})\n\ntest('can be composed', () => {\n  const nestedList = [ 0, [ 10, 11, 12 ], 1, 2 ]\n  const composedLens = compose(lensIndex(1), lensIndex(0))\n\n  expect(view(composedLens, nestedList)).toEqual(10)\n})\n\ntest('set s (get s) === s', () => {\n  expect(set(\n    lensIndex(0), view(lensIndex(0), testList), testList\n  )).toEqual(testList)\n})\n\ntest('get (set s v) === v', () => {\n  expect(view(lensIndex(0), set(\n    lensIndex(0), 0, testList\n  ))).toEqual(0)\n})\n\ntest('get (set(set s v1) v2) === v2', () => {\n  expect(view(lensIndex(0), set(\n    lensIndex(0), 11, set(\n      lensIndex(0), 10, testList\n    )\n  ))).toEqual(11,)\n})\n"
  },
  "lensPath": {
    "explanation": "Returns a lens that focuses on the specified path",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "lensPath",
    "example": "const xHeadYLens = R.lensPath(['x', 0, 'y'])\n\nR.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}) //=> 2\nR.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}) //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}\nR.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}) //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}",
    "code": "import { assocPath } from './assocPath'\nimport { lens } from './lens'\nimport { path } from './path'\n\nexport function lensPath(key){\n  return lens(path(key), assocPath(key))\n}",
    "spec": "import { compose } from './compose'\nimport { identity } from './identity'\nimport { inc } from './inc'\nimport { lensPath } from './lensPath'\nimport { lensProp } from './lensProp'\nimport { over } from './over'\nimport { set } from './set'\nimport { view } from './view'\n\nconst testObj = {\n  a : [ { b : 1 }, { b : 2 } ],\n  d : 3,\n}\n\ntest('view', () => {\n  expect(view(lensPath('d'), testObj)).toEqual(3)\n  expect(view(lensPath('a.0.b'), testObj)).toEqual(1)\n  // this is different to ramda, ramda will return a clone of the input object\n  expect(view(lensPath(''), testObj)).toEqual(undefined)\n})\n\ntest('set', () => {\n  expect(set(\n    lensProp('d'), 0, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 2 } ],\n    d : 0,\n  })\n  expect(set(\n    lensPath('a.0.b'), 0, testObj\n  )).toEqual({\n    a : [ { b : 0 }, { b : 2 } ],\n    d : 3,\n  })\n  expect(set(\n    lensPath('a.0.X'), 0, testObj\n  )).toEqual({\n    a : [ {\n      b : 1,\n      X : 0,\n    }, { b : 2 } ],\n    d : 3,\n  })\n  expect(set(\n    lensPath([]), 0, testObj\n  )).toEqual(0)\n})\n\ntest('over', () => {\n  expect(over(\n    lensPath('d'), inc, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 2 } ],\n    d : 4,\n  })\n  expect(over(\n    lensPath('a.1.b'), inc, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 3 } ],\n    d : 3,\n  })\n  expect(over(\n    lensProp('X'), identity, testObj\n  )).toEqual({\n    a : [ { b : 1 }, { b : 2 } ],\n    d : 3,\n    X : undefined,\n  })\n  expect(over(\n    lensPath('a.0.X'), identity, testObj\n  )).toEqual({\n    a : [ {\n      b : 1,\n      X : undefined,\n    }, { b : 2 } ],\n    d : 3,\n  })\n})\n\ntest('compose', () => {\n  const composedLens = compose(lensPath('a'), lensPath('1.b'))\n  expect(view(composedLens, testObj)).toEqual(2)\n})\n\ntest('set s (get s) === s', () => {\n  expect(set(\n    lensPath([ 'd' ]), view(lensPath([ 'd' ]), testObj), testObj\n  )).toEqual(testObj)\n  expect(set(\n    lensPath([ 'a', 0, 'b' ]), view(lensPath([ 'a', 0, 'b' ]), testObj), testObj\n  )).toEqual(testObj)\n})\n\ntest('get (set s v) === v', () => {\n  expect(view(lensPath([ 'd' ]), set(\n    lensPath([ 'd' ]), 0, testObj\n  ))).toEqual(0)\n  expect(view(lensPath([ 'a', 0, 'b' ]), set(\n    lensPath([ 'a', 0, 'b' ]), 0, testObj\n  ))).toEqual(0)\n})\n\ntest('get (set(set s v1) v2) === v2', () => {\n  const p = [ 'd' ]\n  const q = [ 'a', 0, 'b' ]\n  expect(view(lensPath(p), set(\n    lensPath(p), 11, set(\n      lensPath(p), 10, testObj\n    )\n  ))).toEqual(11)\n  expect(view(lensPath(q), set(\n    lensPath(q), 11, set(\n      lensPath(q), 10, testObj\n    )\n  ))).toEqual(11)\n})\n"
  },
  "lensProp": {
    "explanation": "Returns a lens that focuses on the specified property",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "lensProp",
    "example": "const xLens = R.lensProp('x');\n\nR.view(xLens, {x: 1, y: 2}) //=> 1\nR.set(xLens, 4, {x: 1, y: 2}) //=> {x: 4, y: 2}\nR.over(xLens, R.negate, {x: 1, y: 2}) //=> {x: -1, y: 2}",
    "code": "import { assoc } from './assoc'\nimport { lens } from './lens'\nimport { prop } from './prop'\n\nexport function lensProp(key){\n  return lens(prop(key), assoc(key))\n}",
    "spec": "import { compose } from './compose'\nimport { identity } from './identity'\nimport { inc } from './inc'\nimport { lensProp } from './lensProp'\nimport { over } from './over'\nimport { set } from './set'\nimport { view } from './view'\n\nconst testObj = {\n  a : 1,\n  b : 2,\n  c : 3,\n}\n\ntest('focuses object the specified object property', () => {\n  expect(view(lensProp('a'), testObj)).toEqual(1)\n})\n\ntest('returns undefined if the specified property does not exist', () => {\n  expect(view(lensProp('X'), testObj)).toEqual(undefined)\n})\n\ntest('sets the value of the object property specified', () => {\n  expect(set(\n    lensProp('a'), 0, testObj\n  )).toEqual({\n    a : 0,\n    b : 2,\n    c : 3,\n  })\n})\n\ntest('adds the property to the object if it doesn\\'t exist', () => {\n  expect(set(\n    lensProp('d'), 4, testObj\n  )).toEqual({\n    a : 1,\n    b : 2,\n    c : 3,\n    d : 4,\n  })\n})\n\ntest('applies function to the value of the specified object property', () => {\n  expect(over(\n    lensProp('a'), inc, testObj\n  )).toEqual({\n    a : 2,\n    b : 2,\n    c : 3,\n  })\n})\n\ntest('applies function to undefined and adds the property if it doesn\\'t exist', () => {\n  expect(over(\n    lensProp('X'), identity, testObj\n  )).toEqual({\n    a : 1,\n    b : 2,\n    c : 3,\n    X : undefined,\n  })\n})\n\ntest('can be composed', () => {\n  const nestedObj = {\n    a : { b : 1 },\n    c : 2,\n  }\n  const composedLens = compose(lensProp('a'), lensProp('b'))\n\n  expect(view(composedLens, nestedObj)).toEqual(1)\n})\n\ntest('set s (get s) === s', () => {\n  expect(set(\n    lensProp('a'), view(lensProp('a'), testObj), testObj\n  )).toEqual(testObj)\n})\n\ntest('get (set s v) === v', () => {\n  expect(view(lensProp('a'), set(\n    lensProp('a'), 0, testObj\n  ))).toEqual(0)\n})\n\ntest('get (set(set s v1) v2) === v2', () => {\n  expect(view(lensProp('a'), set(\n    lensProp('a'), 11, set(\n      lensProp('a'), 10, testObj\n    )\n  ))).toEqual(11,)\n})\n"
  },
  "map": {
    "explanation": "It returns the result of looping through iterable `x` with `mapFn`.\n\nThe method works with objects as well.\n\nNote that unlike Ramda's `map`, here array keys are passed as second argument to `mapFn`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "MAP",
        "date": "2019-11-13T11:28:31.029Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 96274997,
            "margin": 1.15,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 11824628,
            "margin": 2.47,
            "percentSlower": 87.72
          },
          {
            "name": "Lodash",
            "ops": 73562763,
            "margin": 1.82,
            "percentSlower": 23.59
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst arr = [ 1, 2, 3, 4 ]\nconst fn = x => x * 2\nconst map = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.map(fn, arr)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.map(fn, arr)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.map(arr, fn)\n    },\n  },\n]\n\nmodule.exports = map\n"
    },
    "typingSpec": "import { map } from 'rambda'\n\ndescribe('map with arrays', () => {\n  it('only one type', () => {\n    const x = map<number>((a,b) => { // $ExpectType number[]\n      a // $ExpectType number\n      b // $ExpectType number\n      return a + 2\n    },[1,2,3]);\n    x // $ExpectType number[]\n  });\n  it('only one type + curry', () => {\n    const x = map<number>((a,b) => { // $ExpectType number[]\n      a // $ExpectType number\n      b // $ExpectType number\n      return a + 2\n    })([1,2,3]);\n    x // $ExpectType number[]\n  });\n  it('2 types', () => {\n    const x = map<number, string>((a,b) => { // $ExpectType string[]\n      a // $ExpectType number\n      b // $ExpectType number\n      return `${a}`\n    },[1,2,3]);\n    x // $ExpectType string[]\n  });\n  it('2 types + curry', () => {\n    const x = map<number, string>((a,b) => { // $ExpectType string[]\n      a // $ExpectType number\n      b // $ExpectType number\n      return `${a}`\n    })([1,2,3]);\n    x // $ExpectType string[]\n  });\n});\n\ndescribe('map with objects', () => {\n  it('curry', () => {\n    // It requires dummy third typing argument\n    // in order to distinguish compared to curry typings for arrays\n    // ============================================\n    const x = map<number, string, any>((a,b,c) => { // $ExpectType Dictionary<string>\n      a // $ExpectType number\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n      return `${a}`\n    })({a:1,b:2});\n    x // $ExpectType Dictionary<string>\n  });\n  it('1', () => {\n    const x = map<number, string>((a,b,c) => { // $ExpectType Dictionary<string>\n      a // $ExpectType number\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n      return `${a}`\n    },{a:1,b:2});\n    x // $ExpectType Dictionary<string>\n  });\n  it('2', () => {\n    const x = map<number, string>((a,b) => { // $ExpectType Dictionary<string>\n      a // $ExpectType number\n      b // $ExpectType string\n      return `${a}`\n    },{a:1,b:2});\n    x // $ExpectType Dictionary<string>\n  });\n  it('3', () => {\n    const x = map<number, string>((a) => { // $ExpectType Dictionary<string>\n      a // $ExpectType number\n      return `${a}`\n    },{a:1,b:2});\n    x // $ExpectType Dictionary<string>\n  });\n});\n",
    "methodName": "map",
    "example": "const mapFn = x => x * 2\nconst resultWithArray = R.map(mapFn, [1, 2, 3])\n// => [2, 4, 6]\n\nconst result = R.map((val, prop)=>{\n  return `${prop}-${val}`\n}, {a: 1, b: 2})\n// => {a: 'a-1', b: 'b-2'}",
    "code": "function mapObject(fn, obj){\n  const willReturn = {}\n\n  for (const prop in obj){\n    willReturn[ prop ] = fn(\n      obj[ prop ], prop, obj\n    )\n  }\n\n  return willReturn\n}\n\nexport function map(fn, list){\n  if (arguments.length === 1) return _list => map(fn, _list)\n\n  if (list === undefined){\n    return []\n  }\n  if (!Array.isArray(list)){\n    return mapObject(fn, list)\n  }\n\n  let index = -1\n  const len = list.length\n  const willReturn = Array(len)\n\n  while (++index < len){\n    willReturn[ index ] = fn(list[ index ], index)\n  }\n\n  return willReturn\n}",
    "spec": "import { add, compose } from '../rambda'\nimport { map } from './map'\n\nconst double = x => x * 2\n\nconst sampleObject = {\n  a : 1,\n  b : 2,\n  c : 3,\n  d : 4,\n}\n\ntest('with array', () => {\n  expect(map(double, [ 1, 2, 3 ])).toEqual([ 2, 4, 6 ])\n})\n\ntest('pass index as second argument', () => {\n  let counter = 0\n  map((x, i) => {\n    expect(i).toBe(counter)\n    counter++\n  },\n  [ 10, 20, 30 ])\n})\n\ntest('with object', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n  }\n\n  expect(map(double, obj)).toEqual({\n    a : 2,\n    b : 4,\n  })\n})\n\ntest('pass input object as third argument', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n  }\n  const iterator = (\n    val, prop, inputObject\n  ) => {\n    expect(inputObject).toEqual(obj)\n\n    return val * 2\n  }\n  expect(map(iterator, obj)).toEqual({\n    a : 2,\n    b : 4,\n  })\n})\n\ntest('with object passes property as second argument', () => {\n  map((_, prop) => {\n    expect(typeof prop).toEqual('string')\n  })(sampleObject)\n})\n\ntest('map with index example', () => {\n  const mappedWithIndex = (fn, obj) => {\n    let counter = -1\n\n    return map((...inputs) => {\n      counter++\n\n      return fn(...inputs, counter)\n    }, obj)\n  }\n  const fn = (\n    x, prop, obj, index\n  ) => {\n    expect(index).toBeNumber()\n\n    return x + 1\n  }\n  const result = mappedWithIndex(fn, {\n    a : 1,\n    b : 2,\n  })\n  expect(result).toEqual({\n    a : 2,\n    b : 3,\n  })\n})\n\n/**\n * https://github.com/selfrefactor/rambda/issues/77\n */\ntest('when undefined instead of array', () => {\n  expect(map(double, undefined)).toEqual([])\n})\n\ntest('with R.compose', () => {\n  const result = compose(map(add(1)), map(add(1)))([ 1, 2, 3 ])\n  expect(result).toEqual([ 3, 4, 5 ])\n})\n"
  },
  "match": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "MATCH",
        "date": "2019-11-13T11:28:41.848Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 4516091,
            "margin": 1.3,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 2167381,
            "margin": 1.39,
            "percentSlower": 52.01
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst match = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.match(/a./g)('foo bar baz')\n      R.match(/a./g, 'foo bar baz')\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.match(/a./g)('foo bar baz')\n      Ramda.match(/a./g, 'foo bar baz')\n    },\n  },\n]\n\nmodule.exports = match\n"
    },
    "typingSpec": "",
    "methodName": "match",
    "example": "R.match(/([a-z]a)/g, 'bananas') // => ['ba', 'na', 'na']",
    "code": "export function match(pattern, str){\n  if (arguments.length === 1) return _str => match(pattern, _str)\n\n  const willReturn = str.match(pattern)\n\n  return willReturn === null ? [] : willReturn\n}",
    "spec": "import { match } from './match'\n\ntest('happy', () => {\n  expect(match(/a./g)('foo bar baz')).toEqual([ 'ar', 'az' ])\n\n  expect(match(/a./g)('foo')).toEqual([])\n\n  expect(() => {\n    match(/a./g, null)\n  }).toThrowWithMessage(TypeError, 'Cannot read property \\'match\\' of null')\n})\n"
  },
  "max": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "max",
    "example": "R.max(5,7) // => 7",
    "code": "export function max(a, b){\n  if (arguments.length === 1) return _b => max(a, _b)\n\n  return b > a ? b : a\n}",
    "spec": "import { max } from './max'\n\ntest('max', () => {\n  expect(max(2, 1)).toBe(2)\n})\n"
  },
  "maxBy": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "maxBy",
    "example": "R.maxBy(Math.abs, 5, -7) // => -7",
    "code": "export function maxBy(\n  fn, a, b\n){\n  if (arguments.length === 2){\n    return _b => maxBy(\n      fn, a, _b\n    )\n  } else if (arguments.length === 1){\n    return (_a, _b) => maxBy(\n      fn, _a, _b\n    )\n  }\n\n  return fn(b) > fn(a) ? b : a\n}",
    "spec": "import { maxBy } from './maxBy'\n\ntest('1', () => {\n  expect(maxBy(\n    Math.round, 0.66, 0.77\n  )).toEqual(0.66)\n})\n\ntest('2', () => {\n  expect(maxBy(\n    Math.round, 0.77, 0.66\n  )).toEqual(0.77)\n})\n\ntest('3', () => {\n  expect(maxBy(Math.round)(0.77, 0.66)).toEqual(0.77)\n})\n\ntest('4', () => {\n  expect(maxBy(Math.round, 0.77)(0.66)).toEqual(0.77)\n})\n\ntest('5', () => {\n  expect(maxBy(\n    x => x === 1 ? -1 : 1, 1, 0.66\n  )).toEqual(0.66)\n})\n"
  },
  "merge": {
    "explanation": "It returns result of `Object.assign({}, a, b)`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "MERGE",
        "date": "2019-11-13T11:28:58.222Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 16739995,
            "margin": 1.49,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 11828189,
            "margin": 1.07,
            "percentSlower": 29.34
          },
          {
            "name": "Lodash",
            "ops": 5413801,
            "margin": 0.94,
            "percentSlower": 67.66
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Lodash",
          "index": 2
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst obj = { bar : 'yes' }\nconst a = {\n  foo : 'bar',\n  bar : 'baz',\n}\nconst merge = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.merge(a, obj)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.merge(a, obj)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.merge(a, obj)\n    },\n  },\n]\n\nmodule.exports = merge\n"
    },
    "typingSpec": "",
    "methodName": "merge",
    "example": "R.merge({ 'foo': 0, 'bar': 1 }, { 'foo': 7 })\n// => { 'foo': 7, 'bar': 1 }",
    "code": "export function merge(obj, props){\n  if (arguments.length === 1) return _props => merge(obj, _props)\n\n  return Object.assign(\n    {}, obj || {}, props || {}\n  )\n}",
    "spec": "import { merge } from './merge'\n\nconst sample = {\n  foo : 'bar',\n  bar : 'bar',\n}\n\ntest('merge', () => {\n  expect(merge(sample)({ bar : 'baz' })).toEqual({\n    foo : 'bar',\n    bar : 'baz',\n  })\n})\n\n/**\n * https://github.com/selfrefactor/rambda/issues/77\n */\ntest('when undefined or null instead of object', () => {\n  expect(merge(null, undefined)).toEqual({})\n  expect(merge(sample, null)).toEqual(sample)\n  expect(merge(sample, undefined)).toEqual(sample)\n  expect(merge(undefined, sample)).toEqual(sample)\n})\n"
  },
  "min": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "min",
    "example": "R.min(5,7) // => 5",
    "code": "export function min(a, b){\n  if (arguments.length === 1) return _b => min(a, _b)\n\n  return b < a ? b : a\n}",
    "spec": "import { min } from './min'\n\ntest('happy', () => {\n  expect(min(2, 1)).toBe(1)\n  expect(min(2)(1)).toBe(1)\n})\n"
  },
  "minBy": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "minBy",
    "example": "R.minBy(Math.abs, -5, -7) // => -5",
    "code": "export function minBy(\n  fn, a, b\n){\n  if (arguments.length === 2){\n    return _b => minBy(\n      fn, a, _b\n    )\n  } else if (arguments.length === 1){\n    return (_a, _b) => minBy(\n      fn, _a, _b\n    )\n  }\n\n  return fn(b) < fn(a) ? b : a\n}",
    "spec": "import { minBy } from './minBy'\n\ntest('1', () => {\n  expect(minBy(\n    Math.round, 0.66, 0.77\n  )).toEqual(0.66)\n})\n\ntest('2', () => {\n  expect(minBy(\n    Math.round, 0.77, 0.66\n  )).toEqual(0.77)\n})\n\ntest('3', () => {\n  expect(minBy(Math.round)(0.77, 0.66)).toEqual(0.77)\n})\n\ntest('4', () => {\n  expect(minBy(Math.round, 0.77)(0.66)).toEqual(0.77)\n})\n\ntest('5', () => {\n  expect(minBy(\n    x => x === 1 ? -1 : 1, 1, 0.66\n  )).toEqual(1)\n})\n"
  },
  "modulo": {
    "explanation": "It returns the remainder of operation `a/b`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "modulo",
    "example": "R.module(14, 3) // => 2",
    "code": "export function modulo(a, b){\n  if (arguments.length === 1) return _b => modulo(a, _b)\n\n  return a % b\n}",
    "spec": "import { modulo } from './modulo'\n\ntest('happy', () => {\n  expect(modulo(17, 3)).toEqual(2)\n  expect(modulo(15)(6)).toEqual(3)\n})\n"
  },
  "multiply": {
    "explanation": "It returns the result of operation `a*b`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "multiply",
    "example": "R.multiply(4, 3) // => 12",
    "code": "export function multiply(a, b){\n  if (arguments.length === 1) return _b => multiply(a, _b)\n\n  return a * b\n}",
    "spec": "import { multiply } from './multiply'\n\ntest('happy', () => {\n  expect(multiply(2, 4)).toEqual(8)\n  expect(multiply(2)(4)).toEqual(8)\n})\n"
  },
  "not": {
    "explanation": "It returns inverted boolean version of input `x`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "not",
    "example": "R.not(true) //=> false\nR.not(false) //=> true\nR.not(0) //=> true\nR.not(1) //=> false",
    "code": "export function not(a){\n  return !a\n}",
    "spec": "import { not } from './not'\n\ntest('not', () => {\n  expect(not(false)).toEqual(true)\n  expect(not(true)).toEqual(false)\n  expect(not(0)).toEqual(true)\n  expect(not(1)).toEqual(false)\n})\n"
  },
  "omit": {
    "explanation": "It returns a partial copy of an `obj` with omitting `propsToOmit`",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "OMIT",
        "date": "2019-11-13T11:29:14.964Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 34422692,
            "margin": 0.98,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 9317817,
            "margin": 1.24,
            "percentSlower": 72.93
          },
          {
            "name": "Lodash",
            "ops": 697871,
            "margin": 2.67,
            "percentSlower": 97.97
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Lodash",
          "index": 2
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst obj = {\n  a : 'foo',\n  b : 'bar',\n  c : 'baz',\n}\nconst toOmit = [ 'a', 'c' ]\nconst omit = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.omit(toOmit, obj)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.omit(toOmit, obj)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.omit(obj, toOmit)\n    },\n  },\n]\n\nmodule.exports = omit\n"
    },
    "typingSpec": "import { omit } from 'rambda'\n\ndescribe('omit with string as props input', () => {\n  it('one type', () => {\n    const x = omit<number>('a,c', {a:1,b:2,c:3,d:4}); // $ExpectType Dictionary<number>\n    x // $ExpectType Dictionary<number>\n    const y = omit<number>('a,c')({a:1,b:2,c:3,d:4}); // $ExpectType Dictionary<number>\n    y // $ExpectType Dictionary<number>\n  });\n  it('two types', () => {\n    interface Output{\n      b: string\n      d: number\n    }\n\n    const x = omit<string|number, Output>('a,c', {a:1,b:'2',c:3,d:4}); // $ExpectType Output\n    x.b // $ExpectType string\n    const y = omit<string|number, Output>('a,c')({a:1,b:'2',c:3,d:4}); // $ExpectType Output\n    y.d // $ExpectType number\n  });\n\n  it('infered input type', () => {\n    const x = omit('a,c', {a:1,b:2,c:3,d:4}); // $ExpectType Dictionary<number>\n    x // $ExpectType Dictionary<number>\n    const y = omit('a,c', {a:1,b:'1',c:3,d:4}); // $ExpectType Dictionary<string | number>\n    y // $ExpectType Dictionary<string | number>\n    const q = omit('a,c')({a:1,b:1,c:3,d:4}); // $ExpectType Dictionary<unknown>\n    q // $ExpectType Dictionary<unknown>\n  });\n});\n\ndescribe('omit with array as props input', () => {\n  it('one type', () => {\n    const x = omit<number>(['a,c'], {a:1,b:2,c:3,d:4}); // $ExpectType Dictionary<number>\n    x // $ExpectType Dictionary<number>\n    const y = omit<number>(['a,c'])({a:1,b:2,c:3,d:4}); // $ExpectType Dictionary<number>\n    y // $ExpectType Dictionary<number>\n  });\n});\n",
    "methodName": "omit",
    "example": "R.omit('a,c,d', {a: 1, b: 2, c: 3}) // => {b: 2}",
    "code": "export function omit(keys, obj){\n  if (arguments.length === 1) return _obj => omit(keys, _obj)\n\n  if (obj === null || obj === undefined){\n    return undefined\n  }\n\n  const keysValue =\n    typeof keys === 'string' ? keys.split(',') : keys\n\n  const willReturn = {}\n\n  for (const key in obj){\n    if (!keysValue.includes(key)){\n      willReturn[ key ] = obj[ key ]\n    }\n  }\n\n  return willReturn\n}",
    "spec": "import { omit } from './omit'\n\ntest('with string as condition', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n  const result = omit('a,c', obj)\n  const resultCurry = omit('a,c')(obj)\n  const expectedResult = { b : 2 }\n\n  expect(result).toEqual(expectedResult)\n  expect(resultCurry).toEqual(expectedResult)\n})\n\ntest('with null', () => {\n  expect(omit('a,b', null)).toEqual(undefined)\n})\n\ntest('doesn\\'t work with number as property', () => {\n  expect(omit([ 42 ], {\n    a  : 1,\n    42 : 2,\n  })).toEqual({\n    42 : 2,\n    a  : 1,\n  })\n})\n\ntest('happy', () => {\n  expect(omit([ 'a', 'c' ])({\n    a : 'foo',\n    b : 'bar',\n    c : 'baz',\n  })).toEqual({ b : 'bar' })\n})\n"
  },
  "over": {
    "explanation": "Returns a copied `Object` or `Array` with the modified value resulting from the function applying to the lenses focus.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "OVER",
        "date": "2020-02-16T11:21:32.628Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 1401771,
            "margin": 1.58,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 613179,
            "margin": 2.69,
            "percentSlower": 56.26
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst testObj = { a: 1 }\n\nconst last = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.over(R.lensProp('a'), R.inc, testObj)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.over(Ramda.lensProp('a'), Ramda.inc, testObj)\n    },\n  },\n]\n\nmodule.exports = last\n"
    },
    "typingSpec": "",
    "methodName": "over",
    "example": "const headLens = R.lensIndex(0)\n \nR.over(headLens, R.toUpper, ['foo', 'bar', 'baz']) //=> ['FOO', 'bar', 'baz']",
    "code": "const Identity = x => ({\n  x,\n  map : fn => Identity(fn(x)),\n})\n\nexport function over(\n  lens, fn, object\n){\n  if (arguments.length === 1)\n    return (_fn, _object) => over(\n      lens, _fn, _object\n    )\n  if (arguments.length === 2)\n    return _object => over(\n      lens, fn, _object\n    )\n\n  return lens(x => Identity(fn(x)))(object).x\n}",
    "spec": ""
  },
  "path": {
    "explanation": "If `pathToSearch` is `'a.b'` then it will return `1` if `obj` is `{a:{b:1}}`.\n\nIt will return `undefined`, if such path is not found.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('path', function() {\n  var deepObject = {a: {b: {c: 'c'}}, falseVal: false, nullVal: null, undefinedVal: undefined, arrayVal: ['arr']};\n  it('takes a path that contains negative indices into arrays', function() {\n    eq(R.path(['x', -2], {x: ['a', 'b', 'c', 'd']}), 'c');\n    eq(R.path([-1, 'y'], [{x: 1, y: 99}, {x: 2, y: 98}, {x: 3, y: 97}]), 97);\n  });\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "PATH",
        "date": "2019-11-13T11:29:31.554Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 47917103,
            "margin": 0.95,
            "percentSlower": 0.34
          },
          {
            "name": "Ramda",
            "ops": 22710828,
            "margin": 2.5,
            "percentSlower": 52.76
          },
          {
            "name": "Lodash",
            "ops": 48079429,
            "margin": 0.86,
            "percentSlower": 0
          }
        ],
        "fastest": {
          "name": "Lodash",
          "index": 2
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\nconst obj = { a : { b : 2 } }\nconst pathInput = [ 'a', 'b' ]\n\nconst path = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.path(pathInput, obj)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.path(pathInput, obj)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.get(obj, pathInput)\n    },\n  },\n]\n\nmodule.exports = path\n"
    },
    "typingSpec": "import { path } from 'rambda'\n\ninterface Input{\n  a: number\n  b: {\n    c: boolean\n  }\n}\n\ndescribe('path', () => {\n  it('without specified input type', () => {\n    const input = { a: 1, b: { c: true } }\n    const result = path<boolean>('a.b.c', input)\n    const resultCurried = path<boolean>('a.b.c')(input)\n    result // $ExpectType boolean | undefined\n    resultCurried // $ExpectType boolean | undefined\n  });\n\n  it('without specified output type', () => {\n    const input = { a: 1, b: { c: true } }\n    const result = path('a.b.c', input)\n    result // $ExpectType unknown\n  });\n\n  it('with string as path', () => {\n    const input: Input = { a: 1, b: { c: true } }\n    const resultA = path<boolean>('a.b.c', input)\n    const resultB = path<boolean>('a.b.c')(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  });\n  it('with array as path', () => {\n    const input: Input = { a: 1, b: { c: true } }\n    const resultA = path<boolean>(['a','b','c'], input)\n    const resultB = path<boolean>(['a','b','c'])(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  });\n});\n\ndescribe('path with specified input', () => {\n  it('with string as path', () => {\n    const input: Input = { a: 1, b: { c: true } }\n    // const wrongInput = { a: 1, b: true }\n    // const resultA = path<Input, boolean>('a.b.c', wrongInput)\n    const resultA = path<Input, boolean>('a.b.c', input)\n    const resultB = path<Input, boolean>('a.b.c')(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  });\n  it('with array as path', () => {\n    const input: Input = { a: 1, b: { c: true } }\n    const resultA = path<Input, boolean>(['a','b','c'], input)\n    const resultB = path<Input, boolean>(['a','b','c'])(input)\n    resultA // $ExpectType boolean | undefined\n    resultB // $ExpectType boolean | undefined\n  });\n});\n",
    "methodName": "path",
    "example": "R.path('a.b', {a: {b: 1}}) // => 1",
    "code": "export function path(list, obj){\n  if (arguments.length === 1) return _obj => path(list, _obj)\n\n  if (obj === null || obj === undefined){\n    return undefined\n  }\n  let willReturn = obj\n  let counter = 0\n\n  const pathArrValue = typeof list === 'string' ? list.split('.') : list\n\n  while (counter < pathArrValue.length){\n    if (willReturn === null || willReturn === undefined){\n      return undefined\n    }\n    willReturn = willReturn[ pathArrValue[ counter ] ]\n    counter++\n  }\n\n  return willReturn\n}",
    "spec": "import { path } from './path'\n\ntest('with array inside object', () => {\n  const obj = { a : { b : [ 1, { c : 1 } ] } }\n\n  expect(path('a.b.1.c', obj)).toBe(1)\n})\n\ntest('works with undefined', () => {\n  const obj = { a : { b : { c : 1 } } }\n\n  expect(path('a.b.c.d.f', obj)).toBeUndefined()\n  expect(path('foo.babaz', undefined)).toBeUndefined()\n  expect(path('foo.babaz')(undefined)).toBeUndefined()\n})\n\ntest('works with string instead of array', () => {\n  expect(path('foo.bar.baz')({ foo : { bar : { baz : 'yes' } } })).toEqual('yes')\n})\n\ntest('path', () => {\n  expect(path([ 'foo', 'bar', 'baz' ])({ foo : { bar : { baz : 'yes' } } })).toEqual('yes')\n\n  expect(path([ 'foo', 'bar', 'baz' ])(null)).toBeUndefined()\n\n  expect(path([ 'foo', 'bar', 'baz' ])({ foo : { bar : 'baz' } })).toBeUndefined()\n})\n"
  },
  "paths": {
    "explanation": "Similar to `R.path`, but for multiple object's path queries.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { paths } from 'rambda'\n\ninterface Input{\n  a: number,\n  b: number,\n  c: number,\n}\n\nconst input: Input = { a: 1, b: 2, c: 3 }\n\ndescribe('paths', () => {\n  it('with dot notation', () => {\n    const result = paths<number>(['a.b.c', 'foo.bar'], input)\n    result // $ExpectType (number | undefined)[]\n  });\n\n  it('without type', () => {\n    const result = paths(['a.b.c', 'foo.bar'], input)\n    result // $ExpectType unknown[]\n  });\n\n  it('with array as path', () => {\n    const result = paths<number>([['a','b','c'], ['foo.bar']], input)\n    result // $ExpectType (number | undefined)[]\n  });\n  \n  it('with curry', () => {\n    const result = paths<number>([['a','b','c'], ['foo.bar']])(input)\n    result // $ExpectType (number | undefined)[]\n  });\n});\n",
    "methodName": "paths",
    "example": "const obj = {\n  foo: {\n    bar: [10,20],\n    baz: '123'\n  },\n  a: 90\n}\nR.paths(['a.b', 'foo.bar.1', 'foo.baz'])\n// => [ undefined, 20, 90]",
    "code": "import { path } from './path'\n\nexport function paths(pathsInput, obj){\n  return pathsInput.map(singlePath => path(singlePath, obj))\n}",
    "spec": "import { paths } from './paths'\n\nconst obj = {\n  a : {\n    b : {\n      c : 1,\n      d : 2,\n    },\n  },\n  p : [ { q : 3 }, 'Hi' ],\n  x : {\n    y : 'Alice',\n    z : [ [ {} ] ],\n  },\n}\n\ntest('with string path', () => {\n  const result = paths([\n    'a.b.d',\n    'p.q',\n  ],\n  obj)\n\n  expect(result).toEqual([ 2, undefined ])\n})\n\ntest('with array path', () => {\n  const result = paths([\n    [ 'a', 'b', 'c' ],\n    [ 'x', 'y' ],\n  ],\n  obj)\n\n  expect(result).toEqual([ 1, 'Alice' ])\n\n})\n\ntest('takes a paths that contains indices into arrays', () => {\n  expect(paths([\n    [ 'p', 0, 'q' ],\n    [ 'x', 'z', 0, 0 ],\n  ],\n  obj)).toEqual([ 3, {} ])\n  expect(paths([\n    [ 'p', 0, 'q' ],\n    [ 'x', 'z', 2, 1 ],\n  ],\n  obj)).toEqual([ 3, undefined ])\n})\n\ntest('gets a deep property\\'s value from objects', () => {\n  expect(paths([ [ 'a', 'b' ] ], obj)).toEqual([ obj.a.b ])\n  expect(paths([ [ 'p', 0 ] ], obj)).toEqual([ obj.p[ 0 ] ])\n})\n\ntest('returns undefined for items not found', () => {\n  expect(paths([ [ 'a', 'x', 'y' ] ], obj)).toEqual([ undefined ])\n  expect(paths([ [ 'p', 2 ] ], obj)).toEqual([ undefined ])\n})\n"
  },
  "pathOr": {
    "explanation": "`pathFound` is the result of calling `R.path(pathToSearch, obj)`.\n\nIf `pathFound` is `undefined`, `null` or `NaN`, then `defaultValue` will be returned.\n\n`pathFound` is returned in any other case.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "pathOr",
    "example": "R.pathOr(1, 'a.b', {a: {b: 2}}) // => 2\nR.pathOr(1, ['a', 'b'], {a: {b: 2}}) // => 2\nR.pathOr(1, ['a', 'c'], {a: {b: 2}}) // => 1",
    "code": "import { curry } from './curry'\nimport { defaultTo } from './defaultTo'\nimport { path } from './path'\n\nfunction pathOrRaw(\n  defaultValue, list, obj\n){\n  return defaultTo(defaultValue,\n    path(list, obj))\n}\n\nexport const pathOr = curry(pathOrRaw)",
    "spec": "import { pathOr } from './pathOr'\n\ntest('with undefined', () => {\n  const result = pathOr(\n    'foo', 'x.y', { x : { y : 1 } }\n  )\n\n  expect(result).toEqual(1)\n})\n\ntest('with null', () => {\n  const result = pathOr(\n    'foo', 'x.y', null\n  )\n\n  expect(result).toEqual('foo')\n})\n\ntest('with NaN', () => {\n  const result = pathOr(\n    'foo', 'x.y', NaN\n  )\n\n  expect(result).toEqual('foo')\n})\n\ntest('curry case (x)(y)(z)', () => {\n  const result = pathOr('foo')('x.y.z')({ x : { y : { a : 1 } } })\n\n  expect(result).toEqual('foo')\n})\n\ntest('curry case (x)(y,z)', () => {\n  const result = pathOr('foo', 'x.y.z')({ x : { y : { a : 1 } } })\n\n  expect(result).toEqual('foo')\n})\n\ntest('curry case (x,y)(z)', () => {\n  const result = pathOr('foo')('x.y.z', { x : { y : { a : 1 } } })\n\n  expect(result).toEqual('foo')\n})\n"
  },
  "partial": {
    "explanation": "It is very similar to `R.curry`, but you can pass initial arguments when you create the curried function.\n\n`R.partial` will keep returning a function until all the arguments that the function `fn` expects are passed.\nThe name comes from the fact that you partially inject the inputs.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('partial', function() {\n  var disc = function(a, b, c) { // note disc(3, 7, 4) => 1\n    return b * b - 4 * a * c;\n  };\n  it('caches the initially supplied arguments', function() {\n    var f = R.partial(disc, [3]);\n    eq(f(7, 4), 1);\n    var g = R.partial(disc, [3, 7]);\n    eq(g(4), 1);\n  });\n  it('correctly reports the arity of the new function', function() {\n    var f = R.partial(disc, [3]);\n    eq(f.length, 2);\n    var g = R.partial(disc, [3, 7]);\n    eq(g.length, 1);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "partial",
    "example": "const fn = (salutation, title, firstName, lastName) => salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!'\n\nconst canPassAnyNumberOfArguments = partial(fn, 'Hello', 'Ms.')\nconst finalFn = canPassAnyNumberOfArguments('foo')\n\nfinalFn('bar') // =>  'Hello, Ms. foo bar!'",
    "code": "export function partial(fn, ...args){\n  const len = fn.length\n\n  return (...rest) => {\n    if (args.length + rest.length >= len){\n      return fn(...args, ...rest)\n    }\n\n    return partial(fn, ...[ ...args, ...rest ])\n  }\n}",
    "spec": "import { partial } from './partial'\nimport { type } from './type'\n\nconst greet = (\n  salutation, title, firstName, lastName\n) => salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!'\n\ntest('happy', () => {\n  const canPassAnyNumberOfArguments = partial(\n    greet, 'Hello', 'Ms.'\n  )\n  const fn = canPassAnyNumberOfArguments('foo')\n\n  expect(type(fn)).toBe('Function')\n\n  expect(fn('bar')).toBe('Hello, Ms. foo bar!')\n})\n\ntest('extra arguments are ignored', () => {\n  const canPassAnyNumberOfArguments = partial(\n    greet, 'Hello', 'Ms.'\n  )\n  const fn = canPassAnyNumberOfArguments('foo')\n\n  expect(type(fn)).toBe('Function')\n\n  expect(fn(\n    'bar', 1, 2\n  )).toBe('Hello, Ms. foo bar!')\n})\n\ntest('when array is input', () => {\n  const fooFn = (\n    a, b, c, d\n  ) => ({\n    a,\n    b,\n    c,\n    d,\n  })\n  const barFn = partial(\n    fooFn, [ 1, 2 ], []\n  )\n\n  expect(barFn(1, 2)).toEqual({\n    a : [ 1, 2 ],\n    b : [],\n    c : 1,\n    d : 2,\n  })\n})\n\ntest('ramda spec', () => {\n  const sayHello = partial(greet, 'Hello')\n  const sayHelloToMs = partial(sayHello, 'Ms.')\n\n  expect(sayHelloToMs('Jane', 'Jones')).toBe('Hello, Ms. Jane Jones!')\n})\n"
  },
  "pick": {
    "explanation": "It returns a partial copy of an `obj` containing only `propsToPick` properties.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "PICK",
        "date": "2019-11-13T11:29:48.085Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 13013258,
            "margin": 1.56,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 9882090,
            "margin": 1.19,
            "percentSlower": 24.06
          },
          {
            "name": "Lodash",
            "ops": 1544896,
            "margin": 1.28,
            "percentSlower": 88.13
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Lodash",
          "index": 2
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst obj = {\n  a : 'foo',\n  b : 'bar',\n  c : 'baz',\n}\nconst pickInput = [ 'a', 'c' ]\nconst pick = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.pick(pickInput, obj)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.pick(pickInput, obj)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.pick(obj, pickInput)\n    },\n  },\n]\n\nmodule.exports = pick\n"
    },
    "typingSpec": "import { pick } from 'rambda'\n\ndescribe('pick with string as props input', () => {\n  it('one type', () => {\n    const x = pick<number>('a,c', {a:1,b:2,c:3,d:4}); // $ExpectType Dictionary<number>\n    x // $ExpectType Dictionary<number>\n    const y = pick<number>('a,c')({a:1,b:2,c:3,d:4}); // $ExpectType Dictionary<number>\n    y // $ExpectType Dictionary<number>\n  });\n  it('two types', () => {\n    interface Output{\n      a: number\n      c: number\n    }\n\n    const x = pick<string|number, Output>('a,c', {a:1,b:'2',c:3,d:4}); // $ExpectType Output\n    x.a // $ExpectType number\n    const y = pick<string|number, Output>('a,c')({a:1,b:'2',c:3,d:4}); // $ExpectType Output\n    y.a // $ExpectType number\n  });\n\n  it('infered input type', () => {\n    const x = pick('a,c', {a:1,b:2,c:3,d:4}); // $ExpectType Dictionary<number>\n    x // $ExpectType Dictionary<number>\n    const y = pick('a,c', {a:1,b:'1',c:3,d:4}); // $ExpectType Dictionary<string | number>\n    y // $ExpectType Dictionary<string | number>\n    const q = pick('a,c')({a:1,b:1,c:3,d:4}); // $ExpectType Dictionary<unknown>\n    q // $ExpectType Dictionary<unknown>\n  });\n});\n\ndescribe('pick with array as props input', () => {\n  it('one type', () => {\n    const x = pick<number>(['a,c'], {a:1,b:2,c:3,d:4}); // $ExpectType Dictionary<number>\n    x // $ExpectType Dictionary<number>\n    const y = pick<number>(['a,c'])({a:1,b:2,c:3,d:4}); // $ExpectType Dictionary<number>\n    y // $ExpectType Dictionary<number>\n  });\n});\n",
    "methodName": "pick",
    "example": "R.pick(['a', 'c'], {a: 1, b: 2}) // => {a: 1}",
    "code": "export function pick(keys, obj){\n  if (arguments.length === 1) return _obj => pick(keys, _obj)\n\n  if (obj === null || obj === undefined){\n    return undefined\n  }\n  const keysValue =\n    typeof keys === 'string' ? keys.split(',') : keys\n\n  const willReturn = {}\n  let counter = 0\n\n  while (counter < keysValue.length){\n    if (keysValue[ counter ] in obj){\n      willReturn[ keysValue[ counter ] ] = obj[ keysValue[ counter ] ]\n    }\n    counter++\n  }\n\n  return willReturn\n}",
    "spec": "import { pick } from './pick'\n\ntest('pick with string as condition', () => {\n  const obj = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n  const result = pick('a,c', obj)\n  const resultCurry = pick('a,c')(obj)\n  const expectedResult = {\n    a : 1,\n    c : 3,\n  }\n\n  expect(result).toEqual(expectedResult)\n  expect(resultCurry).toEqual(expectedResult)\n})\n\ntest('pick', () => {\n  expect(pick([ 'a', 'c' ])({\n    a : 'foo',\n    b : 'bar',\n    c : 'baz',\n  })).toEqual({\n    a : 'foo',\n    c : 'baz',\n  })\n\n  expect(pick([ 'a', 'd', 'e', 'f' ])({\n    a : 'foo',\n    b : 'bar',\n    c : 'baz',\n  })).toEqual({ a : 'foo' })\n\n  expect(pick('a,d,e,f')(null)).toEqual(undefined)\n})\n"
  },
  "pipe": {
    "explanation": "It performs left-to-right function composition.",
    "ramdaDiff": "var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('pipe', function() {\n  it('performs left-to-right function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.pipe(parseInt, R.multiply, R.map);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.pipe(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.pipe(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "pipe",
    "example": "const result = R.pipe(\n  R.filter(val => val > 2),\n  R.map(a => a * 2)\n)([1, 2, 3, 4])\n\n// => [6, 8]",
    "code": "import { compose } from './compose'\n\nexport function pipe(...fns){\n  if (fns.length === 0) throw new Error('pipe requires at least one argument')\n\n  return compose(...fns.reverse())\n}",
    "spec": "import { add, last, map } from '../rambda'\nimport { pipe } from './pipe'\n\ntest('pipe', () => {\n  const result = pipe(\n    map(add(1)), map(add(10)), last\n  )([ 1, 2, 3 ])\n\n  expect(result).toEqual(14)\n})\n\ntest('with bad input', () => {\n  expect(() => pipe()).toThrow('pipe requires at least one argument')\n})\n"
  },
  "pluck": {
    "explanation": "It returns list of the values of `property` taken from the objects in array of objects `arr`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('pluck', function() {\n  var people = [\n    {name: 'Fred', age: 23},\n    {name: 'Wilma', age: 21},\n    {name: 'Pebbles', age: 2}\n  ];\n  it('behaves as a transducer when given a transducer in list position', function() {\n    var numbers = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];\n    var transducer = R.compose(R.pluck('a'), R.map(R.add(1)), R.take(2));\n    eq(R.transduce(transducer, R.flip(R.append), [], numbers), [2, 3]);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { pluck } from 'rambda'\n\ndescribe('pluck', () => {\n  it('with object', () => {\n    interface ListMember{\n      a: number\n      b: string\n    }\n    const input: ListMember[] = [\n      { a: 1, b: 'foo'},\n      { a: 2, b: 'bar'},\n    ] \n    const resultA = pluck('a', input)\n    const resultB = pluck('b')(input)\n    resultA // $ExpectType number[]\n    resultB // $ExpectType string[]\n  });\n\n  it('with array', () => {\n    const input = [[1, 2], [3, 4], [5, 6]] \n    const result = pluck(0, input)\n    const resultCurry = pluck(0)(input)\n    result // $ExpectType number[]\n    resultCurry // $ExpectType number[]\n  });\n});\n",
    "methodName": "pluck",
    "example": "R.pluck('a')([{a: 1}, {a: 2}, {b: 3}]) // => [1, 2]",
    "code": "import { map } from './map'\n\nexport function pluck(key, list){\n  if (arguments.length === 1) return _list => pluck(key, _list)\n\n  const willReturn = []\n\n  map(val => {\n    if (val[ key ] !== undefined){\n      willReturn.push(val[ key ])\n    }\n  }, list)\n\n  return willReturn\n}",
    "spec": "import { pluck } from './pluck'\n\ntest('happy', () => {\n  expect(pluck('a')([ { a : 1 }, { a : 2 }, { b : 1 } ])).toEqual([ 1, 2 ])\n})\n\ntest('with number', () => {\n  const input = [ [ 1, 2 ], [ 3, 4 ] ]\n\n  expect(pluck(0, input)).toEqual([ 1, 3 ])\n})\n"
  },
  "prepend": {
    "explanation": "It adds `x` to the start of the array `arr`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "prepend",
    "example": "R.prepend('foo', ['bar', 'baz']) // => ['foo', 'bar', 'baz']",
    "code": "export function prepend(el, list){\n  if (arguments.length === 1) return _list => prepend(el, _list)\n\n  if (typeof list === 'string') return `${ el }${ list }`\n\n  const clone = [ el ].concat(list)\n\n  return clone\n}",
    "spec": "import { prepend } from './prepend'\n\ntest('happy', () => {\n  expect(prepend('f', 'oo')).toEqual('foo')\n})\n\ntest('prepend', () => {\n  expect(prepend('yes', [ 'foo', 'bar', 'baz' ])).toEqual([\n    'yes',\n    'foo',\n    'bar',\n    'baz',\n  ])\n\n  expect(prepend('foo')([])).toEqual([ 'foo' ])\n})\n"
  },
  "prop": {
    "explanation": "It returns `undefined` or the value of property `propToFind` in `obj`",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "PROP",
        "date": "2019-11-13T11:29:59.026Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 57302832,
            "margin": 1.55,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 3220963,
            "margin": 1.78,
            "percentSlower": 94.38
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst obj = {\n  a : { c : 2 },\n  b : 1,\n}\nconst propInput = 'b'\n\nconst prop = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.prop(propInput, obj)\n      R.prop(propInput)(obj)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.prop(propInput, obj)\n      Ramda.prop(propInput)(obj)\n    },\n  },\n]\n\nmodule.exports = prop\n"
    },
    "typingSpec": "",
    "methodName": "prop",
    "example": "R.prop('x', {x: 100}) // => 100\nR.prop('x', {a: 1}) // => undefined",
    "code": "export function prop(key, obj){\n  if (arguments.length === 1) return _obj => prop(key, _obj)\n\n  if (!obj) return undefined\n\n  return obj[ key ]\n}",
    "spec": "import { prop } from './prop'\n\ntest('prop', () => {\n  expect(prop('foo')({ foo : 'baz' })).toEqual('baz')\n\n  expect(prop('bar')({ foo : 'baz' })).toEqual(undefined)\n\n  expect(prop('bar')(null)).toEqual(undefined)\n})\n"
  },
  "propEq": {
    "explanation": "It returns true if `obj` has property `propToFind` and its value is equal to `valueToMatch`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('propEq', function() {\n  var obj1 = {name: 'Abby', age: 7, hair: 'blond'};\n  var obj2 = {name: 'Fred', age: 12, hair: 'brown'};\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.propEq('value', 0, {value: -0}), false);\n    eq(R.propEq('value', -0, {value: 0}), false);\n    eq(R.propEq('value', NaN, {value: NaN}), true);\n    eq(R.propEq('value', new Just([42]), {value: new Just([42])}), true);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "propEq",
    "example": "const propToFind = 'foo'\nconst valueToMatch = 0\n\nconst result = R.propEq(propToFind, valueToMatch)({foo: 0})\n// => true",
    "code": "import { curry } from './curry'\n\nfunction propEqFn(\n  key, val, obj\n){\n  if (!obj) return false\n\n  return obj[ key ] === val\n}\n\nexport const propEq = curry(propEqFn)",
    "spec": "import { propEq } from './propEq'\n\ntest('propEq', () => {\n  expect(propEq('foo', 'bar')({ foo : 'bar' })).toBeTrue()\n\n  expect(propEq('foo', 'bar')({ foo : 'baz' })).toBeFalse()\n\n  expect(propEq('foo')('bar')({ foo : 'baz' })).toBeFalse()\n})\n\ntest('happy', () => {\n  expect(propEq(\n    'name', 'Abby', null\n  )).toEqual(false)\n// expect(propEq('name', 'Abby', undefined)).toEqual(false)\n})\n"
  },
  "propIs": {
    "explanation": "It Returns `true` if the specified object property is of the given type.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "propIs",
    "example": "R.propIs(Number, 'x', {x: 1, y: 2});  //=> true\nR.propIs(Number, 'x', {x: 'foo'});    //=> false\nR.propIs(Number, 'x', {});            //=> false",
    "code": "import { curry } from './curry.js'\nimport { is } from './is'\n\nfunction propIsFn(\n  type, name, obj\n){\n  return is(type, obj[ name ])\n}\n\nexport const propIs = curry(propIsFn)",
    "spec": "import { propIs } from './propIs'\n\ntest('1', () => {\n  expect(propIs(\n    Number, 'value', { value : 1 }\n  )).toEqual(true)\n})\n\ntest('2', () => {\n  expect(propIs(\n    String, 'value', { value : 1 }\n  )).toEqual(false)\n})\n\ntest('3', () => {\n  expect(propIs(String)('value')({})).toEqual(false)\n})\n"
  },
  "propOr": {
    "explanation": "If the given, non-null object has an own property with the specified name, returns the value of that property. Otherwise returns the provided default value.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "propOr",
    "example": "const theWall = { mother: 'Waters', comfortablyNumb: 'Gilmour/Waters' }\nconst authorOfWishYouWereHere = R.prop('wishYouWereHere')\nconst authorOfAtomHeartMotherWhenDefault = R.propOr('Pink Floyd', 'atomHeartMother')\n\nauthorOfWishYouWereHere(theWall)  //=> undefined\nauthorOfAtomHeartMotherWhenDefault(theWall) //=> 'Pink Floyd'",
    "code": "import { defaultTo } from './defaultTo'\n\nexport function propOr(\n  defaultValue, p, obj\n){\n  if (arguments.length === 2) return _obj => propOr(\n    defaultValue, p, _obj\n  )\n  if (arguments.length === 1) return (_p, _obj) => propOr(\n    defaultValue, _p, _obj\n  )\n\n  if (!obj) return defaultValue\n\n  return defaultTo(defaultValue,\n    obj[ p ])\n}",
    "spec": "import { propOr } from './propOr'\n\ntest('propOr (result)', () => {\n  const obj = { a : 1 }\n  expect(propOr(\n    'default', 'a', obj\n  )).toEqual(1)\n  expect(propOr(\n    'default', 'notExist', obj\n  )).toEqual('default')\n  expect(propOr(\n    'default', 'notExist', null\n  )).toEqual('default')\n})\n\ntest('propOr (currying)', () => {\n  const obj = { a : 1 }\n  expect(propOr('default')('a', obj)).toEqual(1)\n  expect(propOr('default', 'a')(obj)).toEqual(1)\n  expect(propOr('default')('notExist', obj)).toEqual('default')\n  expect(propOr('default', 'notExist')(obj)).toEqual('default')\n})\n"
  },
  "range": {
    "explanation": "It returns a array of numbers from `start`(inclusive) to `end`(exclusive).",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "RANGE",
        "date": "2019-11-13T11:30:26.432Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 55661283,
            "margin": 2.22,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 20343531,
            "margin": 1.14,
            "percentSlower": 63.45
          },
          {
            "name": "Lodash",
            "ops": 27521383,
            "margin": 2.01,
            "percentSlower": 50.56
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\nconst start = 12\nconst end = 22\nconst range = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.range(start, end)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.range(start, end)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.range(start, end)\n    },\n  },\n]\n\nmodule.exports = range\n"
    },
    "typingSpec": "",
    "methodName": "range",
    "example": "R.range(0, 3)   // => [0, 1, 2]",
    "code": "export function range(from, to){\n  if (arguments.length === 1) return _to => range(from, _to)\n\n  if (Number.isNaN(Number(from)) || Number.isNaN(Number(to))){\n    throw new TypeError('Both arguments to range must be numbers')\n  }\n\n  if (to < from) return []\n\n  const len = to - from\n  const willReturn = Array(len)\n\n  for (let i = 0; i < len; i++){\n    willReturn[ i ] = from + i\n  }\n\n  return willReturn\n}",
    "spec": "import { range } from './range'\n\ntest('happy', () => {\n  expect(range(0, 10)).toEqual([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ])\n})\n\ntest('end range is bigger than start range', () => {\n  expect(range(7, 3)).toEqual([])\n  expect(range(5, 5)).toEqual([])\n})\n\ntest('with bad input', () => {\n  expect(() => range('a', 6)).toThrow('Both arguments to range must be numbers')\n  expect(() => range(6, 'z')).toThrow('Both arguments to range must be numbers')\n\n})\n\ntest('curry', () => {\n  expect(range(0)(10)).toEqual([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ])\n})\n"
  },
  "reduce": {
    "explanation": "",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('reduce', function() {\n  var add = function(a, b) {return a + b;};\n  var mult = function(a, b) {return a * b;};\n  it('Prefers the use of the iterator of an object over reduce (and handles short-circuits)', function() {\n    var symIterator = (typeof Symbol !== 'undefined') ? Symbol.iterator : '@@iterator';\n    function Reducible(arr) {\n      this.arr = arr;\n    }\n    Reducible.prototype.reduce = function(f, init) {\n      var acc = init;\n      for (var i = 0; i < this.arr.length; i += 1) {\n        acc = f(acc, this.arr[i]);\n      }\n      return acc;\n    };\n    Reducible.prototype[symIterator] = function() {\n      var a = this.arr;\n      return {\n        _pos: 0,\n        next: function() {\n          if (this._pos < a.length) {\n            var v = a[this._pos];\n            this._pos += 1;\n            return {\n              value: v,\n              done: false\n            };\n          } else {\n            return {\n              done: true\n            };\n          }\n        }\n      };\n    };\n    var xf = R.take(2);\n    var apendingT = { };\n    apendingT['@@transducer/result'] = R.identity;\n    apendingT['@@transducer/step'] = R.flip(R.append);\n    var rfn = xf(apendingT);\n    var list = new Reducible([1, 2, 3, 4, 5, 6]);\n    eq(R.reduce(rfn, [], list), [1, 2]);\n  });\n  it('short circuits with reduced', function() {\n    var addWithMaxOf10 = function(acc, val) {return acc + val > 10 ? R.reduced(acc) : acc + val;};\n    eq(R.reduce(addWithMaxOf10, 0, [1, 2, 3, 4]), 10);\n    eq(R.reduce(addWithMaxOf10, 0, [2, 4, 6, 8]), 6);\n  });\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "REDUCE",
        "date": "2019-11-13T11:30:42.606Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 7587864,
            "margin": 1.06,
            "percentSlower": 71.84
          },
          {
            "name": "Ramda",
            "ops": 4246097,
            "margin": 0.81,
            "percentSlower": 84.24
          },
          {
            "name": "Lodash",
            "ops": 26948578,
            "margin": 1.43,
            "percentSlower": 0
          }
        ],
        "fastest": {
          "name": "Lodash",
          "index": 2
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\nconst fn = (acc, value) => acc + value\nconst holder = [ 1, 2, 3 ]\nconst acc = ''\n\nconst reduce = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.reduce(fn, acc, holder)\n\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.reduce(fn, acc, holder)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.reduce(holder, fn, acc)\n    },\n  },\n]\n\nmodule.exports = reduce\n"
    },
    "typingSpec": "import { reduce } from 'rambda'\n\ndescribe('reduce', () => {\n  it('happy', () => {\n    const result = reduce<number, number>(\n      (acc, elem) => {\n        acc // $ExpectType number\n        elem // $ExpectType number\n        return acc + elem\n      },\n      1,\n      [ 1, 2, 3 ]\n    )\n\n    result // $ExpectType number\n  });\n\n  it('with two types', () => {\n    const result = reduce<number, string>(\n      (acc, elem) => {\n        acc // $ExpectType string\n        elem // $ExpectType number\n\n        return `${acc}${elem}`\n      },\n      'foo',\n      [ 1, 2, 3 ]\n    )\n\n    result // $ExpectType string\n  });\n\n  it('with index', () => {\n    const result = reduce<number, number>(\n      (acc, elem, i) => {\n        acc // $ExpectType number\n        elem // $ExpectType number\n        i // $ExpectType number\n        return acc + elem\n      },\n      1,\n      [ 1, 2, 3 ]\n    )\n\n    result // $ExpectType number\n  });\n\n  it('fallback', () => {\n    const result = reduce((acc, val) => {\n      acc // $ExpectType number\n      return acc + val\n    }, 1,[ 1, 2, 3 ])\n\n    result // $ExpectType number\n  });\n\n  it('fallback with index', () => {\n    const result = reduce((acc, val, i) => {\n      acc // $ExpectType number\n      i // $ExpectType number\n      return acc + val\n    }, 1,[ 1, 2, 3 ])\n\n    result // $ExpectType number\n  });\n\n  it('fallback with two types', () => {\n    const result = reduce((acc, val) => {\n      acc // $ExpectType string\n      return acc + val\n    }, 'foo',[ 1, 2, 3 ])\n\n    result // $ExpectType string\n  });\n});\n",
    "methodName": "reduce",
    "example": "const iteratorFn = (acc, val) => acc + val\nconst result = R.reduce(iteratorFn, 1, [1, 2, 3])\n// => 7",
    "code": "import { curry } from './curry'\n\nfunction reduceFn(\n  fn, acc, list\n){\n  return list.reduce(fn, acc)\n}\n\nexport const reduce = curry(reduceFn)",
    "spec": "import { compose, curry, map } from '../rambda'\nimport { reduce } from './reduce'\n\ntest('happy', () => {\n  const result = reduce((\n    acc, val, i\n  ) => {\n    expect(typeof i).toBe('number')\n\n    return acc + val\n  })(1)([ 1, 2, 3 ])\n\n  expect(result).toEqual(7)\n})\n\ntest('with compose', () => {\n  const convertToString = (acc, value) => acc + value\n\n  expect(compose(reduce(convertToString, ''),\n    map(x => x + 1))([ 1, 2, 3 ])).toEqual('234')\n})\n\ntest('with curry', () => {\n  const add = curry((n, n2) => n + n2)\n\n  expect(reduce(\n    add, 0, [ 1, 2, 3 ]\n  )).toEqual(6)\n})\n"
  },
  "reject": {
    "explanation": "It has the opposite effect of `R.filter`.\n\nIt will return those members of `arr` that return `false` when applied to function `filterFn`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('reject', function() {\n  var even = function(x) {return x % 2 === 0;};\n  it('dispatches to `filter` method', function() {\n    function Nothing() {}\n    Nothing.value = new Nothing();\n    Nothing.prototype.filter = function() {\n      return this;\n    };\n    function Just(x) { this.value = x; }\n    Just.prototype.filter = function(pred) {\n      return pred(this.value) ? this : Nothing.value;\n    };\n    var m = new Just(42);\n    eq(R.filter(R.T, m), m);\n    eq(R.filter(R.F, m), Nothing.value);\n    eq(R.reject(R.T, m), Nothing.value);\n    eq(R.reject(R.F, m), m);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { reject } from 'rambda'\n\ndescribe('reject with array', () => {\n  it('1 curry', () => {\n    const x = reject<number>((a)=> { // $ExpectType number[]\n      a // $ExpectType number\n      return a > 1\n    })([1,2,3]);\n    x // $ExpectType number[]\n  });\n  it('1', () => {\n    const x = reject<number>((a)=> { // $ExpectType number[]\n      a // $ExpectType number\n      return a > 1\n    },[1,2,3]);\n    x // $ExpectType number[]\n  });\n  it('2', () => {\n    const x = reject<number>((a, b)=> { // $ExpectType number[]\n      a // $ExpectType number\n      return a > 1\n    },[1,2,3]);\n    x // $ExpectType number[]\n  });\n})\n \ndescribe('reject with objects', () => {\n  it('curry', () => {\n    const x = reject<number, number>((a,b,c)=> { // $ExpectType Dictionary<number>\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n\n      return a > 1\n    })({a:1,b:2});\n    x // $ExpectType Dictionary<number>\n  });\n\n  it('object with three arguments predicate', () => {\n    const x = reject<number>((a,b,c)=> { // $ExpectType Dictionary<number>\n      b // $ExpectType string\n      c // $ExpectType Dictionary<number>\n\n      return a > 1\n    },{a:1,b:2});\n    x // $ExpectType Dictionary<number>\n  });\n\n  it('object with two arguments predicate', () => {\n    const x = reject<number>((a,b)=> { // $ExpectType Dictionary<number>\n      b // $ExpectType string\n      return a > 1\n    },{a:1,b:2});\n    x // $ExpectType Dictionary<number>\n  });\n  it('object with one argument predicate', () => {\n    const x = reject<number>((a)=> { // $ExpectType Dictionary<number>\n      a // $ExpectType number\n      return a > 1\n    },{a:1,b:2});\n    x // $ExpectType Dictionary<number>\n  });\n});\n",
    "methodName": "reject",
    "example": "const filterFn = x => x % 2 === 1\n\nconst result = R.reject(filterFn, [1, 2, 3, 4])\n// => [2, 4]",
    "code": "import { filter } from './filter'\n\nexport function reject(fn, list){\n  if (arguments.length === 1) return _list => reject(fn, _list)\n\n  return filter((x, i) => !fn(x, i), list)\n}",
    "spec": "import { add, compose, equals, map } from '../rambda'\nimport { reject } from './reject'\n\nconst isOdd = n => n % 2 === 1\n\ntest('with array', () => {\n  expect(reject(isOdd, [ 1, 2, 3, 4 ])).toEqual([ 2, 4 ])\n})\n\ntest('with object', () => {\n  expect(reject(isOdd, {\n    a : 1,\n    b : 2,\n    c : 3,\n    d : 4,\n  })).toEqual({\n    b : 2,\n    d : 4,\n  })\n})\n\ntest('should work with currying', () => {\n  const result = compose(reject(equals(2)),\n    map(add(1)))({\n    a : 1,\n    b : 2,\n    c : 3,\n  })\n\n  expect(result).toEqual({\n    b : 3,\n    c : 4,\n  })\n})\n\ntest('pass index as second argument', () => {\n  reject((x, i) => {\n    expect(typeof x).toBe('number')\n    expect(typeof i).toBe('number')\n  })([ 10, 12, 15 ])\n})\n"
  },
  "repeat": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "REPEAT",
        "date": "2019-11-13T11:30:58.843Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 9886572,
            "margin": 1.54,
            "percentSlower": 55.51
          },
          {
            "name": "Ramda",
            "ops": 3677206,
            "margin": 1.72,
            "percentSlower": 83.45
          },
          {
            "name": "Lodash",
            "ops": 22219597,
            "margin": 1.8,
            "percentSlower": 0
          }
        ],
        "fastest": {
          "name": "Lodash",
          "index": 2
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\nconst num = 10\nconst str = 'foo'\n\nconst repeat = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.repeat(str, num)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.repeat(str, num)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.repeat(str, num)\n    },\n  },\n]\n\nmodule.exports = repeat\n"
    },
    "typingSpec": "",
    "methodName": "repeat",
    "example": "R.repeat('foo', 2) // => ['foo', 'foo']",
    "code": "export function repeat(val, n){\n  if (arguments.length === 1) return _n => repeat(val, _n)\n\n  const willReturn = Array(n)\n\n  return willReturn.fill(val)\n}",
    "spec": "import { repeat } from './repeat'\n\ntest('repeat', () => {\n  expect(repeat('')(3)).toEqual([ '', '', '' ])\n  expect(repeat('foo', 3)).toEqual([ 'foo', 'foo', 'foo' ])\n\n  const obj = {}\n  const arr = repeat(obj, 3)\n\n  expect(arr).toEqual([ {}, {}, {} ])\n\n  expect(arr[ 0 ] === arr[ 1 ]).toBeTrue()\n})\n"
  },
  "replace": {
    "explanation": "It replaces `strOrRegex` found in `str` with `replacer`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "REPLACE",
        "date": "2019-11-13T11:31:15.547Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 7106810,
            "margin": 1.46,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 4559147,
            "margin": 1.82,
            "percentSlower": 35.85
          },
          {
            "name": "Lodash",
            "ops": 6752550,
            "margin": 1.33,
            "percentSlower": 4.98
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst replace = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.replace(/\\s/g, '|', 'foo bar baz')\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.replace(/\\s/g, '|', 'foo bar baz')\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.replace('foo bar baz', /\\s/g, '|')\n    },\n  },\n]\n\nmodule.exports = replace\n"
    },
    "typingSpec": "",
    "methodName": "replace",
    "example": "R.replace('foo', 'bar', 'foo foo') // => 'bar foo'\nR.replace(/foo/, 'bar', 'foo foo') // => 'bar foo'\nR.replace(/foo/g, 'bar', 'foo foo') // => 'bar bar'",
    "code": "export function replace(\n  pattern, replacer, str\n){\n  if (replacer === undefined){\n    return (_replacer, _str) => replace(\n      pattern, _replacer, _str\n    )\n  } else if (str === undefined){\n    return _str => replace(\n      pattern, replacer, _str\n    )\n  }\n\n  return str.replace(pattern, replacer)\n}",
    "spec": "import { replace } from './replace'\n\ntest('happy', () => {\n  expect(replace(\n    'foo', 'yes', 'foo bar baz'\n  )).toEqual('yes bar baz')\n})\n\ntest('1', () => {\n  expect(replace(/\\s/g)('|')('foo bar baz')).toEqual('foo|bar|baz')\n})\n\ntest('2', () => {\n  expect(replace(/\\s/g)('|', 'foo bar baz')).toEqual('foo|bar|baz')\n})\n\ntest('3', () => {\n  expect(replace(/\\s/g, '|')('foo bar baz')).toEqual('foo|bar|baz')\n})\n"
  },
  "reverse": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "reverse",
    "example": "const arr = [1, 2]\n\nconst result = R.reverse(arr)\n// => [2, 1]",
    "code": "export function reverse(input){\n  if (typeof input === 'string'){\n    return input.split('').reverse()\n      .join('')\n  }\n\n  const clone = input.slice()\n\n  return clone.reverse()\n}",
    "spec": "import { reverse } from './reverse'\n\ntest('happy', () => {\n  expect(reverse([ 1, 2, 3 ])).toEqual([ 3, 2, 1 ])\n})\n\ntest('with string', () => {\n  expect(reverse('baz')).toEqual('zab')\n})\n\ntest('it doesn\\'t mutate', () => {\n  const arr = [ 1, 2, 3 ]\n\n  expect(reverse(arr)).toEqual([ 3, 2, 1 ])\n\n  expect(arr).toEqual([ 1, 2, 3 ])\n})\n"
  },
  "set": {
    "explanation": "Returns a copied `Object` or `Array` with the modified value resulting from the input value replacing that of the lenses focus.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "SET",
        "date": "2020-02-16T11:22:22.690Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 1294216,
            "margin": 1.18,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 548616,
            "margin": 2.54,
            "percentSlower": 57.61
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst testObj = { a: 1 }\n\nconst last = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.set(R.lensProp('a'), 2, testObj)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.set(Ramda.lensProp('a'), 2, testObj)\n    },\n  },\n]\n\nmodule.exports = last\n"
    },
    "typingSpec": "",
    "methodName": "set",
    "example": "const xLens = R.lensProp('x')\n\nR.set(xLens, 4, {x: 1, y: 2}) //=> {x: 4, y: 2}\nR.set(xLens, 8, {x: 1, y: 2}) //=> {x: 8, y: 2}",
    "code": "import { always } from './always'\nimport { over } from './over'\n\nexport function set(\n  lens, v, x\n){\n  if (arguments.length === 1)\n    return (_v, _x) => set(\n      lens, _v, _x\n    )\n  if (arguments.length === 2)\n    return _x => set(\n      lens, v, _x\n    )\n\n  return over(\n    lens, always(v), x\n  )\n}",
    "spec": ""
  },
  "slice": {
    "explanation": "Returns the elements of the given list or string (or object with a `slice`\nmethod) from `fromIndex` (inclusive) to `toIndex` (exclusive).\nDispatches to the `slice` method of the third argument, if present.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('slice', function() {\n  it('handles array-like object', function() {\n    var args = (function() { return arguments; }(1, 2, 3, 4, 5));\n    eq(R.slice(1, 4, args), [2, 3, 4]);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "slice",
    "example": "R.slice(1, 3, ['a', 'b', 'c', 'd'])\n//=> ['b', 'c']",
    "code": "import { curry } from './curry'\n\nfunction sliceFn(\n  fromIndex, toIndex, list\n){\n  return list.slice(fromIndex, toIndex)\n}\n\nexport const slice = curry(sliceFn)",
    "spec": "import { slice } from './slice'\n\ntest('slice', () => {\n  expect(slice(\n    1, 3, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'b', 'c' ])\n  expect(slice(\n    1, Infinity, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'b', 'c', 'd' ])\n  expect(slice(\n    0, -1, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'a', 'b', 'c' ])\n  expect(slice(\n    -3, -1, [ 'a', 'b', 'c', 'd' ]\n  )).toEqual([ 'b', 'c' ])\n  expect(slice(\n    0, 3, 'ramda'\n  )).toEqual('ram')\n})\n"
  },
  "sort": {
    "explanation": "It returns copy of `arr` sorted by `sortFn`.\n\nNote that `sortFn` must return a number type.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "SORT",
        "date": "2019-11-13T11:31:26.433Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 1846442,
            "margin": 2.13,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 1321425,
            "margin": 0.78,
            "percentSlower": 28.43
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst list = [ 'foo', 'bar', 'baz' ]\nconst fn = (a, b) => a > b ? -1 : 1\n\nconst replace = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.sort(fn, list)\n      R.sort(fn)(list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.sort(fn, list)\n      Ramda.sort(fn)(list)\n    },\n  },\n]\n\nmodule.exports = replace\n"
    },
    "typingSpec": "",
    "methodName": "sort",
    "example": "const sortFn = (a, b) => a - b\n\nconst result = R.sort(sortFn, [3, 1, 2])\n// => [1, 2, 3]",
    "code": "export function sort(fn, list){\n  if (arguments.length === 1) return _list => sort(fn, _list)\n\n  const arrClone = list.slice()\n\n  return arrClone.sort(fn)\n}",
    "spec": "import { sort } from './sort'\n\nconst fn = (a, b) => a > b ? 1 : -1\n\ntest('sort', () => {\n  expect(sort((a, b) => a - b)([ 2, 3, 1 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('it doesn\\'t mutate', () => {\n  const list = [ 'foo', 'bar', 'baz' ]\n\n  expect(sort(fn, list)).toEqual([\n    'bar',\n    'baz',\n    'foo',\n  ])\n\n  expect(list[ 0 ]).toBe('foo')\n  expect(list[ 1 ]).toBe('bar')\n  expect(list[ 2 ]).toBe('baz')\n})\n"
  },
  "sortBy": {
    "explanation": "It returns copy of `arr` sorted by `sortFn`.\n\nNote that `sortFn` must return value for comparison.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\nvar albums = [\n  {title: 'Art of the Fugue', artist: 'Glenn Gould', genre: 'Baroque'},\n  {title: 'A Farewell to Kings', artist: 'Rush', genre: 'Rock'},\n  {title: 'Timeout', artist: 'Dave Brubeck Quartet', genre: 'Jazz'},\n  {title: 'Fly By Night', artist: 'Rush', genre: 'Rock'},\n  {title: 'Goldberg Variations', artist: 'Daniel Barenboim', genre: 'Baroque'},\n  {title: 'New World Symphony', artist: 'Leonard Bernstein', genre: 'Romantic'},\n  {title: 'Romance with the Unseen', artist: 'Don Byron', genre: 'Jazz'},\n  {title: 'Somewhere In Time', artist: 'Iron Maiden', genre: 'Metal'},\n  {title: 'In Times of Desparation', artist: 'Danny Holt', genre: 'Modern'},\n  {title: 'Evita', artist: 'Various', genre: 'Broadway'},\n  {title: 'Five Leaves Left', artist: 'Nick Drake', genre: 'Folk'},\n  {title: 'The Magic Flute', artist: 'John Eliot Gardiner', genre: 'Classical'}\n];\ndescribe('sortBy', function() {\n  it('sorts array-like object', function() {\n    var args = (function() { return arguments; }('c', 'a', 'b'));\n    var result = R.sortBy(R.identity, args);\n    eq(result[0], 'a');\n    eq(result[1], 'b');\n    eq(result[2], 'c');\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { sortBy } from 'rambda'\n\ndescribe('sortBy', () => {\n  it('happy', () => {\n    interface Input {a: number}\n\n    function fn(x: Input): number{\n      return x.a\n    }\n\n    const input: Array<Input> = [ { a : 2 }, { a : 1 }, { a : 0 } ]\n    const result =  sortBy(fn, input)\n\n    result // $ExpectType Input[]\n    result[0].a // $ExpectType number\n  });\n});\n",
    "methodName": "sortBy",
    "example": "const sortFn = obj => obj.foo\n\nconst result = R.sortBy(sortFn, [\n  {foo: 1},\n  {foo: 0}\n])\n\nconst expectedResult = [ {foo: 0}, {foo: 1} ]\nconsole.log(R.equals(result, expectedResult))\n// => true",
    "code": "export function sortBy(fn, list){\n  if (arguments.length === 1) return _list => sortBy(fn, _list)\n\n  const arrClone = list.slice()\n\n  return arrClone.sort((a, b) => {\n    const fnA = fn(a)\n    const fnB = fn(b)\n\n    if (fnA === fnB) return 0\n\n    return fnA < fnB ? -1 : 1\n  })\n}",
    "spec": "import { compose, prop, toLower } from '../rambda'\nimport { sortBy } from './sortBy'\n\ntest('sortBy', () => {\n  const sortByNameCaseInsensitive = sortBy(compose(toLower, prop('name')))\n  const alice = {\n    name : 'ALICE',\n    age  : 101,\n  }\n  const bob = {\n    name : 'Bob',\n    age  : -10,\n  }\n  const clara = {\n    name : 'clara',\n    age  : 314.159,\n  }\n  const people = [ clara, bob, alice ]\n\n  expect(sortByNameCaseInsensitive(people)).toEqual([ alice, bob, clara ])\n\n  expect(sortBy(val => val.a, [ { a : 2 }, { a : 1 }, { a : 0 } ])).toEqual([ { a : 0 }, { a : 1 }, { a : 2 } ])\n\n  expect(sortBy(val => val.a, [ { a : 1 }, { a : 1 }, { a : 1 } ])).toEqual([ { a : 1 }, { a : 1 }, { a : 1 } ])\n\n  expect(sortBy(val => val.a, [ { a : 3 }, { a : 2 }, { a : 1 } ])).toEqual([ { a : 1 }, { a : 2 }, { a : 3 } ])\n\n  expect(sortBy(val => val.a, [ { a : 1 }, { a : 2 }, { a : 3 } ])).toEqual([ { a : 1 }, { a : 2 }, { a : 3 } ])\n})\n"
  },
  "split": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "SPLIT",
        "date": "2019-11-13T11:31:59.084Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 7367828,
            "margin": 0.61,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 3221635,
            "margin": 1.34,
            "percentSlower": 56.27
          },
          {
            "name": "Lodash",
            "ops": 5247083,
            "margin": 1,
            "percentSlower": 28.78
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst str = 'foo|bar|baz'\nconst sep = '|'\n\nconst split = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.split(sep, str)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.split(sep, str)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.split(str, sep)\n    },\n  },\n]\n\nmodule.exports = split\n"
    },
    "typingSpec": "",
    "methodName": "split",
    "example": "R.split('-', 'a-b-c') // => ['a', 'b', 'c']",
    "code": "export function split(separator, str){\n  if (arguments.length === 1) return _str => split(separator, _str)\n\n  return str.split(separator)\n}",
    "spec": "import { split } from './split'\n\ntest('split', () => {\n  expect(split('|')('foo|bar|baz')).toEqual([ 'foo', 'bar', 'baz' ])\n\n  expect(split('.', 'a.b.c.xyz.d')).toEqual([\n    'a',\n    'b',\n    'c',\n    'xyz',\n    'd',\n  ])\n})\n"
  },
  "splitEvery": {
    "explanation": "It splits `arrOrStr` into slices of `sliceLength`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "splitEvery",
    "example": "R.splitEvery(2, [1, 2, 3]) // => [[1, 2], [3]]\nR.splitEvery(3, 'foobar') // => ['foo', 'bar']",
    "code": "export function splitEvery(n, list){\n  if (arguments.length === 1) return _list => splitEvery(n, _list)\n\n  if (n < 1) throw new Error('First argument to splitEvery must be a positive integer')\n  const willReturn = []\n  let counter = 0\n\n  while (counter < list.length){\n    willReturn.push(list.slice(counter, counter += n))\n  }\n\n  return willReturn\n}",
    "spec": "import { splitEvery } from './splitEvery'\n\ntest('happy', () => {\n  expect(splitEvery(3, [ 1, 2, 3, 4, 5, 6, 7 ])).toEqual([\n    [ 1, 2, 3 ],\n    [ 4, 5, 6 ],\n    [ 7 ],\n  ])\n\n  expect(splitEvery(3)('foobarbaz')).toEqual([ 'foo', 'bar', 'baz' ])\n})\n\ntest('with bad input', () => {\n  expect(() => expect(splitEvery(0)('foo')).toEqual([ 'f', 'o', 'o' ])).toThrow('First argument to splitEvery must be a positive integer')\n\n})\n"
  },
  "startsWith": {
    "explanation": "",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('startsWith', function() {\n  it('should return true when an array starts with the provided value', function() {\n    eq(R.startsWith(['a'], ['a', 'b', 'c']), true);\n  });\n  it('should return true when an array starts with the provided values', function() {\n    eq(R.startsWith(['a', 'b'], ['a', 'b', 'c']), true);\n  });\n  it('should return false when an array does not start with the provided value', function() {\n    eq(R.startsWith(['b'], ['a', 'b', 'c']), false);\n  });\n  it('should return false when an array does not start with the provided values', function() {\n    eq(R.startsWith(['b', 'c'], ['a', 'b', 'c']), false);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "startsWith",
    "example": "R.startsWith(\n  'foo',\n  'foo-bar'\n) // => true\n\nR.startsWith(\n  'bar',\n  'foo-bar'\n) // => false",
    "code": "export function startsWith(prefix, list){\n  if (arguments.length === 1) return _list => startsWith(prefix, _list)\n\n  return list.startsWith(prefix)\n}",
    "spec": "import { startsWith } from './startsWith'\n\ntest('true', () => {\n  const result = startsWith('foo', 'foo-bar')\n\n  expect(result).toBeTrue()\n})\n\ntest('false', () => {\n  const result = startsWith('baz')('foo-bar')\n\n  expect(result).toBeFalse()\n})\n"
  },
  "subtract": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "subtract",
    "example": "R.subtract(3, 1) // => 2",
    "code": "export function subtract(a, b){\n  if (arguments.length === 1) return _b => subtract(a, _b)\n\n  return a - b\n}",
    "spec": "import { subtract } from './subtract'\n\ntest('happy', () => {\n  expect(subtract(2, 1)).toEqual(1)\n  expect(subtract(2)(1)).toEqual(1)\n})\n"
  },
  "sum": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "sum",
    "example": "R.sum([1,2,3,4,5]) // => 15",
    "code": "export function sum(list){\n  return list.reduce((prev, current) => prev + current,\n    0)\n}",
    "spec": "import { sum } from './sum'\n\ntest('happy', () => {\n  expect(sum([ 1, 2, 3, 4, 5 ])).toBe(15)\n})\n"
  },
  "tail": {
    "explanation": "- It returns all but the first element of `arrOrStr`",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "tail",
    "example": "R.tail([1, 2, 3])  // => [2, 3]\nR.tail('foo')  // => 'oo'",
    "code": "import { drop } from './drop'\n\nexport function tail(list){\n  return drop(1, list)\n}",
    "spec": "import { tail } from './tail'\n\ntest('tail', () => {\n  expect(tail([ 1, 2, 3 ])).toEqual([ 2, 3 ])\n  expect(tail([ 1, 2 ])).toEqual([ 2 ])\n  expect(tail([ 1 ])).toEqual([])\n  expect(tail([])).toEqual([])\n\n  expect(tail('abc')).toEqual('bc')\n  expect(tail('ab')).toEqual('b')\n  expect(tail('a')).toEqual('')\n  expect(tail('')).toEqual('')\n})\n"
  },
  "take": {
    "explanation": "It returns the first `num` elements of `arrOrStr`.",
    "ramdaDiff": "var assert = require('assert');\nvar sinon = require('sinon');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\ndescribe('take', function() {\n  it('handles zero correctly (#1224)', function() {\n    eq(R.into([], R.take(0), [1, 2, 3]), []);\n  });\n  it('steps correct number of times', function() {\n    var spy = sinon.spy();\n    R.into([], R.compose(R.map(spy), R.take(2)), [1, 2, 3]);\n    sinon.assert.calledTwice(spy);\n  });\n  it('transducer called for every member of list if `n` is < 0', function() {\n    var spy = sinon.spy();\n    R.into([], R.compose(R.map(spy), R.take(-1)), [1, 2, 3]);\n    sinon.assert.calledThrice(spy);\n  });\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "TAKE",
        "date": "2019-11-13T11:32:26.209Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 128409999,
            "margin": 1.67,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 5133255,
            "margin": 1.03,
            "percentSlower": 96
          },
          {
            "name": "Lodash",
            "ops": 94929087,
            "margin": 1.26,
            "percentSlower": 26.07
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst list = [ 1, 2, 3, 4 ]\nconst num = 2\n\nconst take = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.take(num, list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.take(num, list)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.take(list, num)\n    },\n  },\n]\n\nmodule.exports = take\n"
    },
    "typingSpec": "",
    "methodName": "take",
    "example": "R.take(1, ['foo', 'bar']) // => ['foo']\nR.take(2, 'foo') // => 'fo'",
    "code": "import baseSlice from './internal/baseSlice'\n\nexport function take(n, list){\n  if (arguments.length === 1) return _list => take(n, _list)\n  if (n < 0) return list.slice()\n  if (typeof list === 'string') return list.slice(0, n)\n\n  return baseSlice(\n    list, 0, n\n  )\n}",
    "spec": "import { take } from './take'\n\ntest('happy', () => {\n  const arr = [ 'foo', 'bar', 'baz' ]\n\n  expect(take(1, arr)).toEqual([ 'foo' ])\n\n  expect(arr).toEqual([ 'foo', 'bar', 'baz' ])\n\n  expect(take(2)([ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar' ])\n  expect(take(3, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n  expect(take(4, [ 'foo', 'bar', 'baz' ])).toEqual([ 'foo', 'bar', 'baz' ])\n  expect(take(3)('rambda')).toEqual('ram')\n})\n\ntest('with negative index', () => {\n  expect(take(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(take(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n\ntest('with zero index', () => {\n  expect(take(0, [ 1, 2, 3 ])).toEqual([])\n})\n"
  },
  "takeLast": {
    "explanation": "It returns the last `num` elements of `arrOrStr`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "takeLast",
    "example": "R.takeLast(1, ['foo', 'bar']) // => ['bar']\nR.takeLast(2, 'foo') // => 'oo'",
    "code": "import baseSlice from './internal/baseSlice'\n\nexport function takeLast(n, list){\n  if (arguments.length === 1) return _list => takeLast(n, _list)\n\n  const len = list.length\n  if (n < 0) return list.slice()\n  let numValue = n > len ? len : n\n\n  if (typeof list === 'string') return list.slice(len - numValue)\n\n  numValue = len - numValue\n\n  return baseSlice(\n    list, numValue, len\n  )\n}",
    "spec": "import { takeLast } from './takeLast'\n\ntest('with arrays', () => {\n  expect(takeLast(1, [ 'foo', 'bar', 'baz' ])).toEqual([ 'baz' ])\n\n  expect(takeLast(2)([ 'foo', 'bar', 'baz' ])).toEqual([\n    'bar',\n    'baz',\n  ])\n\n  expect(takeLast(3, [ 'foo', 'bar', 'baz' ])).toEqual([\n    'foo',\n    'bar',\n    'baz',\n  ])\n\n  expect(takeLast(4, [ 'foo', 'bar', 'baz' ])).toEqual([\n    'foo',\n    'bar',\n    'baz',\n  ])\n\n  expect(takeLast(10, [ 'foo', 'bar', 'baz' ])).toEqual([\n    'foo',\n    'bar',\n    'baz',\n  ])\n})\n\ntest('with strings', () => {\n  expect(takeLast(3, 'rambda')).toEqual('bda')\n\n  expect(takeLast(7, 'rambda')).toEqual('rambda')\n})\n\ntest('with negative index', () => {\n  expect(takeLast(-1, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n  expect(takeLast(-Infinity, [ 1, 2, 3 ])).toEqual([ 1, 2, 3 ])\n})\n"
  },
  "tap": {
    "explanation": "It applies function to input and pass the input back. Use case is debuging in the middle of `R.compose`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\nvar listXf = require('./helpers/listXf');\nvar _curry2 = require('rambda/internal/_curry2');\n\ndescribe('tap', function() {\n  var pushToList = _curry2(function(lst, x) { lst.push(x); });\n  it('can act as a transducer', function() {\n    var sideEffect = [];\n    var numbers = [1,2,3,4,5];\n    var xf = R.compose(R.map(R.identity), R.tap(pushToList(sideEffect)));\n    eq(R.into([], xf, numbers), numbers);\n    eq(sideEffect, numbers);\n  });\n  it('dispatches to transformer objects', function() {\n    var sideEffect = [];\n    var pushToSideEffect = pushToList(sideEffect);\n    eq(R.tap(pushToSideEffect, listXf), {\n      f: pushToSideEffect,\n      xf: listXf\n    });\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "tap",
    "example": "let a = 1\nconst sayX = x => (a = x)\n\nconst result = R.tap(sayX, 100)\n// both `a` and `result` are `100`",
    "code": "export function tap(fn, x){\n  if (arguments.length === 1) return _x => tap(fn, _x)\n\n  fn(x)\n\n  return x\n}",
    "spec": "import { tap } from './tap'\n\ntest('tap', () => {\n  let a = 1\n  const sayX = x => a = x\n\n  expect(tap(sayX, 100)).toEqual(100)\n  expect(tap(sayX)(100)).toEqual(100)\n  expect(a).toEqual(100)\n})\n"
  },
  "test": {
    "explanation": "Determines whether `str` matches `regExpression`",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "TEST",
        "date": "2019-11-13T11:32:53.614Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 12981580,
            "margin": 1.93,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 1706042,
            "margin": 1.01,
            "percentSlower": 86.86
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst test = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.test(/\\s/g, 'x y z')\n      R.test(/\\s/g)('x y z')\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.test(/\\s/g, 'x y z')\n      Ramda.test(/\\s/g)('x y z')\n    },\n  },\n]\n\nmodule.exports = test\n"
    },
    "typingSpec": "",
    "methodName": "test",
    "example": "R.test(/^f/, 'foo')\n// => true",
    "code": "export function test(pattern, str){\n  if (arguments.length === 1) return _str => test(pattern, _str)\n\n  if (typeof pattern === 'string'){\n    throw new TypeError(`test requires a value of type RegExp as its first argument; received \"${ pattern }\"`)\n  }\n\n  return str.search(pattern) !== -1\n}",
    "spec": "import { test as testMethod } from './testMethod'\n\ntest('happy', () => {\n  expect(testMethod(/^x/, 'xyz')).toBeTrue()\n\n  expect(testMethod(/^y/)('xyz')).toBeFalse()\n})\n\ntest('throws if first argument is not regex', () => {\n  expect(() => testMethod('foo', 'bar')).toThrow('test requires a value of type RegExp as its first argument; received \"foo\"')\n})\n"
  },
  "times": {
    "explanation": "It returns the result of applying function `fn` over members of range array.\nThe range array includes numbers between `0` and `n`(exclusive).",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "times",
    "example": "R.times(R.identity, 5)\n//=> [0, 1, 2, 3, 4]",
    "code": "import { map } from './map'\nimport { range } from './range'\n\nexport function times(fn, n){\n  if (arguments.length === 1) return _n => times(fn, _n)\n  if (!Number.isInteger(n) || n < 0) throw new RangeError('n must be an integer')\n\n  return map(fn, range(0, n))\n}",
    "spec": "import assert from 'assert'\n\nimport { identity } from './identity'\nimport { times } from './times'\n\ntest('happy', () => {\n  const result = times(identity, 5)\n\n  expect(result).toEqual([ 0, 1, 2, 3, 4 ])\n})\n\ntest('with bad input', () => {\n  assert.throws(() => { times(3)('cheers!') }, RangeError)\n  assert.throws(() => { times(identity, -1) }, RangeError)\n})\n\ntest('curry', () => {\n  const result = times(identity)(5)\n\n  expect(result).toEqual([ 0, 1, 2, 3, 4 ])\n})\n"
  },
  "toLower": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "toLower",
    "example": "R.toLower('FOO') // => 'foo'",
    "code": "export function toLower(str){\n  return str.toLowerCase()\n}",
    "spec": "import { toLower } from './toLower'\n\ntest('toLower', () => {\n  expect(toLower('FOO|BAR|BAZ')).toEqual('foo|bar|baz')\n})\n"
  },
  "toPairs": {
    "explanation": "It transforms an object to a list.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "toPairs",
    "example": "const list = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\nconst expected = [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', [ 3, 4 ] ] ]\n\nconst result = R.toPairs(list)\n// expected === result",
    "code": "export function toPairs(obj){\n  return Object.entries(obj)\n}",
    "spec": "import { toPairs } from './toPairs'\n\nconst obj = {\n  a : 1,\n  b : 2,\n  c : [ 3, 4 ],\n}\nconst expected = [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', [ 3, 4 ] ] ]\n\ntest('happy', () => {\n  expect(toPairs(obj)).toEqual(expected)\n})\n"
  },
  "toString": {
    "explanation": "",
    "ramdaDiff": "var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda.js');\ndescribe('toString', function() {\n  it('returns the string representation of null', function() {\n    assert.strictEqual(R.toString(null), 'null');\n  });\n  it('returns the string representation of undefined', function() {\n    assert.strictEqual(R.toString(undefined), 'undefined');\n  });\n  it('returns the string representation of a number primitive', function() {\n    assert.strictEqual(R.toString(0), '0');\n    assert.strictEqual(R.toString(-0), '-0');\n    assert.strictEqual(R.toString(1.23), '1.23');\n    assert.strictEqual(R.toString(-1.23), '-1.23');\n    assert.strictEqual(R.toString(1e+23), '1e+23');\n    assert.strictEqual(R.toString(-1e+23), '-1e+23');\n    assert.strictEqual(R.toString(1e-23), '1e-23');\n    assert.strictEqual(R.toString(-1e-23), '-1e-23');\n    assert.strictEqual(R.toString(Infinity), 'Infinity');\n    assert.strictEqual(R.toString(-Infinity), '-Infinity');\n    assert.strictEqual(R.toString(NaN), 'NaN');\n  });\n  it('returns the string representation of a string primitive', function() {\n    assert.strictEqual(R.toString('abc'), '\"abc\"');\n    assert.strictEqual(R.toString('x \"y\" z'), '\"x \\\\\"y\\\\\" z\"');\n    assert.strictEqual(R.toString(\"' '\"), '\"\\' \\'\"');\n    assert.strictEqual(R.toString('\" \"'), '\"\\\\\" \\\\\"\"');\n    assert.strictEqual(R.toString('\\b \\b'), '\"\\\\b \\\\b\"');\n    assert.strictEqual(R.toString('\\f \\f'), '\"\\\\f \\\\f\"');\n    assert.strictEqual(R.toString('\\n \\n'), '\"\\\\n \\\\n\"');\n    assert.strictEqual(R.toString('\\r \\r'), '\"\\\\r \\\\r\"');\n    assert.strictEqual(R.toString('\\t \\t'), '\"\\\\t \\\\t\"');\n    assert.strictEqual(R.toString('\\v \\v'), '\"\\\\v \\\\v\"');\n    assert.strictEqual(R.toString('\\0 \\0'), '\"\\\\0 \\\\0\"');\n    assert.strictEqual(R.toString('\\\\ \\\\'), '\"\\\\\\\\ \\\\\\\\\"');\n  });\n  it('returns the string representation of a Boolean object', function() {\n    assert.strictEqual(R.toString(new Boolean(true)), 'new Boolean(true)');\n    assert.strictEqual(R.toString(new Boolean(false)), 'new Boolean(false)');\n  });\n  it('returns the string representation of a Number object', function() {\n    assert.strictEqual(R.toString(new Number(0)), 'new Number(0)');\n    assert.strictEqual(R.toString(new Number(-0)), 'new Number(-0)');\n  });\n  it('returns the string representation of a String object', function() {\n    assert.strictEqual(R.toString(new String('abc')), 'new String(\"abc\")');\n    assert.strictEqual(R.toString(new String('x \"y\" z')), 'new String(\"x \\\\\"y\\\\\" z\")');\n    assert.strictEqual(R.toString(new String(\"' '\")), 'new String(\"\\' \\'\")');\n    assert.strictEqual(R.toString(new String('\" \"')), 'new String(\"\\\\\" \\\\\"\")');\n    assert.strictEqual(R.toString(new String('\\b \\b')), 'new String(\"\\\\b \\\\b\")');\n    assert.strictEqual(R.toString(new String('\\f \\f')), 'new String(\"\\\\f \\\\f\")');\n    assert.strictEqual(R.toString(new String('\\n \\n')), 'new String(\"\\\\n \\\\n\")');\n    assert.strictEqual(R.toString(new String('\\r \\r')), 'new String(\"\\\\r \\\\r\")');\n    assert.strictEqual(R.toString(new String('\\t \\t')), 'new String(\"\\\\t \\\\t\")');\n    assert.strictEqual(R.toString(new String('\\v \\v')), 'new String(\"\\\\v \\\\v\")');\n    assert.strictEqual(R.toString(new String('\\0 \\0')), 'new String(\"\\\\0 \\\\0\")');\n    assert.strictEqual(R.toString(new String('\\\\ \\\\')), 'new String(\"\\\\\\\\ \\\\\\\\\")');\n  });\n  it('returns the string representation of a Date object', function() {\n    assert.strictEqual(R.toString(new Date('2001-02-03T04:05:06.000Z')), 'new Date(\"2001-02-03T04:05:06.000Z\")');\n    assert.strictEqual(R.toString(new Date('XXX')), 'new Date(NaN)');\n  });\n  it('returns the string representation of an array', function() {\n    assert.strictEqual(R.toString([]), '[]');\n    assert.strictEqual(R.toString([1, 2, 3]), '[1, 2, 3]');\n    assert.strictEqual(R.toString([1, [2, [3]]]), '[1, [2, [3]]]');\n    assert.strictEqual(R.toString(['x', 'y']), '[\"x\", \"y\"]');\n  });\n  it('returns the string representation of an array with non-numeric property names', function() {\n    var xs = [1, 2, 3];\n    xs.foo = 0;\n    xs.bar = 0;\n    xs.baz = 0;\n    assert.strictEqual(R.toString(xs), '[1, 2, 3, \"bar\": 0, \"baz\": 0, \"foo\": 0]');\n  });\n  it('returns the string representation of an arguments object', function() {\n    assert.strictEqual(R.toString((function() { return arguments; })()), '(function() { return arguments; }())');\n    assert.strictEqual(R.toString((function() { return arguments; })(1, 2, 3)), '(function() { return arguments; }(1, 2, 3))');\n    assert.strictEqual(R.toString((function() { return arguments; })(['x', 'y'])), '(function() { return arguments; }([\"x\", \"y\"]))');\n  });\n  it('returns the string representation of a plain object', function() {\n    assert.strictEqual(R.toString({}), '{}');\n    assert.strictEqual(R.toString({foo: 1, bar: 2, baz: 3}), '{\"bar\": 2, \"baz\": 3, \"foo\": 1}');\n    assert.strictEqual(R.toString({'\"quoted\"': true}), '{\"\\\\\"quoted\\\\\"\": true}');\n    assert.strictEqual(R.toString({a: {b: {c: {}}}}), '{\"a\": {\"b\": {\"c\": {}}}}');\n  });\n  it('treats instance without custom `toString` method as plain object', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    assert.strictEqual(R.toString(new Point(1, 2)), '{\"x\": 1, \"y\": 2}');\n  });\n  it('dispatches to custom `toString` method', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    Point.prototype.toString = function() {\n      return 'new Point(' + this.x + ', ' + this.y + ')';\n    };\n    assert.strictEqual(R.toString(new Point(1, 2)), 'new Point(1, 2)');\n    function Just(x) {\n      if (!(this instanceof Just)) {\n        return new Just(x);\n      }\n      this.value = x;\n    }\n    Just.prototype.toString = function() {\n      return 'Just(' + R.toString(this.value) + ')';\n    };\n    assert.strictEqual(R.toString(Just(42)), 'Just(42)');\n    assert.strictEqual(R.toString(Just([1, 2, 3])), 'Just([1, 2, 3])');\n    assert.strictEqual(R.toString(Just(Just(Just('')))), 'Just(Just(Just(\"\")))');\n    assert.strictEqual(R.toString({toString: R.always('x')}), 'x');\n  });\n  it('handles object with no `toString` method', function() {\n    if (typeof Object.create === 'function') {\n      var a = Object.create(null);\n      var b = Object.create(null); b.x = 1; b.y = 2;\n      assert.strictEqual(R.toString(a), '{}');\n      assert.strictEqual(R.toString(b), '{\"x\": 1, \"y\": 2}');\n    }\n  });\n  it('handles circular references', function() {\n    var a = [];\n    a[0] = a;\n    assert.strictEqual(R.toString(a), '[<Circular>]');\n    var o = {};\n    o.o = o;\n    assert.strictEqual(R.toString(o), '{\"o\": <Circular>}');\n    var b = ['bee'];\n    var c = ['see'];\n    b[1] = c;\n    c[1] = b;\n    assert.strictEqual(R.toString(b), '[\"bee\", [\"see\", <Circular>]]');\n    assert.strictEqual(R.toString(c), '[\"see\", [\"bee\", <Circular>]]');\n    var p = {};\n    var q = {};\n    p.q = q;\n    q.p = p;\n    assert.strictEqual(R.toString(p), '{\"q\": {\"p\": <Circular>}}');\n    assert.strictEqual(R.toString(q), '{\"p\": {\"q\": <Circular>}}');\n    var x = [];\n    var y = {};\n    x[0] = y;\n    y.x = x;\n    assert.strictEqual(R.toString(x), '[{\"x\": <Circular>}]');\n    assert.strictEqual(R.toString(y), '{\"x\": [<Circular>]}');\n  });\n});",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "toString",
    "example": "R.toString([1, 2]) // => '1,2'",
    "code": "export function toString(val){\n  return val.toString()\n}",
    "spec": "import { toString } from './toString'\n\ntest('happy', () => {\n  expect(toString([ 1, 2, 3 ])).toEqual('1,2,3')\n})\n"
  },
  "toUpper": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "toUpper",
    "example": "R.toUpper('foo') // => 'FOO'",
    "code": "export function toUpper(str){\n  return str.toUpperCase()\n}",
    "spec": "import { toUpper } from './toUpper'\n\ntest('toUpper', () => {\n  expect(toUpper('foo|bar|baz')).toEqual('FOO|BAR|BAZ')\n})\n"
  },
  "transpose": {
    "explanation": "",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "transpose",
    "example": "const input = [[10, 11], [20], [], [30, 31, 32]]\nconst expected = [[10, 20, 30], [11, 31], [32]]\n\nconst result = R.transpose(input)\n// result === expected",
    "code": "export function transpose(array){\n  return array.reduce((acc, el) => {\n    el.forEach((nestedEl, i) =>\n      Array.isArray(acc[ i ]) ? acc[ i ].push(nestedEl) : acc.push([ nestedEl ]))\n\n    return acc\n  }, [])\n}",
    "spec": "import { transpose } from './transpose'\n\ntest('happy', () => {\n  const input = [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', 3 ] ]\n\n  expect(transpose(input)).toEqual([ [ 'a', 'b', 'c' ], [ 1, 2, 3 ] ])\n})\n\ntest('when rows are shorter', () => {\n  const actual = transpose([ [ 10, 11 ], [ 20 ], [], [ 30, 31, 32 ] ])\n  const expected = [ [ 10, 20, 30 ], [ 11, 31 ], [ 32 ] ]\n  expect(actual).toEqual(expected)\n})\n\ntest('with empty array', () => {\n  expect(transpose([])).toEqual([])\n})\n\ntest('array with falsy values', () => {\n  const actual = transpose([ [ true, false, undefined, null ], [ null, undefined, false, true ] ])\n  const expected = [ [ true, null ], [ false, undefined ], [ undefined, false ], [ null, true ] ]\n  expect(actual).toEqual(expected)\n})\n"
  },
  "trim": {
    "explanation": "",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('trim', function() {\n  var test = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFFHello, World!\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n  it('trims all ES5 whitespace', function() {\n    eq(R.trim(test), 'Hello, World!');\n    eq(R.trim(test).length, 13);\n  });\n  if (typeof String.prototype.trim !== 'function') {\n    it('falls back to a shim if String.prototype.trim is not present', function() {\n      eq(R.trim('   xyz  '), 'xyz');\n      eq(R.trim(test), 'Hello, World!');\n      eq(R.trim(test).length, 13);\n      eq(R.trim('\\u200b'), '\\u200b');\n      eq(R.trim('\\u200b').length, 1);\n    });\n  }\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "trim",
    "example": "R.trim('  foo  ') // => 'foo'",
    "code": "export function trim(str){\n  return str.trim()\n}",
    "spec": "import { trim } from './trim'\n\ntest('trim', () => {\n  expect(trim(' foo ')).toEqual('foo')\n})\n"
  },
  "type": {
    "explanation": "",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('type', function() {\n  // it('\"Arguments\" if given an arguments object', function() {\n  //   var args = (function() { return arguments; }());\n  //   eq(R.type(args), 'Arguments');\n  // });\n  it('\"Number\" if given the NaN value', function() {\n    eq(R.type(NaN), 'Number');\n  });\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "TYPE",
        "date": "2019-11-13T11:33:04.292Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 381347,
            "margin": 1.81,
            "percentSlower": 19.76
          },
          {
            "name": "Ramda",
            "ops": 475281,
            "margin": 0.59,
            "percentSlower": 0
          }
        ],
        "fastest": {
          "name": "Ramda",
          "index": 1
        },
        "slowest": {
          "name": "Rambda",
          "index": 0
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\nconst fn1 = () => {}\nconst fn2 = function(){}\nfunction fn3(){}\n\nconst test = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.type(new Boolean(true))\n      R.type(new String('I am a String object'))\n      R.type(fn1)\n      R.type(fn2)\n      R.type(fn3)\n      R.type(1)\n      R.type({ a : 1 })\n      R.type(null)\n      R.type(undefined)\n      R.type(Number('foo'))\n      R.type([ 12, 3 ])\n      R.type(/\\s/g)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.type(new Boolean(true))\n      Ramda.type(new String('I am a String object'))\n      Ramda.type(fn1)\n      Ramda.type(fn2)\n      Ramda.type(fn3)\n      Ramda.type(1)\n      Ramda.type({ a : 1 })\n      Ramda.type(null)\n      Ramda.type(undefined)\n      Ramda.type(Number('foo'))\n      Ramda.type([ 12, 3 ])\n      Ramda.type(/\\s/g)\n    },\n  },\n]\n\nmodule.exports = test\n"
    },
    "typingSpec": "",
    "methodName": "type",
    "example": "R.type(() => {}) // => 'Function'\nR.type(async () => {}) // => 'Async'\nR.type([]) // => 'Array'\nR.type({}) // => 'Object'\nR.type('foo') // => 'String'\nR.type(1) // => 'Number'\nR.type(true) // => 'Boolean'\nR.type(null) // => 'Null'\nR.type(/[A-z]/) // => 'RegExp'\n\nconst delay = ms => new Promise(resolve => {\n  setTimeout(function () {\n    resolve()\n  }, ms)\n})\nR.type(delay) // => 'Promise'",
    "code": "export function type(input){\n  const typeOf = typeof input\n\n  if (input === null){\n    return 'Null'\n  } else if (input === undefined){\n    return 'Undefined'\n  } else if (typeOf === 'boolean'){\n    return 'Boolean'\n  } else if (typeOf === 'number'){\n    return Number.isNaN(input) ? 'NaN' : 'Number'\n  } else if (typeOf === 'string'){\n    return 'String'\n  } else if (Array.isArray(input)){\n    return 'Array'\n  } else if (input instanceof RegExp){\n    return 'RegExp'\n  }\n\n  const asStr = input && input.toString ? input.toString() : ''\n\n  if ([ 'true', 'false' ].includes(asStr)) return 'Boolean'\n  if (!Number.isNaN(Number(asStr))) return 'Number'\n  if (asStr.startsWith('async')) return 'Async'\n  if (asStr === '[object Promise]') return 'Promise'\n  if (typeOf === 'function') return 'Function'\n  if (input instanceof String) return 'String'\n\n  return 'Object'\n}",
    "spec": "import { type as ramdaType } from 'ramda'\n\nimport { type } from './type'\n\ntest('with simple promise', () => {\n  expect(type(Promise.resolve(1))).toBe('Promise')\n})\n\ntest('with new Boolean', () => {\n  expect(type(new Boolean(true))).toBe('Boolean')\n})\n\ntest('with new String', () => {\n  expect(type(new String('I am a String object'))).toEqual('String')\n})\n\ntest('with new Number', () => {\n  expect(type(new Number(1))).toBe('Number')\n})\n\ntest('with new promise', () => {\n  const delay = ms =>\n    new Promise(resolve => {\n      setTimeout(() => {\n        resolve(ms + 110)\n      }, ms)\n    })\n\n  expect(type(delay(10))).toEqual('Promise')\n})\n\ntest('async function', () => {\n  expect(type(async () => {})).toEqual('Async')\n})\n\ntest('async arrow', () => {\n  const asyncArrow = async () => {}\n  expect(type(asyncArrow)).toBe('Async')\n})\n\ntest('function', () => {\n  const fn1 = () => {}\n  const fn2 = function(){}\n\n  function fn3(){}\n\n  [ () => {}, fn1, fn2, fn3 ].map(val => {\n    expect(type(val)).toEqual('Function')\n  })\n})\n\ntest('object', () => {\n  expect(type({})).toEqual('Object')\n})\n\ntest('number', () => {\n  expect(type(1)).toEqual('Number')\n})\n\ntest('boolean', () => {\n  expect(type(false)).toEqual('Boolean')\n})\n\ntest('string', () => {\n  expect(type('foo')).toEqual('String')\n})\n\ntest('null', () => {\n  expect(type(null)).toEqual('Null')\n})\n\ntest('array', () => {\n  expect(type([])).toEqual('Array')\n  expect(type([ 1, 2, 3 ])).toEqual('Array')\n})\n\ntest('regex', () => {\n  expect(type(/\\s/g)).toEqual('RegExp')\n})\n\ntest('undefined', () => {\n  expect(type(undefined)).toEqual('Undefined')\n})\n\ntest('not a number', () => {\n  expect(type(Number('s'))).toBe('NaN')\n})\n\ntest('function inside object 1', () => {\n  const obj = {\n    f(){\n      return 4\n    },\n  }\n\n  expect(type(obj.f)).toBe('Function')\n  expect(ramdaType(obj.f)).toBe('Function')\n})\n\ntest('function inside object 2', () => {\n  const name = 'f'\n  const obj = {\n    [ name ](){\n      return 4\n    },\n  }\n  expect(type(obj.f)).toBe('Function')\n  expect(ramdaType(obj.f)).toBe('Function')\n})\n"
  },
  "uniq": {
    "explanation": "It returns a new array containing only one copy of each element in `arr`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('uniq', function() {\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.uniq([-0, -0]).length, 1);\n    eq(R.uniq([0, -0]).length, 2);\n    eq(R.uniq([NaN, NaN]).length, 1);\n    eq(R.uniq([[1], [1]]).length, 1);\n    eq(R.uniq([new Just([42]), new Just([42])]).length, 1);\n  it('handles null and undefined elements', function() {\n    eq(R.uniq([void 0, null, void 0, null]), [void 0, null]);\n  it('uses reference equality for functions', function() {\n    eq(R.uniq([R.add, R.identity, R.add, R.identity, R.add, R.identity]).length, 2);\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "UNIQ",
        "date": "2019-11-13T11:33:20.601Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 92373,
            "margin": 1.13,
            "percentSlower": 99.56
          },
          {
            "name": "Ramda",
            "ops": 724421,
            "margin": 0.63,
            "percentSlower": 96.54
          },
          {
            "name": "Lodash",
            "ops": 20921331,
            "margin": 1.19,
            "percentSlower": 0
          }
        ],
        "fastest": {
          "name": "Lodash",
          "index": 2
        },
        "slowest": {
          "name": "Rambda",
          "index": 0
        }
      },
      "spec": "const _ = require('lodash')\nconst R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst list = [ 4, 1, 3, 5, 4, 2, 3, 4 ]\n\nconst uniq = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.uniq(list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.uniq(list)\n    },\n  },\n  {\n    label : 'Lodash',\n    fn    : () => {\n      _.uniq(list)\n    },\n  },\n]\n\nmodule.exports = uniq\n"
    },
    "typingSpec": "import { uniq } from 'rambda'\n\ndescribe('uniq', () => {\n  it('happy', () => {\n\n    const result = uniq([ 1, 2, 3, 3, 3, 1, 2, 0 ])\n    result // $ExpectType number[]\n  });\n});\n",
    "methodName": "uniq",
    "example": "R.uniq([1, 1, 2, 1])\n// => [1, 2]",
    "code": "import { includes } from './includes'\n\nexport function uniq(list){\n  let index = -1\n  const willReturn = []\n\n  while (++index < list.length){\n    const value = list[ index ]\n\n    if (!includes(value, willReturn)){\n      willReturn.push(value)\n    }\n  }\n\n  return willReturn\n}",
    "spec": "import { uniq } from './uniq'\n\ntest('uniq', () => {\n  expect(uniq([ 1, 2, 3, 3, 3, 1, 2, 0 ])).toEqual([ 1, 2, 3, 0 ])\n  expect(uniq([ 1, 1, 2, 1 ])).toEqual([ 1, 2 ])\n  expect([ 1, '1' ]).toEqual([ 1, '1' ])\n  expect(uniq([ [ 42 ], [ 42 ] ])).toEqual([ [ 42 ] ])\n})\n"
  },
  "uniqWith": {
    "explanation": "It returns a new array containing only one copy of each element in `arr` according to boolean returning function `fn`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { uniqWith } from 'rambda'\n\ndescribe('uniqWith', () => {\n  it('happy', () => {\n    const input = [\n      {\n        id    : 0,\n        title : 'foo',\n      },\n      {\n        id    : 1,\n        title : 'bar',\n      },\n      {\n        id    : 2,\n        title : 'baz',\n      },\n      {\n        id    : 3,\n        title : 'foo',\n      },\n      {\n        id    : 4,\n        title : 'bar',\n      },\n    ]\n  \n  \n    const fn = (x:any, y:any) => x.title === y.title\n  \n    const result = uniqWith(fn, input)\n    result // $ExpectType { id: number; title: string; }[]\n  });\n});\n",
    "methodName": "uniqWith",
    "example": "const arr = [\n  {id: 0, title:'foo'},\n  {id: 1, title:'bar'},\n  {id: 2, title:'baz'},\n  {id: 3, title:'foo'},\n  {id: 4, title:'bar'},\n]\n\nconst expectedResult = [\n  {id: 0, title:'foo'},\n  {id: 1, title:'bar'},\n  {id: 2, title:'baz'},\n]\n\nconst fn = (x,y) => x.title === y.title\n\nconst result = R.uniqWith(fn, arr)\n\nconsole.log(R.equals(result, expectedResult)) // => true",
    "code": "import { any } from './any'\n\nexport function uniqWith(fn, list){\n  if (arguments.length === 1) return _list => uniqWith(fn, _list)\n\n  let index = -1\n  const len = list.length\n  const willReturn = []\n\n  while (++index < len){\n    const value = list[ index ]\n    const flag = any(willReturnInstance => fn(value, willReturnInstance),\n      willReturn)\n\n    if (!flag){\n      willReturn.push(value)\n    }\n  }\n\n  return willReturn\n}",
    "spec": "import { uniqWith } from './uniqWith'\n\ntest('happy', () => {\n  const input = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n    {\n      id    : 3,\n      title : 'foo',\n    },\n    {\n      id    : 4,\n      title : 'bar',\n    },\n  ]\n\n  const expectedResult = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n  ]\n\n  const fn = (x, y) => x.title === y.title\n\n  const result = uniqWith(fn, input)\n  const curriedResult = uniqWith(fn)(input)\n\n  expect(result).toEqual(expectedResult)\n\n  expect(curriedResult).toEqual(expectedResult)\n})\n\ntest('uniqWith', () => {\n  const input = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n    {\n      id    : 3,\n      title : 'foo',\n    },\n    {\n      id    : 4,\n      title : 'bar',\n    },\n  ]\n\n  const expectedResult = [\n    {\n      id    : 0,\n      title : 'foo',\n    },\n    {\n      id    : 1,\n      title : 'bar',\n    },\n    {\n      id    : 2,\n      title : 'baz',\n    },\n  ]\n\n  const fn = (x, y) => x.title === y.title\n\n  const result = uniqWith(fn, input)\n  //const result = uniqWith(Ramda.eqBy(Ramda.prop('title')), input)\n\n  expect(result).toEqual(expectedResult)\n})\n"
  },
  "update": {
    "explanation": "It returns a new copy of the `arr` with the element at `i` index\nreplaced with `replaceValue`.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('update', function() {\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.update(2, 4, args(0, 1, 2, 3)), [0, 1, 4, 3]);\n  });\n});",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "UPDATE",
        "date": "2019-11-13T11:33:31.444Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 8121661,
            "margin": 0.78,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 979799,
            "margin": 0.45,
            "percentSlower": 87.94
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst list = [ 0, 1, 2 ]\nconst index = 1\nconst replacer = 7\n\nconst update = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.update(replacer, index, list)\n      R.update(replacer, index)(list)\n      R.update(replacer)(index)(list)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.update(replacer, index, list)\n      Ramda.update(replacer, index)(list)\n      Ramda.update(replacer)(index)(list)\n    },\n  },\n]\n\nmodule.exports = update\n"
    },
    "typingSpec": "import { update } from 'rambda'\n\ndescribe('update', () => {\n  it('happy', () => {\n    const result = update(1,0,[ 1, 2, 3 ])\n    result // $ExpectType number[]\n  });\n});\n",
    "methodName": "update",
    "example": "R.update(0, 'foo', ['bar', 'baz'])\n// => ['foo', baz]",
    "code": "export function update(\n  idx, val, list\n){\n  if (val === undefined){\n    return (_val, _list) => update(\n      idx, _val, _list\n    )\n  } else if (list === undefined){\n    return _list => update(\n      idx, val, _list\n    )\n  }\n\n  const arrClone = list.slice()\n\n  return arrClone.fill(\n    val, idx, idx + 1\n  )\n}",
    "spec": "import { update } from './update'\n\ntest('update', () => {\n  expect(update(1)(0)([ 1, 2, 3 ])).toEqual([ 1, 0, 3 ])\n  expect(update(\n    1, 11, [ 0, 1, 2 ]\n  )).toEqual([ 0, 11, 2 ])\n})\n"
  },
  "values": {
    "explanation": "It returns array with of all values in `obj`.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { values } from 'rambda'\n\ndescribe('values', () => {\n  it('happy', () => {\n    const result = values({\n      a : 1,\n      b : 2,\n      c : 3,\n    })\n    result // $ExpectType number[]\n  });\n});\n",
    "methodName": "values",
    "example": "R.values({a: 1, b: 2})\n// => [1, 2]",
    "code": "import { type } from './type.js'\n\nexport function values(obj){\n  if (type(obj) !== 'Object') return []\n\n  return Object.values(obj)\n}",
    "spec": "import { values } from './values'\n\ntest('happy', () => {\n  expect(values({\n    a : 1,\n    b : 2,\n    c : 3,\n  })).toEqual([ 1, 2, 3 ])\n})\n\ntest('with bad input', () => {\n  expect(values(null)).toEqual([])\n  expect(values(undefined)).toEqual([])\n  expect(values(55)).toEqual([])\n  expect(values('foo')).toEqual([])\n  expect(values(true)).toEqual([])\n  expect(values(false)).toEqual([])\n  expect(values(NaN)).toEqual([])\n  expect(values(Infinity)).toEqual([])\n  expect(values([])).toEqual([])\n})\n"
  },
  "view": {
    "explanation": "Returns the value at the lenses focus on the target object.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {
      "result": {
        "name": "VIEW",
        "date": "2020-02-16T11:23:11.446Z",
        "version": null,
        "results": [
          {
            "name": "Rambda",
            "ops": 3260721,
            "margin": 1.38,
            "percentSlower": 0
          },
          {
            "name": "Ramda",
            "ops": 999314,
            "margin": 0.55,
            "percentSlower": 69.35
          }
        ],
        "fastest": {
          "name": "Rambda",
          "index": 0
        },
        "slowest": {
          "name": "Ramda",
          "index": 1
        }
      },
      "spec": "const R = require('../dist/rambda.js')\nconst Ramda = require('ramda')\n\nconst testObj = { a: 1 }\n\nconst last = [\n  {\n    label : 'Rambda',\n    fn    : () => {\n      R.view(R.lensProp('a'), testObj)\n    },\n  },\n  {\n    label : 'Ramda',\n    fn    : () => {\n      Ramda.view(Ramda.lensProp('a'), testObj)\n    },\n  },\n]\n\nmodule.exports = last\n"
    },
    "typingSpec": "",
    "methodName": "view",
    "example": "const xLens = R.lensProp('x')\n\nR.view(xLens, {x: 1, y: 2}) //=> 1\nR.view(xLens, {x: 4, y: 2}) //=> 4",
    "code": "const Const = x => ({\n  x,\n  map : fn => Const(x),\n})\n\nexport function view(lens, target){\n  if (arguments.length === 1)\n    return _target => view(lens, _target)\n\n  return lens(Const)(target).x\n}",
    "spec": ""
  },
  "without": {
    "explanation": "It will return a new array based on `b` array.\n\nThis array contains all members of `b` array, that doesn't exist in `a` array.\n\nMethod `R.equals` is used to determine the existance of `b` members in `a` array.",
    "ramdaDiff": "var R = require('../../../../../rambda/dist/rambda.js');\nvar eq = require('./shared/eq');\n\ndescribe('without', function() {\n  it('can act as a transducer', function() {\n    eq(R.into([], R.without([1]), [1]), []);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.without([0], [-0]).length, 1);\n    eq(R.without([-0], [0]).length, 1);\n    eq(R.without([NaN], [NaN]).length, 0);\n    eq(R.without([[1]], [[1]]).length, 0);\n    eq(R.without([new Just([42])], [new Just([42])]).length, 0);\n  });\n});",
    "typing": "",
    "benchmark": {},
    "typingSpec": "",
    "methodName": "without",
    "example": "R.without([1, 2], [1, 2, 3, 4])\n// => [3, 4]",
    "code": "import { includes } from './includes'\nimport { reduce } from './reduce'\n\nexport function without(left, right){\n  if (right === undefined){\n    return _right => without(left, _right)\n  }\n\n  return reduce(\n    (accum, item) =>\n      includes(item, left) ? accum : accum.concat(item),\n    [],\n    right\n  )\n}",
    "spec": "import { without } from './without'\n\ntest('should return a new list without values in the first argument ', () => {\n  const itemsToOmit = [ 'A', 'B', 'C' ]\n  const collection = [ 'A', 'B', 'C', 'D', 'E', 'F' ]\n\n  expect(without(itemsToOmit, collection)).toEqual([ 'D', 'E', 'F' ])\n  expect(without(itemsToOmit)(collection)).toEqual([ 'D', 'E', 'F' ])\n})\n\ntest('ramda test', () => {\n  expect(without([ 1, 2 ])([ 1, 2, 1, 3, 4 ])).toEqual([ 3, 4 ])\n})\n"
  },
  "xor": {
    "explanation": "Logical xor function",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { xor } from 'rambda'\n\ndescribe('xor', () => {\n  it('happy', () => {\n    xor(true, false); // $ExpectType boolean\n  });\n  it('curry', () => {\n    xor(true)(false); // $ExpectType boolean\n  });\n});\n",
    "methodName": "xor",
    "example": "R.xor(false, true)\n// => true\n\nR.xor(true, true)\n// => false",
    "code": "export function xor(a, b){\n  if (arguments.length === 1) return _b => xor(a, _b)\n\n  return Boolean(a) && !b || Boolean(b) && !a\n}",
    "spec": "import { xor } from './xor'\n\ntest('compares two values with exclusive or', () => {\n  expect(xor(true, true)).toEqual(false)\n  expect(xor(true, false)).toEqual(true)\n  expect(xor(false, true)).toEqual(true)\n  expect(xor(false, false)).toEqual(false)\n})\n\ntest('when both values are truthy, it should return false', () => {\n  expect(xor(true, 'foo')).toEqual(false)\n  expect(xor(42, true)).toEqual(false)\n  expect(xor('foo', 42)).toEqual(false)\n  expect(xor({}, true)).toEqual(false)\n  expect(xor(true, [])).toEqual(false)\n  expect(xor([], {})).toEqual(false)\n  expect(xor(new Date(), true)).toEqual(false)\n  expect(xor(true, Infinity)).toEqual(false)\n  expect(xor(Infinity, new Date())).toEqual(false)\n})\n\ntest('when both values are falsy, it should return false', () => {\n  expect(xor(null, false)).toEqual(false)\n  expect(xor(false, undefined)).toEqual(false)\n  expect(xor(undefined, null)).toEqual(false)\n  expect(xor(0, false)).toEqual(false)\n  expect(xor(false, NaN)).toEqual(false)\n  expect(xor(NaN, 0)).toEqual(false)\n  expect(xor('', false)).toEqual(false)\n})\n\ntest('when one argument is truthy and the other is falsy, it should return true', () => {\n  expect(xor('foo', null)).toEqual(true)\n  expect(xor(null, 'foo')).toEqual(true)\n  expect(xor(undefined, 42)).toEqual(true)\n  expect(xor(42, undefined)).toEqual(true)\n  expect(xor(Infinity, NaN)).toEqual(true)\n  expect(xor(NaN, Infinity)).toEqual(true)\n  expect(xor({}, '')).toEqual(true)\n  expect(xor('', {})).toEqual(true)\n  expect(xor(new Date(), 0)).toEqual(true)\n  expect(xor(0, new Date())).toEqual(true)\n  expect(xor([], null)).toEqual(true)\n  expect(xor(undefined, [])).toEqual(true)\n})\n\ntest.skip('returns a curried function', () => {\n  expect(xor()(true)(true)).toEqual(false)\n  expect(xor()(true)(false)).toEqual(true)\n  expect(xor()(false)(true)).toEqual(true)\n  expect(xor()(false)(false)).toEqual(false)\n})\n"
  },
  "zip": {
    "explanation": "It will return a new array containing tuples of equally positions items from both lists. The returned list will be truncated to match the length of the shortest supplied list.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { zip } from 'rambda'\n\ndescribe('zip', () => {\n  it('happy', () => {\nconst array1 = [ 1, 2, 3 ]\nconst array2 = [ 'A', 'B', 'C' ]\n\n  const result = zip(array1)(array2)\n    result // $ExpectType KeyValuePair<number, string>[]\n  });\n});\n",
    "methodName": "zip",
    "example": "R.zip([1, 2], ['A', 'B'])\n// => [[1, 'A'], [2, 'B']]\n\n// truncates to shortest list\nR.zip([1, 2, 3, 4], ['A', 'B'])\n// => [[1, 'A'], [2, 'B']]",
    "code": "export function zip(left, right){\n  if (arguments.length === 1) return _right => zip(left, _right)\n\n  const result = []\n  const length = Math.min(left.length, right.length)\n\n  for (let i = 0; i < length; i++){\n    result[ i ] = [ left[ i ], right[ i ] ]\n  }\n\n  return result\n}",
    "spec": "import { zip } from './zip'\n\nconst array1 = [ 1, 2, 3 ]\nconst array2 = [ 'A', 'B', 'C' ]\n\ntest('should return an array', () => {\n  const actual = zip(array1)(array2)\n  expect(actual).toBeInstanceOf(Array)\n})\n\ntest('should return and array or tuples', () => {\n  const expected = [ [ 1, 'A' ], [ 2, 'B' ], [ 3, 'C' ] ]\n  const actual = zip(array1, array2)\n  expect(actual).toEqual(expected)\n})\n\ntest('should truncate result to length of shorted input list', () => {\n  const expectedA = [ [ 1, 'A' ], [ 2, 'B' ] ]\n  const actualA = zip([ 1, 2 ], array2)\n  expect(actualA).toEqual(expectedA)\n\n  const expectedB = [ [ 1, 'A' ], [ 2, 'B' ] ]\n  const actualB = zip(array1, [ 'A', 'B' ])\n  expect(actualB).toEqual(expectedB)\n})\n"
  },
  "zipObj": {
    "explanation": "It will return a new object with keys of `a` array and values of `b` array.",
    "ramdaDiff": "",
    "typing": "",
    "benchmark": {},
    "typingSpec": "import { zipObj } from 'rambda'\n\ndescribe('zipObj', () => {\n  it('happy', () => {\n    const result = zipObj([ 'a', 'b', 'c', 'd', 'e', 'f' ], [ 1, 2, 3 ])\n    result // $ExpectType { [index: string]: number; }\n  });\n});\n",
    "methodName": "zipObj",
    "example": "R.zipObj(['a', 'b', 'c'], [1, 2, 3])\n//=> {a: 1, b: 2, c: 3}\n\n// truncates to shortest list\nR.zipObj(['a', 'b', 'c'], [1, 2])\n//=> {a: 1, b: 2}",
    "code": "import { take } from './take'\n\nexport function zipObj(keys, values){\n  if (arguments.length === 1) return yHolder => zipObj(keys, yHolder)\n\n  return take(values.length, keys).reduce((\n    prev, xInstance, i\n  ) => {\n    prev[ xInstance ] = values[ i ]\n\n    return prev\n  }, {})\n}",
    "spec": "import { equals } from './equals'\nimport { zipObj } from './zipObj'\n\ntest('zipObj', () => {\n  expect(zipObj([ 'a', 'b', 'c' ], [ 1, 2, 3 ])).toEqual({\n    a : 1,\n    b : 2,\n    c : 3,\n  })\n})\n\ntest('0', () => {\n  expect(zipObj([ 'a', 'b' ])([ 1, 2, 3 ])).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('1', () => {\n  expect(zipObj([ 'a', 'b', 'c' ])([ 1, 2 ])).toEqual({\n    a : 1,\n    b : 2,\n  })\n})\n\ntest('ignore extra keys', () => {\n  const result = zipObj([ 'a', 'b', 'c', 'd', 'e', 'f' ], [ 1, 2, 3 ])\n  const expected = {\n    a : 1,\n    b : 2,\n    c : 3,\n  }\n\n  expect(equals(result, expected)).toBeTrue()\n})\n"
  }
}